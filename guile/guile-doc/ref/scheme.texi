@page
@node Guile and R5RS Scheme
@chapter Guile and R5RS Scheme

Guile's core language is Scheme, which is specified and described in the
series of reports known as @dfn{RnRS}.  @dfn{RnRS} is shorthand for the
@dfn{Revised^n Report on the Algorithmic Language Scheme}.  The current
latest revision of RnRS is version 5 (@pxref{Top,R5RS,,r5rs}), and Guile 1.4
is fully compliant with the Scheme specification in this revision.

But Guile, like most Scheme implementations, also goes beyond R5RS in
many ways, because R5RS does not give specifications (or even
recommendations) regarding many issues that are important in practical
programming.  Some of the areas where Guile goes beyond R5RS are:

@itemize @bullet
@item
Guile's interactive documentation system

@item
Guile's support for POSIX-compliant network programming

@item
GOOPS -- Guile's framework for object oriented programming.
@end itemize

This reference manual documents all of Guile's Scheme-level language and
features in functionally-related groups.  Where a particular section of
the manual includes both R5RS-compliant parts and Guile-specific
extensions, the text indicates which parts of the documentation describe
R5RS behaviour and which parts describe Guile extensions.

For a breakdown of Guile's core language and features in terms of what
is R5RS-compliant and what is Guile-specific, see the corresponding
indices: @ref{R5RS Index} and @ref{Guile Extensions Index}.


@page
@node About Data
@chapter Data Types, Values and Variables

In this and the next few chapters, we begin by introducing the basic
concepts of the Scheme language.  This chapter discusses the
representation of data types and values, what it means for Scheme to be
a @dfn{latently typed} language, and the role of variables.  We conclude
by introducing the Scheme syntaxes for defining a new variable, and for
changing the value of an existing variable.
 
@menu
* Latent Typing::               Scheme as a "latently typed" language.
* Values and Variables::        About data types, values and variables.
* Definition::                  Defining variables and setting their values.
@end menu


@node Latent Typing
@section Latent Typing

The term @dfn{latent typing} is used to descibe a computer language,
such as Scheme, for which you cannot, @emph{in general}, simply look at
a program's source code and determine what type of data will be
associated with a particular variable, or with the result of a
particular expression.

Sometimes, of course, you @emph{can} tell from the code what the type of
an expression will be.  If you have a line in your program that sets the
variable @code{x} to the numeric value 1, you can be certain that,
immediately after that line has executed (and in the absence of multiple
threads), @code{x} has the numeric value 1.  Or if you write a procedure
that is designed to concatenate two strings, it is likely that the rest
of your application will always invoke this procedure with two string
parameters, and quite probable that the procedure would go wrong in some
way if it was ever invoked with parameters that were not both strings.

Nevertheless, the point is that there is nothing in Scheme which
requires the procedure parameters always to be strings, or @code{x}
always to hold a numeric value, and there is no way of declaring in your
program that such constraints should always be obeyed.  In the same
vein, there is no way to declare the expected type of a procedure's
return value.

Instead, the types of variables and expressions are only known - in
general - at run time.  If you @emph{need} to check at some point that a
value has the expected type, Scheme provides run time procedures that
you can invoke to do so.  But equally, it can be perfectly valid for two
separate invocations of the same procedure to specify arguments with
different types, and to return values with different types.

The next section explains what this means in practice, for the ways
that Scheme programs use data types, values and variables.


@node Values and Variables
@section Values and Variables

Scheme provides many data types that you can use to represent your data.
Primitive types include characters, strings, numbers and procedures.
Compound types, which allow a group of primitive and compound values to
be stored together, include lists, pairs, vectors and multi-dimensional
arrays.  In addition, Guile allows applications to define their own data
types, with the same status as the built-in standard Scheme types.

As a Scheme program runs, values of all types pop in and out of
existence.  Sometimes values are stored in variables, but more commonly
they pass seamlessly from being the result of one computation to being
one of the parameters for the next.

Consider an example.  A string value is created because the interpreter
reads in a literal string from your program's source code.  Then a
numeric value is created as the result of calculating the length of the
string.  A second numeric value is created by doubling the calculated
length.  Finally the program creates a list with two elements -- the
doubled length and the original string itself -- and stores this list in
a program variable.

All of the values involved here -- in fact, all values in Scheme --
carry their type with them.  In other words, every value ``knows,'' at
runtime, what kind of value it is.  A number, a string, a list,
whatever.

A variable, on the other hand, has no fixed type.  A variable --
@code{x}, say -- is simply the name of a location -- a box -- in which
you can store any kind of Scheme value.  So the same variable in a
program may hold a number at one moment, a list of procedures the next,
and later a pair of strings.  The ``type'' of a variable -- insofar as
the idea is meaningful at all -- is simply the type of whatever value
the variable happens to be storing at a particular moment.


@node Definition
@section Defining and Setting Variables

To define a new variable, you use Scheme's @code{define} syntax like
this:

@lisp
(define @var{variable-name} @var{value})
@end lisp

This makes a new variable called @var{variable-name} and stores
@var{value} in it as the variable's initial value.  For example:

@lisp
;; Make a variable `x' with initial numeric value 1.
(define x 1)

;; Make a variable `organization' with an initial string value.
(define organization "Free Software Foundation")
@end lisp

(In Scheme, a semicolon marks the beginning of a comment that continues
until the end of the line.  So the lines beginning @code{;;} are
comments.)

Changing the value of an already existing variable is very similar,
except that @code{define} is replaced by the Scheme syntax @code{set!},
like this:

@lisp
(set! @var{variable-name} @var{new-value})
@end lisp

Remember that variables do not have fixed types, so @var{new-value} may
have a completely different type from whatever was previously stored in
the location named by @var{variable-name}.  Both of the following
examples are therefore correct.

@lisp
;; Change the value of `x' to 5.
(set! x 5)

;; Change the value of `organization' to the FSF's street number.
(set! organization 545)
@end lisp

In these examples, @var{value} and @var{new-value} are literal numeric
or string values.  In general, however, @var{value} and @var{new-value}
can be any Scheme expression.  Even though we have not yet covered the
forms that Scheme expressions can take (@pxref{About Expressions}), you
can probably guess what the following @code{set!} example does@dots{}

@lisp
(set! x (+ x 1))
@end lisp

Note: this is not a complete description of @code{define} and
@code{set!}, because we need to introduce some other aspects of Scheme
before the missing pieces can be filled in.  If, however, you are
already familiar with the structure of Scheme, you may like to read
about those missing pieces immediately by jumping ahead to the following
references.

@itemize @bullet
@item
@ref{Internal Definitions}, to read about using @code{define} other than
at top level in a Scheme program, including a discussion of when it
works to use @code{define} rather than @code{set!} to change the value
of an existing variable.

@item
@ref{Procedure Definitions}, to read about an alternative form of the
@code{define} syntax that can be used when defining new procedures.

@item
@ref{Generalized set!}, to read about an alternative form of the
@code{set!} syntax that helps with changing a single value in the depths
of a compound data structure.
@end itemize


@page
@node About Procedures
@chapter The Representation and Use of Procedures

This chapter introduces the basics of using and creating Scheme
procedures.  It discusses the representation of procedures as just
another kind of Scheme value, and shows how procedure invocation
expressions are constructed.  We then explain how @code{lambda} is used
to create new procedures, and conclude by presenting the various
shorthand forms of @code{define} that can be used instead of writing an
explicit @code{lambda} expression.

@menu
* Procedures as Values::        Procedures are values just like everything else.
* Simple Invocation::           How to write a straightforward procedure invocation.
* Creating a Procedure::        How to create your own procedures.
* Lambda Alternatives::         Other ways of writing procedure definitions.
@end menu


@node Procedures as Values
@section Procedures as Values

One of the great simplifications of Scheme is that a procedure is just
another type of value, and that procedure values can be passed around
and stored in variables in exactly the same way as, for example, strings
and lists.  When we talk about a built-in standard Scheme procedure such
as @code{open-input-file}, what we actually mean is that there is a
pre-defined top level variable called @code{open-input-file}, whose
value is a procedure that implements what R5RS says that
@code{open-input-file} should do.

Note that this is quite different from many dialects of Lisp ---
including Emacs Lisp --- in which a program can use the same name with
two quite separate meanings: one meaning identifies a Lisp function,
while the other meaning identifies a Lisp variable, whose value need
have nothing to do with the function that is associated with the first
meaning.  In these dialects, functions and variables are said to live in
different @dfn{namespaces}.

In Scheme, on the other hand, all names belong to a single unified
namespace, and the variables that these names identify can hold any kind
of Scheme value, including procedure values.

One consequence of this is that, if you don't happen to like the
standard name for a Scheme procedure, you can change it.

For example, @code{call-with-current-continuation} is a very important
standard Scheme procedure, but it also has a very long name!  So, many
programmers use the following definition to assign the same procedure
value to the more convenient name @code{call/cc}.

@lisp
(define call/cc call-with-current-continuation)
@end lisp

Let's undertand exactly how this works.  The definition creates a new
variable @code{call/cc}, and then sets its value to the value of the
variable @code{call-with-current-continuation}; the latter value is a
procedure that implements the behaviour that R5RS specifies under the
name ``call-with-current-continuation''.  So @code{call/cc} ends up
holding this value as well.

Now that @code{call/cc} holds the required procedure value, you could
choose to use @code{call-with-current-continuation} for a completely
different purpose, or just change its value so that you will get an
error if you accidentally use @code{call-with-current-continuation} as a
procedure in your program rather than @code{call/cc}.  For example:

@lisp
(set! call-with-current-continuation "Not a procedure any more!")
@end lisp

Or you could just leave @code{call-with-current-continuation} as it was.
It's perfectly fine for more than one variable to hold the same
procedure value.

Another benefit of Scheme's approach to procedure values is that it
simplifies the rules for creating new procedures and writing procedure
invocations, as explained in the following sections.


@node Simple Invocation
@section Simple Procedure Invocation

A procedure invocation in Scheme is written like this:

@lisp
(@var{procedure} [@var{arg1} [@var{arg2} @dots{}]])
@end lisp

In this expression, @var{procedure} can be any Scheme expression whose
value is a procedure.  Most commonly, however, @var{procedure} is simply
the name of a variable whose value is a procedure.

For example, @code{string-append} is a standard Scheme procedure whose
behaviour is to concatenate together all the arguments, which are
expected to be strings, that it is given.  So the expression

@lisp
(string-append "/home" "/" "andrew")
@end lisp

is a procedure invocation whose result is the string value
@code{"/home/andrew"}.

Similarly, @code{string-length} is a standard Scheme procedure that
returns the length of a single string argument, so

@lisp
(string-length "abc")
@end lisp

is a procedure invocation whose result is the numeric value 3.

Each of the parameters in a procedure invocation can itself be any
Scheme expression.  Since a procedure invocation is itself a type of
expression, we can put these two examples together to get

@lisp
(string-length (string-append "/home" "/" "andrew"))
@end lisp

--- a procedure invocation whose result is the numeric value 12.

(You may be wondering what happens if the two examples are combined the
other way round.  If we do this, we can make a procedure invocation
expression that is @emph{syntactically} correct:

@lisp
(string-append "/home" (string-length "abc"))
@end lisp

But when this expression is executed, it will cause an error, because
the result of @code{(string-length "abc")} is a numeric value, and
@code{string-append} is not designed to accept a numeric value as one of
its arguments.)


@node Creating a Procedure
@section Creating and Using a New Procedure

Scheme has lots of standard procedures, and Guile provides all of these
via predefined top level variables.  All of these standard procedures
are documented in the later chapters of this reference manual.

Before very long, though, you will want to create new procedures that
encapsulate aspects of your own applications' functionality.  To do
this, you can use the famous @code{lambda} syntax.

The value of the following Scheme expression ---

@lisp
(lambda (name address) @var{expression} @dots{})
@end lisp

--- is a newly created procedure that takes two arguments:
@code{name} and @code{address}.  The behaviour of the
new procedure is determined by the sequence of @var{expression}s in the
@dfn{body} of the procedure definition.  (Typically, these
@var{expression}s would use the arguments in some way, or else there
wouldn't be any point in giving them to the procedure.)  When invoked,
the new procedure returns a value that is the value of the last
@var{expression} in the procedure body.

To make things more concrete, let's suppose that the two arguments are
both strings, and that the purpose of this procedure is to form a
combined string that includes these arguments.  Then the full lambda
expression might look like this:

@lisp
(lambda (name address)
  (string-append "Name=" name ":Address=" address))
@end lisp

We noted in the previous section that the @var{procedure} part of a
procedure invocation expression can be any Scheme expression whose value
is a procedure.  But that's exactly what a lambda expression is!  So we
can use a lambda expression directly in a procedure invocation, like this:

@lisp
((lambda (name address)
   (string-append "Name=" name ":Address=" address))
 "FSF"
 "Cambridge") 
@end lisp

This is a valid procedure invocation expression, whose result is the
string @code{"Name=FSF:Address=Cambridge"}.

It it more common, though, to store the procedure value in a variable ---

@lisp
(define make-combined-string
  (lambda (name address)
    (string-append "Name=" name ":Address=" address)))
@end lisp

--- and then to use the variable name in the procedure invocation:

@lisp
(make-combined-string "FSF" "Cambridge") 
@end lisp

Which has exactly the same result.

It's important to note that procedures created using @code{lambda} have
exactly the same status as the standard built in Scheme procedures, and
can be invoked, passed around, and stored in variables in exactly the
same ways.


@node Lambda Alternatives
@section Lambda Alternatives

Since it is so common in Scheme programs to want to create a procedure
and then store it in a variable, there is an alternative form of the
@code{define} syntax that allows you to do just that.

A @code{define} expression of the form

@lisp
(define (@var{name} [@var{arg1} [@var{arg2} @dots{}]])
  @var{expression} @dots{})
@end lisp

is exactly equivalent to the longer form

@lisp
(define @var{name}
  (lambda ([@var{arg1} [@var{arg2} @dots{}]])
    @var{expression} @dots{}))
@end lisp

So, for example, the definition of @code{make-combined-string} in the
previous section could equally be written:

@lisp
(define (make-combined-string name address)
  (string-append "Name=" name ":Address=" address))
@end lisp

This kind of procedure definition creates a procedure that requires
exactly the expected number of arguments.  There are two further forms
of the @code{lambda} expression, which create a procedure that can
accept a variable number of arguments:

@lisp
(lambda (@var{arg1} @dots{} . @var{args}) @var{expression} @dots{})

(lambda @var{args} @var{expression} @dots{})
@end lisp

The corresponding forms of the alternative @code{define} syntax are:

@lisp
(define (@var{name} @var{arg1} @dots{} . @var{args}) @var{expression} @dots{})

(define (@var{name} . @var{args}) @var{expression} @dots{})
@end lisp

For details on how these forms work, see @xref{Procedures}.

(It could be argued that the alternative @code{define} forms are rather
confusing, especially for newcomers to the Scheme language, as they hide
both the role of @code{lambda} and the fact that procedures are values
that are stored in variables in the some way as any other kind of value.
On the other hand, they are very convenient, and they are also a good
example of another of Scheme's powerful features: the ability to specify
arbitrary syntactic transformations at run time, which can be applied to
subsequently read input.)


@page
@node About Expressions
@chapter About Expressions

@menu
* Evaluating::                  Results and side effects of Scheme expressions.
* Internal Definitions::
* Procedure Definitions::
* Generalized set!::
@end menu


@node Evaluating
@section Evaluating Expressions


@node Internal Definitions
@section Internal Definitions

Somewhere here, we need to cover the difference between

@lisp
(define a 1)
(let () (define a 4) a)
a
@end lisp

and

@lisp
(define a 1)
(let () (set! a 4) a)
a
@end lisp

--- this is referenced from @xref{Definition}.


@node Procedure Definitions
@section Procedure Definitions


@node Generalized set!
@section Generalized set!


@page
@node Options
@chapter Options

Guile's behaviour can be modified by setting options.  For example, is
the language that Guile accepts case sensitive, or should the debugger
automatically show a backtrace on error?

Guile has two levels of interface for managing options: a low-level
control interface, and a user-level interface which allows the enabling
or disabling of options.

Moreover, the options are classified in groups according to whether they
configure @emph{reading}, @emph{printing}, @emph{debugging} or
@emph{evaluating}.

@menu
* General option interface::
* Reader options::
* Printing options::
* Debugger options::
* Evaluator options::
* Examples of option use::
@end menu

@node General option interface
@section General option interface

We will use the expression @code{<group>} to represent @code{read},
@code{print}, @code{debug} or @code{evaluator}.

@subheading Low level

@c NJFIXME
@deffn primitive <group>-options-interface
@deffnx primitive read-options-interface [SOME-INT]
@deffnx primitive print-options-interface [SOME-INT]
@deffnx primitive evaluator-traps-interface [SOME-INT]
@deffnx primitive read-options-interface [SOME-INT]
[FIXME: I have just taken the comments for C routine scm_options that
implements all of these.  It needs to be presented better.]

If scm_options is called without arguments, the current option setting
is returned.  If the argument is an option setting, options are altered
and the old setting is returned.  If the argument isn't a list, a list
of sublists is returned, where each sublist contains option name, value
and documentation string.
@end deffn


@subheading User level

@c @deftp {Data type} scm_option
@c @code{scm_option} is used to represent run time options.  It can be a
@c @emph{boolean} type, in which case the option will be set by the strings
@c @code{"yes"} and @code{"no"}.  It can be a
@c @end deftp

@c NJFIXME
@deffn procedure <group>-options [arg]
@deffnx procedure read-options [arg]
@deffnx procedure print-options [arg]
@deffnx procedure debug-options [arg]
@deffnx procedure traps [arg]
These functions list the options in their group.  The optional argument
@var{arg} is a symbol which modifies the form in which the options are
presented.

With no arguments, @code{<group>-options} returns the values of the
options in that particular group.  If @var{arg} is @code{'help}, a
description of each option is given.  If @var{arg} is @code{'full},
programmers' options are also shown.

@var{arg} can also be a list representing the state of all options.  In
this case, the list contains single symbols (for enabled boolean
options) and symbols followed by values.
@end deffn
[FIXME: I don't think 'full is ever any different from 'help.  What's
up?]

@c NJFIXME
@deffn procedure <group>-enable option-symbol
@deffnx procedure read-enable option-symbol
@deffnx procedure print-enable option-symbol
@deffnx procedure debug-enable option-symbol
@deffnx procedure trap-enable option-symbol
These functions set the specified @var{option-symbol} in their options
group.  They only work if the option is boolean, and throw an error
otherwise.
@end deffn

@c NJFIXME
@deffn procedure <group>-disable option-symbol
@deffnx procedure read-disable option-symbol
@deffnx procedure print-disable option-symbol
@deffnx procedure debug-disable option-symbol
@deffnx procedure trap-disable option-symbol
These functions turn off the specified @var{option-symbol} in their
options group.  They only work if the option is boolean, and throw an
error otherwise.
@end deffn

@c NJFIXME
@deffn syntax <group>-set! option-symbol value
@deffnx syntax read-set! option-symbol value
@deffnx syntax print-set! option-symbol value
@deffnx syntax debug-set! option-symbol value
@deffnx syntax trap-set! option-symbol value
These functions set a non-boolean @var{option-symbol} to the specified
@var{value}.
@end deffn


@node Reader options
@section Reader options
@cindex options - read
@cindex read options

Here is the list of reader options generated by typing
@code{(read-options 'full)} in Guile.  You can also see the default
values.
@smalllisp
keywords         #f      Style of keyword recognition: #f or 'prefix
case-insensitive no      Convert symbols to lower case.
positions        yes     Record positions of source code expressions.
copy             no      Copy source code expressions.
@end smalllisp

Notice that while Standard Scheme is case insensitive, to ease
translation of other Lisp dialects, notably Emacs Lisp, into Guile,
Guile is case-sensitive by default.

To make Guile case insensitive, you can type
@smalllisp
(read-enable 'case-insensitive)
@end smalllisp

@node Printing options
@section Printing options

Here is the list of print options generated by typing
@code{(print-options 'full)} in Guile.  You can also see the default
values.
@smallexample
source          no      Print closures with source.
closure-hook    #f      Hook for printing closures.
@end smallexample


@node Evaluator options
@section Evaluator options

Here is the list of print options generated by typing
@code{(traps 'full)} in Guile.  You can also see the default
values.
@smallexample
exit-frame      no      Trap when exiting eval or apply.
apply-frame     no      Trap when entering apply.
enter-frame     no      Trap when eval enters new frame.
@end smallexample


@node Debugger options
@section Debugger options

Here is the list of print options generated by typing
@code{(debug-options 'full)} in Guile.  You can also see the default
values.
@smallexample
stack           20000   Stack size limit (0 = no check).
debug           yes     Use the debugging evaluator.
backtrace       no      Show backtrace on error.
depth           20      Maximal length of printed backtrace.
maxdepth        1000    Maximal number of stored backtrace frames.
frames          3       Maximum number of tail-recursive frames in backtrace.
indent          10      Maximal indentation in backtrace.
backwards       no      Display backtrace in anti-chronological order.
procnames       yes     Record procedure names at definition.
trace           no      *Trace mode.
breakpoints     no      *Check for breakpoints.
cheap           yes     *Flyweight representation of the stack at traps.
@end smallexample


@node Examples of option use
@section Examples of option use

Here is an example of a session in which some read and debug option
handling procedures are used.  In this example, the user

@enumerate
@item
Notices that the symbols @code{abc} and @code{aBc} are not the same
@item
Examines the @code{read-options}, and sees that @code{case-insensitive}
is set to ``no''.
@item
Enables @code{case-insensitive}
@item
Verifies that now @code{aBc} and @code{abc} are the same
@item
Disables @code{case-insensitive} and enables debugging @code{backtrace}
@item
Reproduces the error of displaying @code{aBc} with backtracing enabled
[FIXME: this last example is lame because there is no depth in the
backtrace.  Need to give a better example, possibly putting debugging
option examples in a separate session.]
@end enumerate


@smalllisp
guile> (define abc "hello")
guile> abc
"hello"
guile> aBc
ERROR: In expression aBc:
ERROR: Unbound variable: aBc
ABORT: (misc-error)

Type "(backtrace)" to get more information.
guile> (read-options 'help)
keywords	#f	Style of keyword recognition: #f or 'prefix
case-insensitive	no	Convert symbols to lower case.
positions	yes	Record positions of source code expressions.
copy		no	Copy source code expressions.
guile> (debug-options 'help)
stack		20000	Stack size limit (0 = no check).
debug		yes	Use the debugging evaluator.
backtrace	no	Show backtrace on error.
depth		20	Maximal length of printed backtrace.
maxdepth	1000	Maximal number of stored backtrace frames.
frames		3	Maximum number of tail-recursive frames in backtrace.
indent		10	Maximal indentation in backtrace.
backwards	no	Display backtrace in anti-chronological order.
procnames	yes	Record procedure names at definition.
trace		no	*Trace mode.
breakpoints	no	*Check for breakpoints.
cheap		yes	*Flyweight representation of the stack at traps.
guile> (read-enable 'case-insensitive)
(keywords #f case-insensitive positions)
guile> aBc
"hello"
guile> (read-disable 'case-insensitive)
(keywords #f positions)
guile> (debug-enable 'backtrace)
(stack 20000 debug backtrace depth 20 maxdepth 1000 frames 3 indent 10 procnames cheap)
guile> aBc

Backtrace:
0* aBc

ERROR: In expression aBc:
ERROR: Unbound variable: aBc
ABORT: (misc-error)
guile>
@end smalllisp


@page
@node Read Syntax Extensions
@chapter Read Syntax Extensions

@menu
* Block Comments::
* Interpreter Triggers::
* Case Sensitivity::
* Keywords::                    Self-quoting, customizable display keywords.
@end menu

@node Block Comments
@section Block Comments

@node Interpreter Triggers
@section Interpreter Triggers

@node Case Sensitivity
@section Case Sensitivity

@node Keywords
@section Keywords

Keywords are self-evaluating objects with a convenient read syntax that
makes them easy to type.

Guile's keyword support conforms to R4RS, and adds a (switchable) read
syntax extension to permit keywords to begin with @code{:} as well as
@code{#:}.

@menu
* Why Use Keywords?::
* Coding With Keywords::
* Keyword Read Syntax::
* Keyword Primitives::
@end menu

@node Why Use Keywords?
@subsection Why Use Keywords?

Keywords are useful in contexts where a program or procedure wants to be
able to accept a large number of optional arguments without making its
interface unmanageable.

To illustrate this, consider a hypothetical @code{make-window}
procedure, which creates a new window on the screen for drawing into
using some graphical toolkit.  There are many parameters that the caller
might like to specify, but which could also be sensibly defaulted, for
example:

@itemize @bullet
@item
colour depth -- Default: the colour depth for the screen

@item
background colour -- Default: white

@item
width -- Default: 600

@item
height -- Default: 400
@end itemize

If @code{make-window} did not use keywords, the caller would have to
pass in a value for each possible argument, remembering the correct
argument order and using a special value to indicate the default value
for that argument:

@lisp
(make-window 'default              ;; Colour depth
             'default              ;; Background colour
             800                   ;; Width
             100                   ;; Height
             @dots{})                  ;; More make-window arguments
@end lisp

With keywords, on the other hand, defaulted arguments are omitted, and
non-default arguments are clearly tagged by the appropriate keyword.  As
a result, the invocation becomes much clearer:

@lisp
(make-window #:width 800 #:height 100)
@end lisp

On the other hand, for a simpler procedure with few arguments, the use
of keywords would be a hindrance rather than a help.  The primitive
procedure @code{cons}, for example, would not be improved if it had to
be invoked as

@lisp
(cons #:car x #:cdr y)
@end lisp

So the decision whether to use keywords or not is purely pragmatic: use
them if they will clarify the procedure invocation at point of call.

@node Coding With Keywords
@subsection Coding With Keywords

If a procedure wants to support keywords, it should take a rest argument
and then use whatever means is convenient to extract keywords and their
corresponding arguments from the contents of that rest argument.

The following example illustrates the principle: the code for
@code{make-window} uses a helper procedure called
@code{get-keyword-value} to extract individual keyword arguments from
the rest argument.

@lisp
(define (get-keyword-value args keyword default)
  (let ((kv (memq keyword args)))
    (if (and kv (>= (length kv) 2))
        (cadr kv)
        default)))

(define (make-window . args)
  (let ((depth  (get-keyword-value args #:depth  screen-depth))
        (bg     (get-keyword-value args #:bg     "white"))
        (width  (get-keyword-value args #:width  800))
        (height (get-keyword-value args #:height 100))
        @dots{})
    @dots{}))
@end lisp

But you don't need to write @code{get-keyword-value}.  The @code{(ice-9
optargs)} module provides a set of powerful macros that you can use to
implement keyword-supporting procedures like this:

@lisp
(use-modules (ice-9 optargs))

(define (make-window . args)
  (let-keywords args #f ((depth  screen-depth)
                         (bg     "white")
                         (width  800)
                         (height 100))
    ...))
@end lisp

Or, even more economically, like this:

@lisp
(use-modules (ice-9 optargs))

(define* (make-window #:key (depth  screen-depth)
                            (bg     "white")
                            (width  800)
                            (height 100))
  ...)
@end lisp

For further details on @code{let-keywords}, @code{define*} and other
facilities provided by the @code{(ice-9 optargs)} module, @ref{Optional
Arguments}.


@node Keyword Read Syntax
@subsection Keyword Read Syntax

Guile, by default, only recognizes the keyword syntax specified by R4RS.
A token of the form @code{#:NAME}, where @code{NAME} has the same syntax
as a Scheme symbol, is the external representation of the keyword named
@code{NAME}.  Keyword objects print using this syntax as well, so values
containing keyword objects can be read back into Guile.  When used in an
expression, keywords are self-quoting objects.

If the @code{keyword} read option is set to @code{'prefix}, Guile also
recognizes the alternative read syntax @code{:NAME}.  Otherwise, tokens
of the form @code{:NAME} are read as symbols, as required by R4RS.

To enable and disable the alternative non-R4RS keyword syntax, you use
the @code{read-options} procedure documented in @ref{General option
interface} and @ref{Reader options}.

@smalllisp
(read-set! keywords 'prefix)

#:type
@result{}
#:type

:type
@result{}
#:type

(read-set! keywords #f)

#:type
@result{}
#:type

:type
@result{}
ERROR: In expression :type:
ERROR: Unbound variable: :type
ABORT: (unbound-variable)
@end smalllisp

@node Keyword Primitives
@subsection Keyword Primitives

Internally, a keyword is implemented as something like a tagged symbol,
where the tag identifies the keyword as being self-evaluating, and the
symbol, known as the keyword's @dfn{dash symbol} has the same name as
the keyword name but prefixed by a single dash.  For example, the
keyword @code{#:name} has the corresponding dash symbol @code{-name}.

Most keyword objects are constructed automatically by the reader when it
reads a token beginning with @code{#:}.  However, if you need to
construct a keyword object programmatically, you can do so by calling
@code{make-keyword-from-dash-symbol} with the corresponding dash symbol
(as the reader does).  The dash symbol for a keyword object can be
retrieved using the @code{keyword-dash-symbol} procedure.

@c docstring begin (texi-doc-string "guile" "make-keyword-from-dash-symbol")
@deffn primitive make-keyword-from-dash-symbol symbol
Make a keyword object from a @var{symbol} that starts with a dash.
@end deffn

@c docstring begin (texi-doc-string "guile" "keyword?")
@deffn primitive keyword? obj
Returns @code{#t} if the argument @var{obj} is a keyword, else @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "keyword-dash-symbol")
@deffn primitive keyword-dash-symbol keyword
Return the dash symbol for @var{keyword}.
This is the inverse of @code{make-keyword-from-dash-symbol}.
@end deffn


@page
@node Optional Arguments
@chapter Optional Arguments


@page
@node Exceptions
@chapter Exceptions
@cindex error handling
@cindex exception handling


@c ARGFIXME tag/key
@c docstring begin (texi-doc-string "guile" "catch")
@deffn primitive catch tag thunk handler
Invoke @var{thunk} in the dynamic context of @var{handler} for
exceptions matching @var{key}.  If thunk throws to the symbol @var{key},
then @var{handler} is invoked this way:

@example
(handler key args ...)
@end example

@var{key} is a symbol or #t.

@var{thunk} takes no arguments.  If @var{thunk} returns normally, that
is the return value of @code{catch}.

Handler is invoked outside the scope of its own @code{catch}.  If
@var{handler} again throws to the same key, a new handler from further
up the call chain is invoked.

If the key is @code{#t}, then a throw to @emph{any} symbol will match
this call to @code{catch}.
@end deffn

@c docstring begin (texi-doc-string "guile" "throw")
@deffn primitive throw key . args
Invoke the catch form matching @var{key}, passing @var{args} to the
@var{handler}.

@var{key} is a symbol.  It will match catches of the same symbol or of
#t.

If there is no handler at all, an error is signaled.
@end deffn

@c begin (scm-doc-string "boot-9.scm" "error")
@deffn procedure error msg args @dots{}
Raise an error with key @code{misc-error} and a message constructed by
displaying @var{msg} and writing @var{args}.
@end deffn
@c end

@c ARGFIXME rest/data
@c docstring begin (texi-doc-string "guile" "scm-error")
@deffn primitive scm-error key subr message args rest
Raise an error with key @var{key}.  @var{subr} can be a string naming
the procedure associated with the error, or @code{#f}.  @var{message}
is the error message string, possibly containing @code{~S} and @code{~A}
escapes.  When an error is reported, these are replaced by formating the
corresponding members of @var{args}: @code{~A} (was @code{%s}) formats using @code{display}
and @code{~S} (was @code{%S}) formats using @code{write}.  @var{data} is a
list or @code{#f} depending on @var{key}: if @var{key} is
@code{system-error} then it should be a list
containing the Unix @code{errno} value;  If @var{key} is @code{signal} then
it should be a list containing the Unix signal number; otherwise it
will usually be @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "strerror")
@deffn primitive strerror err
Returns the Unix error message corresponding to @var{err}, an integer.
@end deffn

@c begin (scm-doc-string "boot-9.scm" "false-if-exception")
@deffn syntax false-if-exception expr
Returns the result of evaluating its argument; however
if an exception occurs then @code{#f} is returned instead.
@end deffn
@c end

@c docstring begin (texi-doc-string "guile" "lazy-catch")
@deffn primitive lazy-catch tag thunk handler
@end deffn

It is traditional in Scheme to implement exception systems using
@code{call-with-current-continuation}, but his has not been done, for
performance reasons.  The implementation of
@code{call-with-current-continuation} is a stack copying implementation.
This allows it to interact well with ordinary C code.  Unfortunately, a
stack-copying implementation can be slow -- creating a new continuation
involves a block copy of the stack.

Instead of using @code{call-with-current-continuation}, the exception
primitives are implemented as built-ins that take advantage of the
@emph{upward only} nature of exceptions.


@page
@node Modules
@chapter Modules
@cindex modules

[FIXME: somewhat babbling; should be reviewed by someone who understands
modules, once the new module system is in place]

When programs become large, naming conflicts can occur when a function
or global variable defined in one file has the same name as a function
or global variable in another file.  Even just a @emph{similarity}
between function names can cause hard-to-find bugs, since a programmer
might type the wrong function name.

The approach used to tackle this problem is called @emph{information
encapsulation}, which consists of packaging functional units into a
given name space that is clearly separated from other name spaces.
@cindex encapsulation
@cindex information encapsulation
@cindex name space

The language features that allow this are usually called @emph{the
module system} because programs are broken up into modules that are
compiled separately (or loaded separately in an interpreter).

Older languages, like C, have limited support for name space
manipulation and protection.  In C a variable or function is public by
default, and can be made local to a module with the @code{static}
keyword.  But you cannot reference public variables and functions from
another module with different names.

More advanced module systems have become a common feature in recently
designed languages: ML, Python, Perl, and Modula 3 all allow the
@emph{renaming} of objects from a foreign module, so they will not
clutter the global name space.
@cindex name space - private

@menu
* Scheme and modules::
* The Guile module system::
* Module Internals::
@end menu

@node Scheme and modules
@section Scheme and modules

Scheme, as defined in R4RS, does @emph{not} have a module system at all.

Aubrey Jaffer, mostly to support his portable Scheme library SLIB,
implemented a provide/require mechanism for many Scheme implementations.
Library files in SLIB @emph{provide} a feature, and when user programs
@emph{require} that feature, the library file is loaded in.

For example, the file @file{random.scm} in the SLIB package contains the
line
@smalllisp
(provide 'random)
@end smalllisp
so to use its procedures, a user would type
@smalllisp
(require 'random)
@end smalllisp
and they would magically become available, @emph{but still have the same
names!}  So this method is nice, but not as good as a full-featured
module system.

@node The Guile module system
@section The Guile module system

In 1996 Tom Lord implemented a full-featured module system for Guile
which allows loading Scheme source files into a private name space.

This module system is regarded as being rather idiosyncratic, and will
probably change to something more like the ML module system, so for now
I will simply descrive how it works for a couple of simple cases.

First of all, the Guile module system sets up a hierarchical name space,
and that name space can be represented like Unix pathnames preceded by a
@key{#} character.  The root name space for all Guile-supplied modules
is called @code{ice-9}.

So for example, the SLIB interface, contained in
@file{$srcdir/ice-9/slib.scm}, starts out with
@smalllisp
(define-module (ice-9 slib))
@end smalllisp
and a user program can use
@smalllisp
(use-modules (ice-9 slib))
@end smalllisp
to have access to all procedures and variables defined within the slib
module with @code{(define-public ...)}.

So here are the functions involved:
@c begin (scm-doc-string "boot-9.scm" "define-module")
@deffn syntax define-module module-specification
@var{module-specification} is of the form @code{(hierarchy file)}.  One
example of this is
@smalllisp
(use-modules (ice-9 slib))
@end smalllisp
define-module makes this module available to Guile programs under the
given @var{module-specification}.
@end deffn
@c end

@c begin (scm-doc-string "boot-9.scm" "define-public")
@deffn syntax define-public @dots{}
Makes a procedure or variable available to programs that use the current
module.
@end deffn
@c end

@c begin (scm-doc-string "boot-9.scm" "use-modules")
@deffn syntax use-modules module-specification
@var{module-specification} is of the form @code{(hierarchy file)}.  One
example of this is
@smalllisp
(use-modules (ice-9 slib))
@end smalllisp
use-modules allows the current Guile program to use all publicly defined
procedures and variables in the module denoted by
@var{module-specification}.
@end deffn
@c end

[FIXME: must say more, and explain, and also demonstrate a private name
space use, and demonstrate how one would do Python's "from Tkinter
import *" versus "import Tkinter".  Must also add something about paths
and standards for contributed modules.]

@c docstring begin (texi-doc-string "guile" "standard-eval-closure")
@deffn primitive standard-eval-closure module
@end deffn

@c docstring begin (texi-doc-string "guile" "interaction-environment")
@deffn primitive interaction-environment
This procedure returns a specifier for the environment that contains
implementation-defined bindings, typically a superset of those listed in
the report.  The intent is that this procedure will return the
environment in which the implementation would evaluate expressions
dynamically typed by the user.
@end deffn

Some modules are included in the Guile distribution; here are references
to the entries in this manual which describe them in more detail:
@table @strong
@item boot-9
boot-9 is Guile's initialization module, and it is always loaded when
Guile starts up.
@item (ice-9 debug)
Mikael Djurfeldt's source-level debugging support for Guile
(@pxref{Debugger User Interface}).
@item (ice-9 threads)
Guile's support for multi threaded execution (@pxref{Threads and Dynamic
Roots}).
@item (ice-9 slib)
This module contains hooks for using Aubrey Jaffer's portable Scheme
library SLIB from Guile (@pxref{SLIB}).
@item (ice-9 jacal)
This module contains hooks for using Aubrey Jaffer's symbolic math
packge Jacal from Guile (@pxref{JACAL}).
@end table


@page
@node Module Internals
@section Module Internals

@menu
* First-class Variables::
* First-class Modules::
* Dynamic Libraries::		Loading libraries of compiled code at run time.
@end menu

@node First-class Variables
@subsection First-class Variables

@node First-class Modules
@subsection First-class Modules

@node Dynamic Libraries
@subsection Dynamic Libraries

Often you will want to extend Guile by linking it with some existing
system library.  For example, linking Guile with a @code{curses} or
@code{termcap} library would be useful if you want to implement a
full-screen user interface for a Guile application.  However, if you
were to link Guile with these libraries at compile time, it would bloat
the interpreter considerably, affecting everyone on the system even if
the new libraries are useful only to you.  Also, every time a new
library is installed, you would have to reconfigure, recompile and
relink Guile merely in order to provide a new interface.

Many Unix systems permit you to get around this problem by using
@dfn{dynamic loading}.  When a new library is linked, it can be made a
@dfn{dynamic library} by passing certain switches to the linker.  A
dynamic library does not need to be linked with an executable image at
link time; instead, the executable may choose to load it dynamically at
run time.  This is a powerful concept that permits an executable to link
itself with almost any library without reconfiguration, if it has been
written properly.

Guile's dynamic linking functions make it relatively easy to write a
module that incorporates code from third-party object code libraries.

@c ARGFIXME fname/library-file
@c docstring begin (texi-doc-string "guile" "dynamic-link")
@deffn primitive dynamic-link fname
Open the dynamic library @var{library-file}.  A library handle
representing the opened library is returned; this handle should be used
as the @var{lib} argument to the following functions.
@end deffn

@c docstring begin (texi-doc-string "guile" "dynamic-object?")
@deffn primitive dynamic-object? obj
Return @code{#t} if @var{obj} is a dynamic library handle, or @code{#f}
otherwise.
@end deffn

@c ARGFIXME dobj/dynobj/library-handle
@c docstring begin (texi-doc-string "guile" "dynamic-unlink")
@deffn primitive dynamic-unlink dobj
Unlink the library represented by @var{library-handle},
and remove any imported symbols from the address space.
GJB:FIXME:DOC: 2nd version below:
Unlink the indicated object file from the application.  The
argument @var{dynobj} must have been obtained by a call to
@code{dynamic-link}.  After @code{dynamic-unlink} has been
called on @var{dynobj}, its content is no longer accessible.
@end deffn

@c ARGFIXME symb/func/function dobj/lib/dynobj
@c docstring begin (texi-doc-string "guile" "dynamic-func")
@deffn primitive dynamic-func symb dobj
Import the symbol @var{func} from @var{lib} (a dynamic library handle).
A @dfn{function handle} representing the imported function is returned.
GJB:FIXME:DOC: 2nd version below
Search the C function indicated by @var{function} (a string or symbol)
in @var{dynobj} and return some Scheme object that can later be used
with @code{dynamic-call} to actually call this function.  Right now,
these Scheme objects are formed by casting the address of the function
to @code{long} and converting this number to its Scheme representation.

Regardless whether your C compiler prepends an underscore @samp{_} to
the global names in a program, you should @strong{not} include this
underscore in @var{function}.  Guile knows whether the underscore is
needed or not and will add it when necessary.
@end deffn

@c ARGFIXME lib-thunk/func/function lib/dobj/dynobj
@c docstring begin (texi-doc-string "guile" "dynamic-call")
@deffn primitive dynamic-call func dobj
Call @var{lib-thunk}, a procedure of no arguments.  If @var{lib-thunk}
is a string, it is assumed to be a symbol found in the dynamic library
@var{lib} and is fetched with @code{dynamic-func}.  Otherwise, it should
be a function handle returned by a previous call to @code{dynamic-func}.
The return value is unspecified.
GJB:FIXME:DOC 2nd version below
Call the C function indicated by @var{function} and @var{dynobj}.  The
function is passed no arguments and its return value is ignored.  When
@var{function} is something returned by @code{dynamic-func}, call that
function and ignore @var{dynobj}.  When @var{function} is a string (or
symbol, etc.), look it up in @var{dynobj}; this is equivalent to

@smallexample
(dynamic-call (dynamic-func @var{function} @var{dynobj} #f))
@end smallexample

Interrupts are deferred while the C function is executing (with
@code{SCM_DEFER_INTS}/@code{SCM_ALLOW_INTS}).
@end deffn

@c ARGFIXME func/proc/function dobj/dynobj
@c docstring begin (texi-doc-string "guile" "dynamic-args-call")
@deffn primitive dynamic-args-call func dobj args
Call @var{proc}, a dynamically loaded function, passing it the argument
list @var{args} (a list of strings).  As with @code{dynamic-call},
@var{proc} should be either a function handle or a string, in which case
it is first fetched from @var{lib} with @code{dynamic-func}.

@var{proc} is assumed to return an integer, which is used as the return
value from @code{dynamic-args-call}.

GJB:FIXME:DOC 2nd version below
Call the C function indicated by @var{function} and @var{dynobj}, just
like @code{dynamic-call}, but pass it some arguments and return its
return value.  The C function is expected to take two arguments and
return an @code{int}, just like @code{main}:

@smallexample
int c_func (int argc, char **argv);
@end smallexample

The parameter @var{args} must be a list of strings and is converted into
an array of @code{char *}.  The array is passed in @var{argv} and its
size in @var{argc}.  The return value is converted to a Scheme number
and returned from the call to @code{dynamic-args-call}.
@end deffn

@c docstring begin (texi-doc-string "guile" "c-registered-modules")
@deffn primitive c-registered-modules
Return a list of the object code modules that have been imported into
the current Guile process.  Each element of the list is a pair whose
car is the name of the module, and whose cdr is the function handle
for that module's initializer function.  The name is the string that
has been passed to scm_register_module_xxx.
@end deffn

@c docstring begin (texi-doc-string "guile" "c-clear-registered-modules")
@deffn primitive c-clear-registered-modules
Destroy the list of modules registered with the current Guile process.
The return value is unspecified.  @strong{Warning:} this function does
not actually unlink or deallocate these modules, but only destroys the
records of which modules have been loaded.  It should therefore be used
only by module bookkeeping operations.
@end deffn

[FIXME: provide a brief example here of writing the C hooks for an
object code module, and using dynamic-link and dynamic-call to load the
module.]


@page
@node Evaluation
@chapter Evaluation

This chapter describes Guile functions that are concerned with loading
and evaluating Scheme code at run time.  R4RS Scheme, because of strong
differences in opinion among implementors, only provides a @code{load}
function.  There are many useful programs that are difficult or
impossible to write without more powerful evaluation procedures, so we
have provided some.

[FIXME: This needs some more text on the difference between procedures,
macros and memoizing macros.  Also, any definitions listed here should
be double-checked by someone who knows what's going on.  Ask Mikael, Jim
or Aubrey for help. -twp]

@c docstring begin (texi-doc-string "guile" "procedure-documentation")
@deffn primitive procedure-documentation proc
Return the documentation string associated with @code{proc}.  By
convention, if a procedure contains more than one expression and the
first expression is a string constant, that string is assumed to contain
documentation for that procedure.
@end deffn

@c docstring begin (texi-doc-string "guile" "procedure->syntax")
@deffn primitive procedure->syntax code
Returns a @dfn{macro} which, when a symbol defined to this value
appears as the first symbol in an expression, returns the result
of applying @var{code} to the expression and the environment.
@end deffn

@c docstring begin (texi-doc-string "guile" "procedure->macro")
@deffn primitive procedure->macro code
Returns a @dfn{macro} which, when a symbol defined to this value
appears as the first symbol in an expression, evaluates the result
of applying @var{code} to the expression and the environment.
The value returned from @var{code} which has been passed to
@code{procedure->memoizing-macro} replaces the form passed to
@var{code}.  For example:

@example
(define trace
  (procedure->macro
   (lambda (x env) `(set! ,(cadr x) (tracef ,(cadr x) ',(cadr x))))))

(trace @i{foo}) @equiv{} (set! @i{foo} (tracef @i{foo} '@i{foo})).
@end example
@end deffn

@c docstring begin (texi-doc-string "guile" "procedure->memoizing-macro")
@deffn primitive procedure->memoizing-macro code
Returns a @dfn{macro} which, when a symbol defined to this value
appears as the first symbol in an expression, evaluates the result
of applying @var{proc} to the expression and the environment.
The value returned from @var{proc} which has been passed to
@code{procedure->memoizing-macro} replaces the form passed to
@var{proc}.  For example:

@example
(define trace
  (procedure->macro
   (lambda (x env) `(set! ,(cadr x) (tracef ,(cadr x) ',(cadr x))))))

(trace @i{foo}) @equiv{} (set! @i{foo} (tracef @i{foo} '@i{foo})).
@end example
@end deffn

@c docstring begin (texi-doc-string "guile" "macro?")
@deffn primitive macro? obj
Return @code{#t} if @var{obj} is a regular macro, a memoizing macro or a
syntax transformer.
@end deffn

@c ARGFIXME m/obj
@c docstring begin (texi-doc-string "guile" "macro-type")
@deffn primitive macro-type m
Return one of the symbols @code{syntax}, @code{macro} or @code{macro!},
depending on whether @var{obj} is a syntax tranformer, a regular macro,
or a memoizing macro, respectively.  If @var{obj} is not a macro,
@code{#f} is returned.
@end deffn

@c docstring begin (texi-doc-string "guile" "macro-name")
@deffn primitive macro-name m
@end deffn

@c docstring begin (texi-doc-string "guile" "macro-transformer")
@deffn primitive macro-transformer m
@end deffn

@c ARGFIXME x/obj
@c docstring begin (texi-doc-string "guile" "promise?")
@deffn primitive promise? x
Return true if @var{obj} is a promise, i.e. a delayed computation
(@pxref{Delayed evaluation,,,r4rs.info,The Revised^4 Report on Scheme}).
@end deffn

@c docstring begin (texi-doc-string "guile" "force")
@deffn primitive force x
If the promise X has not been computed yet, compute and return
X, otherwise just return the previously computed value.
@end deffn

@c docstring begin (texi-doc-string "guile" "copy-tree")
@deffn primitive copy-tree obj
Recursively copy the data tree that is bound to @var{obj}, and return a
pointer to the new data structure.  @code{copy-tree} recurses down the
contents of both pairs and vectors (since both cons cells and vector
cells may point to arbitrary objects), and stops recursing when it hits
any other object.
@end deffn

@c docstring begin (texi-doc-string "guile" "cons-source")
@deffn primitive cons-source xorig x y
Create and return a new pair whose car and cdr are @var{x} and @var{y}.
Any source properties associated with @var{xorig} are also associated
with the new pair.
@end deffn

@c ARGFIXME environment/environment specifier
@c docstring begin (texi-doc-string "guile" "eval")
@deffn primitive eval exp environment
Evaluate @var{exp}, a list representing a Scheme expression, in the
environment given by @var{environment specifier}.
@end deffn

@c ARGFIXME obj/exp env_thunk/lookup
@c docstring begin (texi-doc-string "guile" "eval2")
@deffn primitive eval2 obj env_thunk
Evaluate @var{exp}, a Scheme expression, in the environment designated
by @var{lookup}, a symbol-lookup function.  @code{(eval exp)} is
equivalent to @code{(eval2 exp *top-level-lookup-closure*)}.
@end deffn

@c docstring begin (texi-doc-string "guile" "local-eval")
@deffn primitive local-eval exp [env]
Evaluate @var{exp} in its environment.  If @var{env} is supplied,
it is the environment in which to evaluate @var{exp}.  Otherwise,
@var{exp} must be a memoized code object (in which case, its environment
is implicit).
@end deffn

@c docstring begin (texi-doc-string "guile" "eval-string")
@deffn primitive eval-string string
Evaluate @var{string} as the text representation of a Scheme form
or forms, and return whatever value they produce.
Evaluation takes place in (interaction-environment).
@end deffn

@c docstring begin (texi-doc-string "guile" "apply:nconc2last")
@deffn primitive apply:nconc2last lst
@end deffn

@c NJFIXME explain [env]
@c docstring begin (texi-doc-string "guile" "defined?")
@deffn primitive defined? sym [env]
Return @code{#t} if @var{sym} is defined in the top-level environment.
@end deffn

@c docstring begin (texi-doc-string "guile" "read-and-eval!")
@deffn primitive read-and-eval! [port]
Read a form from @var{port} (standard input by default), and evaluate it
(memoizing it in the process) in the top-level environment.  If no data
is left to be read from @var{port}, an @code{end-of-file} error is
signalled.
@end deffn

@c docstring begin (texi-doc-string "guile" "eval-options-interface")
@deffn primitive eval-options-interface [setting]
@end deffn

@c docstring begin (texi-doc-string "guile" "evaluator-traps-interface")
@deffn primitive evaluator-traps-interface [setting]
@end deffn

@c ARGFIXME file/filename
@c docstring begin (texi-doc-string "guile" "primitive-load")
@deffn primitive primitive-load filename
Load @var{file} and evaluate its contents in the top-level environment.
The load paths are not searched; @var{file} must either be a full
pathname or be a pathname relative to the current directory.  If the
variable @code{%load-hook} is defined, it should be bound to a procedure
that will be called before any code is loaded.  See documentation for
@code{%load-hook} later in this section.
@end deffn

@c ARGFIXME file/filename
@c docstring begin (texi-doc-string "guile" "primitive-load-path")
@deffn primitive primitive-load-path filename
Search @var{%load-path} for @var{file} and load it into the top-level
environment.  If @var{file} is a relative pathname and is not found in
the list of search paths, an error is signalled.
@end deffn

@c ARGFIXME file/filename
@c docstring begin (texi-doc-string "guile" "%search-load-path")
@deffn primitive %search-load-path filename
Search @var{%load-path} for @var{file}, which must be readable by the
current user.  If @var{file} is found in the list of paths to search or
is an absolute pathname, return its full pathname.  Otherwise, return
@code{#f}.  Filenames may have any of the optional extensions in the
@code{%load-extensions} list; @code{%search-load-path} will try each
extension automatically.
@end deffn

@defvar %load-hook
A procedure to be run whenever @code{primitive-load} is called.  If this
procedure is defined, it will be called with the filename argument that
was passed to @code{primitive-load}.

@example
(define %load-hook (lambda (file)
                     (display "Loading ")
                     (display file)
                     (write-line "...."))) @result{} undefined
(load-from-path "foo.scm")
@print{} Loading /usr/local/share/guile/site/foo.scm....
@end example

@end defvar

@defvar %load-extensions
A list of default file extensions for files containing Scheme code.
@code{%search-load-path} tries each of these extensions when looking for
a file to load.  By default, @code{%load-extensions} is bound to the
list @code{("" ".scm")}.
@end defvar


@page
@node Pairs
@chapter Pairs

@c docstring begin (texi-doc-string "guile" "cons")
@deffn primitive cons x y
Returns a newly allocated pair whose car is @var{x} and whose cdr is
@var{y}.  The pair is guaranteed to be different (in the sense of
@code{eqv?}) from every previously existing object.
@end deffn

@c docstring begin (texi-doc-string "guile" "pair?")
@deffn primitive pair? x
Returns @code{#t} if @var{x} is a pair; otherwise returns @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "set-car!")
@deffn primitive set-car! pair value
Stores @var{value} in the car field of @var{pair}.  The value returned
by @code{set-car!} is unspecified.
@end deffn

@c docstring begin (texi-doc-string "guile" "set-cdr!")
@deffn primitive set-cdr! pair value
Stores @var{value} in the cdr field of @var{pair}.  The value returned
by @code{set-cdr!} is unspecified.
@end deffn


@page
@node Lists
@chapter Lists

@c docstring begin (texi-doc-string "guile" "list")
@deffn primitive list . objs
Return a list containing OBJS, the arguments to `list'.
@end deffn

@c docstring begin (texi-doc-string "guile" "cons*")
@deffn primitive cons* arg . rest
Like `list', but the last arg provides the tail of the constructed list,
returning (cons ARG1 (cons ARG2 (cons ... ARGn))).
Requires at least one argument.  If given one argument, that argument
is returned as result.
This function is called `list*' in some other Schemes and in Common LISP.
@end deffn

@c docstring begin (texi-doc-string "guile" "list?")
@deffn primitive list? x
Return #t iff X is a proper list, else #f.
@end deffn

@c docstring begin (texi-doc-string "guile" "null?")
@deffn primitive null? x
Return #t iff X is the empty list, else #f.
@end deffn

@c docstring begin (texi-doc-string "guile" "length")
@deffn primitive length lst
Return the number of elements in list LST.
@end deffn

@c docstring begin (texi-doc-string "guile" "append")
@deffn primitive append . args
Returns a list consisting of the elements of the first LIST
followed by the elements of the other LISTs.

@example
  (append '(x) '(y))          =>  (x y)
  (append '(a) '(b c d))      =>  (a b c d)
  (append '(a (b)) '((c)))    =>  (a (b) (c))
@end example

The resulting list is always newly allocated, except that it shares
structure with the last LIST argument.  The last argument may
actually be any object; an improper list results if the last
argument is not a proper list.

@example
  (append '(a b) '(c . d))    =>  (a b c . d)
  (append '() 'a)             =>  a
@end example
@end deffn

@c ARGFIXME args ?
@c docstring begin (texi-doc-string "guile" "append!")
@deffn primitive append! . args
A destructive version of @code{append} (@pxref{Pairs and Lists,,,r4rs,
The Revised^4 Report on Scheme}).  The cdr field of each list's final
pair is changed to point to the head of the next list, so no consing is
performed.  Return a pointer to the mutated list.
@end deffn

@c docstring begin (texi-doc-string "guile" "last-pair")
@deffn primitive last-pair lst
Return a pointer to the last pair in @var{lst}, signalling an error if
@var{lst} is circular.
@end deffn

@c docstring begin (texi-doc-string "guile" "reverse")
@deffn primitive reverse lst
Return a new list that contains the elements of LST but in reverse order.
@end deffn

@c NJFIXME explain new_tail
@c docstring begin (texi-doc-string "guile" "reverse!")
@deffn primitive reverse! lst [new_tail]
A destructive version of @code{reverse} (@pxref{Pairs and Lists,,,r4rs,
The Revised^4 Report on Scheme}).  The cdr of each cell in @var{lst} is
modified to point to the previous list element.  Return a pointer to the
head of the reversed list.

Caveat: because the list is modified in place, the tail of the original
list now becomes its head, and the head of the original list now becomes
the tail.  Therefore, the @var{lst} symbol to which the head of the
original list was bound now points to the tail.  To ensure that the head
of the modified list is not lost, it is wise to save the return value of
@code{reverse!}
@end deffn

@c docstring begin (texi-doc-string "guile" "list-ref")
@deffn primitive list-ref list k
Return the Kth element from LIST.
@end deffn

@c docstring begin (texi-doc-string "guile" "list-set!")
@deffn primitive list-set! list k val
Set the @var{k}th element of @var{list} to @var{val}.
@end deffn

@c docstring begin (texi-doc-string "guile" "list-tail")
@deffn primitive list-tail lst k
@deffnx primitive list-cdr-ref lst k
Return the "tail" of @var{lst} beginning with its @var{k}th element.
The first element of the list is considered to be element 0.

@code{list-tail} and @code{list-cdr-ref} are identical.  It may help to
think of @code{list-cdr-ref} as accessing the @var{k}th cdr of the list,
or returning the results of cdring @var{k} times down @var{lst}.
@end deffn

@c docstring begin (texi-doc-string "guile" "list-cdr-set!")
@deffn primitive list-cdr-set! list k val
Set the @var{k}th cdr of @var{list} to @var{val}.
@end deffn

@c docstring begin (texi-doc-string "guile" "list-head")
@deffn primitive list-head lst k
Copy the first @var{k} elements from @var{lst} into a new list, and
return it.
@end deffn

@c docstring begin (texi-doc-string "guile" "list-copy")
@deffn primitive list-copy lst
Return a (newly-created) copy of @var{lst}.
@end deffn

@c docstring begin (texi-doc-string "guile" "memq")
@deffn primitive memq x lst
Return the first sublist of LST whose car is `eq?' to X
where the sublists of LST are the non-empty lists returned
by `(list-tail LST K)' for K less than the length of LST.  If
X does not occur in LST, then `#f' (not the empty list) is
returned.
@end deffn

@c docstring begin (texi-doc-string "guile" "memv")
@deffn primitive memv x lst
Return the first sublist of LST whose car is `eqv?' to X
where the sublists of LST are the non-empty lists returned
by `(list-tail LST K)' for K less than the length of LST.  If
X does not occur in LST, then `#f' (not the empty list) is
returned.
@end deffn

@c docstring begin (texi-doc-string "guile" "member")
@deffn primitive member x lst
Return the first sublist of LST whose car is `equal?' to X
where the sublists of LST are the non-empty lists returned
by `(list-tail LST K)' for K less than the length of LST.  If
X does not occur in LST, then `#f' (not the empty list) is
returned.
@end deffn

@c docstring begin (texi-doc-string "guile" "delq")
@deffn primitive delq item lst
Return a newly-created copy of @var{lst} with elements `eq?' to @var{item} removed.
This procedure mirrors @code{memq}:
@code{delq} compares elements of @var{lst} against @var{item} with
@code{eq?}.
@end deffn

@c docstring begin (texi-doc-string "guile" "delv")
@deffn primitive delv item lst
Return a newly-created copy of @var{lst} with elements `eqv?' to @var{item} removed.
This procedure mirrors @code{memv}:
@code{delv} compares elements of @var{lst} against @var{item} with
@code{eqv?}.
@end deffn

@c docstring begin (texi-doc-string "guile" "delete")
@deffn primitive delete item lst
Return a newly-created copy of @var{lst} with elements `equal?' to @var{item} removed.
This procedure mirrors @code{member}:
@code{delete} compares elements of @var{lst} against @var{item} with
@code{equal?}.
@end deffn

@c docstring begin (texi-doc-string "guile" "delq!")
@deffn primitive delq! item lst
@deffnx primitive delv! item lst
@deffnx primitive delete! item lst
These procedures are destructive versions of @code{delq}, @code{delv}
and @code{delete}: they modify the pointers in the existing @var{lst}
rather than creating a new list.  Caveat evaluator: Like other
destructive list functions, these functions cannot modify the binding of
@var{lst}, and so cannot be used to delete the first element of
@var{lst} destructively.
@end deffn

@c docstring begin (texi-doc-string "guile" "delq1!")
@deffn primitive delq1! item lst
Like `delq!', but only deletes the first occurrence of ITEM from LST.
Tests for equality using `eq?'.  See also `delv1!' and `delete1!'.
@end deffn

@c docstring begin (texi-doc-string "guile" "delv1!")
@deffn primitive delv1! item lst
Like `delv!', but only deletes the first occurrence of ITEM from LST.
Tests for equality using `eqv?'.  See also `delq1!' and `delete1!'.
@end deffn

@c docstring begin (texi-doc-string "guile" "delete1!")
@deffn primitive delete1! item lst
Like `delete!', but only deletes the first occurrence of ITEM from LST.
Tests for equality using `equal?'.  See also `delq1!' and `delv1!'.
@end deffn

[FIXME: is there any reason to have the `sloppy' functions available at
high level at all?  Maybe these docs should be relegated to a "Guile
Internals" node or something. -twp]

@c docstring begin (texi-doc-string "guile" "sloppy-memq")
@deffn primitive sloppy-memq x lst
This procedure behaves like @code{memq}, but does no type or error checking.
Its use is recommended only in writing Guile internals,
not for high-level Scheme programs.
@end deffn

@c docstring begin (texi-doc-string "guile" "sloppy-memv")
@deffn primitive sloppy-memv x lst
This procedure behaves like @code{memv}, but does no type or error checking.
Its use is recommended only in writing Guile internals,
not for high-level Scheme programs.
@end deffn

@c docstring begin (texi-doc-string "guile" "sloppy-member")
@deffn primitive sloppy-member x lst
This procedure behaves like @code{member}, but does no type or error checking.
Its use is recommended only in writing Guile internals,
not for high-level Scheme programs.
@end deffn

@c begin (texi-doc-string "guile" "map")
@deffn primitive map proc arg1 . args
@deffnx primitive map-in-order proc arg1 . args
@end deffn

@c begin (texi-doc-string "guile" "for-each")
@deffn primitive for-each proc arg1 . args
@end deffn


@page
@node Data Structures
@chapter Data Structures

To make it easier to write powerful applications, Guile provides many
data structures not found in standard Scheme.

@menu
* Records::
* Structures::
* Arrays::
* Association Lists and Hash Tables::
* Vectors::
@end menu

@node Records
@section Records

[FIXME: this is pasted in from Tom Lord's original guile.texi and should
be reviewed]

A @dfn{record type} is a first class object representing a user-defined
data type.  A @dfn{record} is an instance of a record type.

@deffn procedure record? obj
Returns @code{#t} if @var{obj} is a record of any type and @code{#f}
otherwise.

Note that @code{record?} may be true of any Scheme value; there is no
promise that records are disjoint with other Scheme types.
@end deffn

@deffn procedure make-record-type type-name field-names
Returns a @dfn{record-type descriptor}, a value representing a new data
type disjoint from all others.  The @var{type-name} argument must be a
string, but is only used for debugging purposes (such as the printed
representation of a record of the new type).  The @var{field-names}
argument is a list of symbols naming the @dfn{fields} of a record of the
new type.  It is an error if the list contains any duplicates.  It is
unspecified how record-type descriptors are represented.@refill
@end deffn

@deffn procedure record-constructor rtd [field-names]
Returns a procedure for constructing new members of the type represented
by @var{rtd}.  The returned procedure accepts exactly as many arguments
as there are symbols in the given list, @var{field-names}; these are
used, in order, as the initial values of those fields in a new record,
which is returned by the constructor procedure.  The values of any
fields not named in that list are unspecified.  The @var{field-names}
argument defaults to the list of field names in the call to
@code{make-record-type} that created the type represented by @var{rtd};
if the @var{field-names} argument is provided, it is an error if it
contains any duplicates or any symbols not in the default list.@refill
@end deffn

@deffn procedure record-predicate rtd
Returns a procedure for testing membership in the type represented by
@var{rtd}.  The returned procedure accepts exactly one argument and
returns a true value if the argument is a member of the indicated record
type; it returns a false value otherwise.@refill
@end deffn

@deffn procedure record-accessor rtd field-name
Returns a procedure for reading the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly one argument which must be a record of the appropriate
type; it returns the current value of the field named by the symbol
@var{field-name} in that record.  The symbol @var{field-name} must be a
member of the list of field-names in the call to @code{make-record-type}
that created the type represented by @var{rtd}.@refill
@end deffn

@deffn procedure record-modifier rtd field-name
Returns a procedure for writing the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly two arguments: first, a record of the appropriate type,
and second, an arbitrary Scheme value; it modifies the field named by
the symbol @var{field-name} in that record to contain the given value.
The returned value of the modifier procedure is unspecified.  The symbol
@var{field-name} must be a member of the list of field-names in the call
to @code{make-record-type} that created the type represented by
@var{rtd}.@refill
@end deffn

@deffn procedure record-type-descriptor record
Returns a record-type descriptor representing the type of the given
record.  That is, for example, if the returned descriptor were passed to
@code{record-predicate}, the resulting predicate would return a true
value when passed the given record.  Note that it is not necessarily the
case that the returned descriptor is the one that was passed to
@code{record-constructor} in the call that created the constructor
procedure that created the given record.@refill
@end deffn

@deffn procedure record-type-name rtd
Returns the type-name associated with the type represented by rtd.  The
returned value is @code{eqv?} to the @var{type-name} argument given in
the call to @code{make-record-type} that created the type represented by
@var{rtd}.@refill
@end deffn

@deffn procedure record-type-fields rtd
Returns a list of the symbols naming the fields in members of the type
represented by @var{rtd}.  The returned value is @code{equal?} to the
field-names argument given in the call to @code{make-record-type} that
created the type represented by @var{rtd}.@refill
@end deffn


@page
@node Structures
@section Structures

[FIXME: this is pasted in from Tom Lord's original guile.texi and should
be reviewed]

A @dfn{structure type} is a first class user-defined data type.  A
@dfn{structure} is an instance of a structure type.  A structure type is
itself a structure.

Structures are less abstract and more general than traditional records.
In fact, in Guile Scheme, records are implemented using structures.

@menu
* Structure Concepts::          The structure of Structures
* Structure Layout::            Defining the layout of structure types
* Structure Basics::            make-, -ref and -set! procedures for structs
* Vtables::                     Accessing type-specific data
@end menu

@node  Structure Concepts
@subsection Structure Concepts

A structure object consists of a handle, structure data, and a vtable.
The handle is a Scheme value which points to both the vtable and the
structure's data.  Structure data is a dynamically allocated region of
memory, private to the structure, divided up into typed fields.  A
vtable is another structure used to hold type-specific data.  Multiple
structures can share a common vtable.

Three concepts are key to understanding structures.

@itemize @bullet{}
@item @dfn{layout specifications}

Layout specifications determine how memory allocated to structures is
divided up into fields.  Programmers must write a layout specification
whenever a new type of structure is defined.

@item @dfn{structural accessors}

Structure access is by field number.   There is only one set of
accessors common to all structure objects.

@item @dfn{vtables}

Vtables, themselves structures, are first class representations of
disjoint sub-types of structures in general.   In most cases, when a
new structure is created, programmers must specifiy a vtable for the
new structure.   Each vtable has a field describing the layout of its
instances.   Vtables can have additional, user-defined fields as well.
@end itemize



@node  Structure Layout
@subsection Structure Layout

When a structure is created, a region of memory is allocated to hold its
state.  The @dfn{layout} of the structure's type determines how that
memory is divided into fields.

Each field has a specified type.  There are only three types allowed, each
corresponding to a one letter code.  The allowed types are:

@itemize @bullet{}
@item 'u' -- unprotected

The field holds binary data that is not GC protected.

@item 'p' -- protected

The field holds a Scheme value and is GC protected.

@item 's' -- self

The field holds a Scheme value and is GC protected.  When a structure is
created with this type of field, the field is initialized to refer to
the structure's own handle.  This kind of field is mainly useful when
mixing Scheme and C code in which the C code may need to compute a
structure's handle given only the address of its malloced data.
@end itemize


Each field also has an associated access protection.   There are only
three kinds of protection, each corresponding to a one letter code.
The allowed protections are:

@itemize @bullet{}
@item 'w' -- writable

The field can be read and written.

@item 'r' -- readable

The field can be read, but not written.

@item 'o' -- opaque

The field can be neither read nor written.   This kind
of protection is for fields useful only to built-in routines.
@end itemize

A layout specification is described by stringing together pairs
of letters: one to specify a field type and one to specify a field
protection.    For example, a traditional cons pair type object could
be described as:

@example
; cons pairs have two writable fields of Scheme data
"pwpw"
@end example

A pair object in which the first field is held constant could be:

@example
"prpw"
@end example

Binary fields, (fields of type "u"), hold one @emph{word} each.  The
size of a word is a machine dependent value defined to be equal to the
value of the C expression: @code{sizeof (long)}.

The last field of a structure layout may specify a tail array.
A tail array is indicated by capitalizing the field's protection
code ('W', 'R' or 'O').   A tail-array field is replaced by
a read-only binary data field containing an array size.   The array
size is determined at the time the structure is created.  It is followed
by a corresponding number of fields of the type specified for the
tail array.   For example, a conventional Scheme vector can be
described as:

@example
; A vector is an arbitrary number of writable fields holding Scheme
; values:
"pW"
@end example

In the above example, field 0 contains the size of the vector and
fields beginning at 1 contain the vector elements.

A kind of tagged vector (a constant tag followed by conventioal
vector elements) might be:

@example
"prpW"
@end example


Structure layouts are represented by specially interned symbols whose
name is a string of type and protection codes.  To create a new
structure layout, use this procedure:

@c docstring begin (texi-doc-string "guile" "make-struct-layout")
@deffn primitive make-struct-layout fields
Return a new structure layout object.

@var{fields} must be a string made up of pairs of characters
strung together.  The first character of each pair describes a field
type, the second a field protection.  Allowed types are 'p' for
GC-protected Scheme data, 'u' for unprotected binary data, and 's' for
a field that points to the structure itself.    Allowed protections
are 'w' for mutable fields, 'r' for read-only fields, and 'o' for opaque
fields.  The last field protection specification may be capitalized to
indicate that the field is a tail-array.
@end deffn



@node Structure Basics
@subsection Structure Basics

This section describes the basic procedures for creating and accessing
structures.

@c docstring begin (texi-doc-string "guile" "make-struct")
@deffn primitive make-struct vtable tail_array_size . init
Create a new structure.

@var{type} must be a vtable structure (@pxref{Vtables}).

@var{tail-elts} must be a non-negative integer.  If the layout
specification indicated by @var{type} includes a tail-array,
this is the number of elements allocated to that array.

The @var{init1}, @dots{} are optional arguments describing how
successive fields of the structure should be initialized.  Only fields
with protection 'r' or 'w' can be initialized, except for fields of
type 's', which are automatically initialized to point to the new
structure itself; fields with protection 'o' can not be initialized by
Scheme programs.

If fewer optional arguments than initializable fields are supplied,
fields of type 'p' get default value #f while fields of type 'u' are
initialized to 0.

Structs are currently the basic representation for record-like data
structures in Guile.  The plan is to eventually replace them with a
new representation which will at the same time be easier to use and
more powerful.

For more information, see the documentation for @code{make-vtable-vtable}.
@end deffn

@c docstring begin (texi-doc-string "guile" "struct?")
@deffn primitive struct? x
Return #t iff @var{obj} is a structure object, else #f.
@end deffn


@c docstring begin (texi-doc-string "guile" "struct-ref")
@deffn primitive struct-ref handle pos
@deffnx primitive struct-set! struct n value
Access (or modify) the @var{n}th field of @var{struct}.

If the field is of type 'p', then it can be set to an arbitrary value.

If the field is of type 'u', then it can only be set to a non-negative
integer value small enough to fit in one machine word.
@end deffn



@node  Vtables
@subsection Vtables

Vtables are structures that are used to represent structure types.  Each
vtable contains a layout specification in field
@code{vtable-index-layout} -- instances of the type are laid out
according to that specification.  Vtables contain additional fields
which are used only internally to libguile.  The variable
@code{vtable-offset-user} is bound to a field number.  Vtable fields
at that position or greater are user definable.

@c docstring begin (texi-doc-string "guile" "struct-vtable")
@deffn primitive struct-vtable handle
Return the vtable structure that describes the type of @var{struct}.
@end deffn

@c docstring begin (texi-doc-string "guile" "struct-vtable?")
@deffn primitive struct-vtable? x
Return #t iff obj is a vtable structure.
@end deffn

If you have a vtable structure, @code{V}, you can create an instance of
the type it describes by using @code{(make-struct V ...)}.  But where
does @code{V} itself come from?  One possibility is that @code{V} is an
instance of a user-defined vtable type, @code{V'}, so that @code{V} is
created by using @code{(make-struct V' ...)}.  Another possibility is
that @code{V} is an instance of the type it itself describes.  Vtable
structures of the second sort are created by this procedure:

@c docstring begin (texi-doc-string "guile" "make-vtable-vtable")
@deffn primitive make-vtable-vtable user_fields tail_array_size . init
Return a new, self-describing vtable structure.

@var{user-fields} is a string describing user defined fields of the
vtable beginning at index @code{vtable-offset-user}
(see @code{make-struct-layout}).

@var{tail-size} specifies the size of the tail-array (if any) of
this vtable.

@var{init1}, @dots{} are the optional initializers for the fields of
the vtable.

Vtables have one initializable system field---the struct printer.
This field comes before the user fields in the initializers passed
to @code{make-vtable-vtable} and @code{make-struct}, and thus works as
a third optional argument to @code{make-vtable-vtable} and a fourth to
@code{make-struct} when creating vtables:

If the value is a procedure, it will be called instead of the standard
printer whenever a struct described by this vtable is printed.
The procedure will be called with arguments STRUCT and PORT.

The structure of a struct is described by a vtable, so the vtable is
in essence the type of the struct.  The vtable is itself a struct with
a vtable.  This could go on forever if it weren't for the
vtable-vtables which are self-describing vtables, and thus terminate
the chain.

There are several potential ways of using structs, but the standard
one is to use three kinds of structs, together building up a type
sub-system: one vtable-vtable working as the root and one or several
"types", each with a set of "instances".  (The vtable-vtable should be
compared to the class <class> which is the class of itself.)

@example
(define ball-root (make-vtable-vtable "pr" 0))

(define (make-ball-type ball-color)
  (make-struct ball-root 0
	       (make-struct-layout "pw")
               (lambda (ball port)
                 (format port "#<a ~A ball owned by ~A>"
                         (color ball)
                         (owner ball)))
               ball-color))
(define (color ball) (struct-ref (struct-vtable ball) vtable-offset-user))
(define (owner ball) (struct-ref ball 0))

(define red (make-ball-type 'red))
(define green (make-ball-type 'green))

(define (make-ball type owner) (make-struct type 0 owner))

(define ball (make-ball green 'Nisse))
ball @result{} #<a green ball owned by Nisse>
@end example
@end deffn

@c docstring begin (texi-doc-string "guile" "struct-vtable-name")
@deffn primitive struct-vtable-name vtable
@end deffn

@c docstring begin (texi-doc-string "guile" "set-struct-vtable-name!")
@deffn primitive set-struct-vtable-name! vtable name
@end deffn

@c docstring begin (texi-doc-string "guile" "struct-vtable-tag")
@deffn primitive struct-vtable-tag handle
@end deffn


@page
@node Arrays
@section Arrays

@menu
* Conventional Arrays::   Arrays with arbitrary data.
* Array Mapping::         Applying a procedure to the contents of an array.
* Uniform Arrays::        Arrays with data of a single type.
* Bit Vectors::           Vectors of bits.
@end menu

@node Conventional Arrays
@subsection Conventional Arrays

@dfn{Conventional arrays} are a collection of cells organised into an
arbitrary number of dimensions.  Each cell can hold any kind of Scheme
value and can be accessed in constant time by supplying an index for
each dimension.  This contrasts with uniform arrays, which use memory
more efficiently but can hold data of only a single type, and lists
where inserting and deleting cells is more efficient, but more time
is usually required to access a particular cell.

A conventional array is displayed as @code{#} followed by the @dfn{rank}
(number of dimensions) followed by the cells, organised into dimensions
using parentheses.  The nesting depth of the parentheses is equal to
the rank.

When an array is created, the number of dimensions and range of each
dimension must be specified, e.g., to create a 2x3 array with a
zero-based index:

@example
(make-array 'ho 2 3) @result{}
#2((ho ho ho) (ho ho ho))
@end example

The range of each dimension can also be given explicitly, e.g., another
way to create the same array:

@example
(make-array 'ho '(0 1) '(0 2)) @result{}
#2((ho ho ho) (ho ho ho))
@end example

A conventional array with one dimension based at zero is identical to
a vector:

@example
(make-array 'ho 3) @result{}
#(ho ho ho)
@end example

The following procedures can be used with conventional arrays (or vectors).

@c docstring begin (texi-doc-string "guile" "array?")
@deffn primitive array? v [prot]
Returns @code{#t} if the @var{obj} is an array, and @code{#f} if not.

The @var{prototype} argument is used with uniform arrays and is described
elsewhere.
@end deffn

@deffn procedure make-array initial-value bound1 bound2 @dots{}
Creates and returns an array that has as many dimensions as there are
@var{bound}s and fills it with @var{initial-value}.
@end deffn

@c array-ref's type is `compiled-closure'.  There's some weird stuff
@c going on in array.c, too.  Let's call it a primitive. -twp

@c docstring begin (texi-doc-string "guile" "uniform-vector-ref")
@deffn primitive uniform-vector-ref v args
@deffnx primitive array-ref v . args
Returns the element at the @code{(index1, index2)} element in @var{array}.
@end deffn

@c docstring begin (texi-doc-string "guile" "array-in-bounds?")
@deffn primitive array-in-bounds? v . args
Returns @code{#t} if its arguments would be acceptable to array-ref.
@end deffn

@c docstring begin (texi-doc-string "guile" "array-set!")
@deffn primitive array-set! v obj . args
@deffnx primitive uniform-array-set1! v obj args
Sets the element at the @code{(index1, index2)} element in @var{array} to
@var{new-value}.  The value returned by array-set! is unspecified.
@end deffn

@c docstring begin (texi-doc-string "guile" "make-shared-array")
@deffn primitive make-shared-array oldra mapfunc . dims
@code{make-shared-array} can be used to create shared subarrays of other
arrays.  The @var{mapper} is a function that translates coordinates in
the new array into coordinates in the old array.  A @var{mapper} must be
linear, and its range must stay within the bounds of the old array, but
it can be otherwise arbitrary.  A simple example:
@example
(define fred (make-array #f 8 8))
(define freds-diagonal
  (make-shared-array fred (lambda (i) (list i i)) 8))
(array-set! freds-diagonal 'foo 3)
(array-ref fred 3 3) @result{} foo
(define freds-center
  (make-shared-array fred (lambda (i j) (list (+ 3 i) (+ 3 j))) 2 2))
(array-ref freds-center 0 0) @result{} foo
@end example
@end deffn

@c docstring begin (texi-doc-string "guile" "shared-array-increments")
@deffn primitive shared-array-increments ra
For each dimension, return the distance between elements in the root vector.
@end deffn

@c docstring begin (texi-doc-string "guile" "shared-array-offset")
@deffn primitive shared-array-offset ra
Return the root vector index of the first element in the array.
@end deffn

@c docstring begin (texi-doc-string "guile" "shared-array-root")
@deffn primitive shared-array-root ra
Return the root vector of a shared array.
@end deffn

@c docstring begin (texi-doc-string "guile" "transpose-array")
@deffn primitive transpose-array ra . args
Returns an array sharing contents with @var{array}, but with dimensions
arranged in a different order.  There must be one @var{dim} argument for
each dimension of @var{array}.  @var{dim0}, @var{dim1}, @dots{} should
be integers between 0 and the rank of the array to be returned.  Each
integer in that range must appear at least once in the argument list.

The values of @var{dim0}, @var{dim1}, @dots{} correspond to dimensions
in the array to be returned, their positions in the argument list to
dimensions of @var{array}.  Several @var{dim}s may have the same value,
in which case the returned array will have smaller rank than
@var{array}.

examples:
@example
(transpose-array '#2((a b) (c d)) 1 0) @result{} #2((a c) (b d))
(transpose-array '#2((a b) (c d)) 0 0) @result{} #1(a d)
(transpose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 1 0) @result{}
                #2((a 4) (b 5) (c 6))
@end example
@end deffn

@c docstring begin (texi-doc-string "guile" "enclose-array")
@deffn primitive enclose-array ra . axes
@var{dim0}, @var{dim1} @dots{} should be nonnegative integers less than
the rank of @var{array}.  @var{enclose-array} returns an array
resembling an array of shared arrays.  The dimensions of each shared
array are the same as the @var{dim}th dimensions of the original array,
the dimensions of the outer array are the same as those of the original
array that did not match a @var{dim}.

An enclosed array is not a general Scheme array.  Its elements may not
be set using @code{array-set!}.  Two references to the same element of
an enclosed array will be @code{equal?} but will not in general be
@code{eq?}.  The value returned by @var{array-prototype} when given an
enclosed array is unspecified.

examples:
@example
(enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1) @result{}
   #<enclosed-array (#1(a d) #1(b e) #1(c f)) (#1(1 4) #1(2 5) #1(3 6))>

(enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 0) @result{}
   #<enclosed-array #2((a 1) (d 4)) #2((b 2) (e 5)) #2((c 3) (f 6))>
@end example
@end deffn

@deffn procedure array-shape array
Returns a list of inclusive bounds of integers.
@example
(array-shape (make-array 'foo '(-1 3) 5)) @result{} ((-1 3) (0 4))
@end example
@end deffn

@c docstring begin (texi-doc-string "guile" "array-dimensions")
@deffn primitive array-dimensions ra
@code{Array-dimensions} is similar to @code{array-shape} but replaces
elements with a @code{0} minimum with one greater than the maximum. So:
@example
(array-dimensions (make-array 'foo '(-1 3) 5)) @result{} ((-1 3) 5)
@end example
@end deffn

@c docstring begin (texi-doc-string "guile" "array-rank")
@deffn primitive array-rank ra
Returns the number of dimensions of @var{obj}.  If @var{obj} is not an
array, @code{0} is returned.
@end deffn

@c docstring begin (texi-doc-string "guile" "array->list")
@deffn primitive array->list v
Returns a list consisting of all the elements, in order, of @var{array}.
@end deffn

@c docstring begin (texi-doc-string "guile" "array-copy!")
@deffn primitive array-copy! src dst
@deffnx primitive array-copy-in-order! src dst
Copies every element from vector or array @var{source} to the
corresponding element of @var{destination}.  @var{destination} must have
the same rank as @var{source}, and be at least as large in each
dimension.  The order is unspecified.
@end deffn

@c docstring begin (texi-doc-string "guile" "array-fill!")
@deffn primitive array-fill! ra fill
Stores @var{fill} in every element of @var{array}.  The value returned
is unspecified.
@end deffn

@c begin (texi-doc-string "guile" "array-equal?")
@deffn primitive array-equal? ra0 ra1
Returns @code{#t} iff all arguments are arrays with the same shape, the
same type, and have corresponding elements which are either
@code{equal?}  or @code{array-equal?}.  This function differs from
@code{equal?} in that a one dimensional shared array may be
@var{array-equal?} but not @var{equal?} to a vector or uniform vector.
@end deffn

@c docstring begin (texi-doc-string "guile" "array-contents")
@deffn primitive array-contents ra [strict]
@deffnx primitive array-contents array strict
If @var{array} may be @dfn{unrolled} into a one dimensional shared array
without changing their order (last subscript changing fastest), then
@code{array-contents} returns that shared array, otherwise it returns
@code{#f}.  All arrays made by @var{make-array} and
@var{make-uniform-array} may be unrolled, some arrays made by
@var{make-shared-array} may not be.

If the optional argument @var{strict} is provided, a shared array will
be returned only if its elements are stored internally contiguous in
memory.
@end deffn

@node Array Mapping
@subsection Array Mapping

@c docstring begin (texi-doc-string "guile" "array-map!")
@deffn primitive array-map! ra0 proc . lra
@deffnx primitive array-map-in-order! ra0 proc . lra
@var{array1}, @dots{} must have the same number of dimensions as
@var{array0} and have a range for each index which includes the range
for the corresponding index in @var{array0}.  @var{proc} is applied to
each tuple of elements of @var{array1} @dots{} and the result is stored
as the corresponding element in @var{array0}.  The value returned is
unspecified.  The order of application is unspecified.
@end deffn

@c docstring begin (texi-doc-string "guile" "array-for-each")
@deffn primitive array-for-each proc ra0 . lra
@var{proc} is applied to each tuple of elements of @var{array0} @dots{}
in row-major order.  The value returned is unspecified.
@end deffn

@c docstring begin (texi-doc-string "guile" "array-index-map!")
@deffn primitive array-index-map! ra proc
applies @var{proc} to the indices of each element of @var{array} in
turn, storing the result in the corresponding element.  The value
returned and the order of application are unspecified.

One can implement @var{array-indexes} as
@example
(define (array-indexes array)
    (let ((ra (apply make-array #f (array-shape array))))
      (array-index-map! ra (lambda x x))
      ra))
@end example
Another example:
@example
(define (apl:index-generator n)
    (let ((v (make-uniform-vector n 1)))
      (array-index-map! v (lambda (i) i))
      v))
@end example
@end deffn

@node Uniform Arrays
@subsection Uniform Arrays

@noindent
@dfn{Uniform arrays} have elements all of the
same type and occupy less storage than conventional
arrays.  Uniform arrays with a single zero-based dimension
are also known as @dfn{uniform vectors}.  The procedures in
this section can also be used on conventional arrays, vectors,
bit-vectors and strings.

@noindent
When creating a uniform array, the type of data to be stored
is indicated with a @var{prototype} argument.  The following table
lists the types available and example prototypes:

@example
prototype           type                       printing character

#t             boolean (bit-vector)                    b
#\a            char (string)                           a
#\nul          byte (integer)                          y
's             short (integer)                         h
1              unsigned long (integer)                 u
-1             signed long (integer)                   e
'l             signed long long (integer)              l
1.0            float (single precision)                s
1/3            double (double precision float)         i
0+i            complex (double precision)              c
()             conventional vector
@end example

@noindent
Unshared uniform arrays of characters with a single zero-based dimension
are identical to strings:

@example
(make-uniform-array #\a 3) @result{}
"aaa"
@end example

@noindent
Unshared uniform arrays of booleans with a single zero-based dimension
are identical to @ref{Bit Vectors, bit-vectors}.

@example
(make-uniform-array #t 3) @result{}
#*111
@end example

@noindent
Other uniform vectors are written in a form similar to that of vectors,
except that a single character from the above table is put between
@code{#} and @code{(}.  For example, a uniform vector of signed
long integers is displayed in the form @code{'#e(3 5 9)}.

@c docstring begin (texi-doc-string "guile" "array?")
@deffn primitive array? v [prot]
Returns @code{#t} if the @var{obj} is an array, and @code{#f} if not.

The @var{prototype} argument is used with uniform arrays and is described
elsewhere.
@end deffn

@deffn procedure make-uniform-array prototype bound1 bound2 @dots{}
Creates and returns a uniform array of type corresponding to
@var{prototype} that has as many dimensions as there are @var{bound}s
and fills it with @var{prototype}.
@end deffn

@c docstring begin (texi-doc-string "guile" "array-prototype")
@deffn primitive array-prototype ra
Returns an object that would produce an array of the same type as
@var{array}, if used as the @var{prototype} for
@code{make-uniform-array}.
@end deffn

@c docstring begin (texi-doc-string "guile" "list->uniform-array")
@deffn primitive list->uniform-array ndim prot lst
@deffnx procedure list->uniform-vector prot lst
Returns a uniform array of the type indicated by prototype @var{prot}
with elements the same as those of @var{lst}.  Elements must be of the
appropriate type, no coercions are done.
@end deffn

@deffn primitive uniform-vector-fill! uve fill
Stores @var{fill} in every element of @var{uve}.  The value returned is
unspecified.
@end deffn

@c docstring begin (texi-doc-string "guile" "uniform-vector-length")
@deffn primitive uniform-vector-length v
Returns the number of elements in @var{uve}.
@end deffn

@c docstring begin (texi-doc-string "guile" "dimensions->uniform-array")
@deffn primitive dimensions->uniform-array dims prot [fill]
@deffnx primitive make-uniform-vector length prototype [fill]
Creates and returns a uniform array or vector of type corresponding to
@var{prototype} with dimensions @var{dims} or length @var{length}.  If
@var{fill} is supplied, it's used to fill the array, otherwise
@var{prototype} is used.
@end deffn

@c Another compiled-closure. -twp

@c docstring begin (texi-doc-string "guile" "uniform-array-read!")
@deffn primitive uniform-array-read! ra [port_or_fd [start [end]]]
@deffnx primitive uniform-vector-read! uve [port-or-fdes] [start] [end]
Attempts to read all elements of @var{ura}, in lexicographic order, as
binary objects from @var{port-or-fdes}.
If an end of file is encountered during
uniform-array-read! the objects up to that point only are put into @var{ura}
(starting at the beginning) and the remainder of the array is
unchanged.

The optional arguments @var{start} and @var{end} allow
a specified region of a vector (or linearized array) to be read,
leaving the remainder of the vector unchanged.

@code{uniform-array-read!} returns the number of objects read.
@var{port-or-fdes} may be omitted, in which case it defaults to the value
returned by @code{(current-input-port)}.
@end deffn

@c docstring begin (texi-doc-string "guile" "uniform-array-write")
@deffn primitive uniform-array-write v [port_or_fd [start [end]]]
@deffnx primitive uniform-vector-write uve [port-or-fdes] [start] [end]
Writes all elements of @var{ura} as binary objects to
@var{port-or-fdes}.

The optional arguments @var{start}
and @var{end} allow
a specified region of a vector (or linearized array) to be written.

The number of objects actually written is returned.
@var{port-or-fdes} may be
omitted, in which case it defaults to the value returned by
@code{(current-output-port)}.
@end deffn

@node Bit Vectors
@subsection Bit Vectors

@noindent
Bit vectors are a specific type of uniform array: an array of booleans
with a single zero-based index.

@noindent
They are displayed as a sequence of @code{0}s and
@code{1}s prefixed by @code{#*}, e.g.,

@example
(make-uniform-vector 8 #t #f) @result{}
#*00000000

#b(#t #f #t) @result{}
#*101
@end example

@c docstring begin (texi-doc-string "guile" "bit-count")
@deffn primitive bit-count b bitvector
Returns the number of occurrences of the boolean B in BITVECTOR.
@end deffn

@c docstring begin (texi-doc-string "guile" "bit-position")
@deffn primitive bit-position item v k
Returns the minimum index of an occurrence of @var{bool} in @var{bv}
which is at least @var{k}.  If no @var{bool} occurs within the specified
range @code{#f} is returned.
@end deffn

@c docstring begin (texi-doc-string "guile" "bit-invert!")
@deffn primitive bit-invert! v
Modifies @var{bv} by replacing each element with its negation.
@end deffn

@c docstring begin (texi-doc-string "guile" "bit-set*!")
@deffn primitive bit-set*! v kv obj
If uve is a bit-vector @var{bv} and uve must be of the same length.  If
@var{bool} is @code{#t}, uve is OR'ed into @var{bv}; If @var{bool} is @code{#f}, the
inversion of uve is AND'ed into @var{bv}.

If uve is a unsigned integer vector all the elements of uve must be
between 0 and the @code{LENGTH} of @var{bv}.  The bits of @var{bv}
corresponding to the indexes in uve are set to @var{bool}.

The return value is unspecified.
@end deffn

@c docstring begin (texi-doc-string "guile" "bit-count*")
@deffn primitive bit-count* v kv obj
Returns
@example
(bit-count (bit-set*! (if bool bv (bit-invert! bv)) uve #t) #t).
@end example
@var{bv} is not modified.
@end deffn


@node Association Lists and Hash Tables
@section Association Lists and Hash Tables

This chapter discusses dictionary objects: data structures that are
useful for organizing and indexing large bodies of information.

@menu
* Dictionary Types::            About dictionary types; what they're good for.
* Association Lists::
* Hash Tables::
@end menu

@node Dictionary Types
@subsection Dictionary Types

A @dfn{dictionary} object is a data structure used to index
information in a user-defined way.  In standard Scheme, the main
aggregate data types are lists and vectors.  Lists are not really
indexed at all, and vectors are indexed only by number
(e.g. @code{(vector-ref foo 5)}).  Often you will find it useful
to index your data on some other type; for example, in a library
catalog you might want to look up a book by the name of its
author.  Dictionaries are used to help you organize information in
such a way.

An @dfn{association list} (or @dfn{alist} for short) is a list of
key-value pairs.  Each pair represents a single quantity or
object; the @code{car} of the pair is a key which is used to
identify the object, and the @code{cdr} is the object's value.

A @dfn{hash table} also permits you to index objects with
arbitrary keys, but in a way that makes looking up any one object
extremely fast.  A well-designed hash system makes hash table
lookups almost as fast as conventional array or vector references.

Alists are popular among Lisp programmers because they use only
the language's primitive operations (lists, @dfn{car}, @dfn{cdr}
and the equality primitives).  No changes to the language core are
necessary.  Therefore, with Scheme's built-in list manipulation
facilities, it is very convenient to handle data stored in an
association list.  Also, alists are highly portable and can be
easily implemented on even the most minimal Lisp systems.

However, alists are inefficient, especially for storing large
quantities of data.  Because we want Guile to be useful for large
software systems as well as small ones, Guile provides a rich set
of tools for using either association lists or hash tables.

@node Association Lists
@subsection Association Lists
@cindex Association List
@cindex Alist
@cindex Database

An association list is a conventional data structure that is often used
to implement simple key-value databases.  It consists of a list of
entries in which each entry is a pair.  The @dfn{key} of each entry is
the @code{car} of the pair and the @dfn{value} of each entry is the
@code{cdr}.

@example
ASSOCIATION LIST ::=  '( (KEY1 . VALUE1)
                         (KEY2 . VALUE2)
                         (KEY3 . VALUE3)
                         @dots{}
                       )
@end example

Association lists are also known, for short, as @dfn{alists}.

The structure of an association list is just one example of the infinite
number of possible structures that can be built using pairs and lists.
As such, the keys and values in an association list can be manipulated
using the general list structure procedures @code{cons}, @code{car},
@code{cdr}, @code{set-car!}, @code{set-cdr!} and so on.  However,
because association lists are so useful, Guile also provides specific
procedures for manipulating them.

@menu
* Alist Key Equality::
* Adding or Setting Alist Entries::
* Retrieving Alist Entries::
* Removing Alist Entries::
* Sloppy Alist Functions::
* Alist Example::
@end menu

@node Alist Key Equality
@subsubsection Alist Key Equality
@findex assq
@findex assv
@findex assoc

All of Guile's dedicated association list procedures, apart from
@code{acons}, come in three flavours, depending on the level of equality
that is required to decide whether an existing key in the association
list is the same as the key that the procedure call uses to identify the
required entry.

@itemize @bullet

@item
Procedures with @dfn{assq} in their name use @code{eq?} to determine key
equality.

@item
Procedures with @dfn{assv} in their name use @code{eqv?} to determine
key equality.

@item
Procedures with @dfn{assoc} in their name use @code{equal?} to
determine key equality.

@end itemize

@code{acons} is an exception because it is used to build association
lists which do not require their entries' keys to be unique.

@node Adding or Setting Alist Entries
@subsubsection Adding or Setting Alist Entries
@findex acons
@findex assq-set!
@findex assv-set!
@findex assoc-set!

@code{acons} adds a new entry to an association list and returns the
combined association list.  The combined alist is formed by consing the
new entry onto the head of the alist specified in the @code{acons}
procedure call.  So the specified alist is not modified, but its
contents become shared with the tail of the combined alist that
@code{acons} returns.

In the most common usage of @code{acons}, a variable holding the
original association list is updated with the combined alist:

@example
(set! address-list (acons name address address-list))
@end example

In such cases, it doesn't matter that the old and new values of
@code{address-list} share some of their contents, since the old value is
usually no longer independently accessible.

Note that @code{acons} adds the specified new entry regardless of
whether the alist may already contain entries with keys that are, in
some sense, the same as that of the new entry.  Thus @code{acons} is
ideal for building alists where there is no concept of key uniqueness.

@example
(set! task-list (acons 3 "pay gas bill" '()))
task-list
@result{}
((3 . "pay gas bill"))

(set! task-list (acons 3 "tidy bedroom" task-list))
task-list
@result{}
((3 . "tidy bedroom") (3 . "pay gas bill"))
@end example

@code{assq-set!}, @code{assv-set!} and @code{assoc-set!} are used to add
or replace an entry in an association list where there @emph{is} a
concept of key uniqueness.  If the specified association list already
contains an entry whose key is the same as that specified in the
procedure call, the existing entry is replaced by the new one.
Otherwise, the new entry is consed onto the head of the old association
list to create the combined alist.  In all cases, these procedures
return the combined alist.

@code{assq-set!} and friends @emph{may} destructively modify the
structure of the old association list in such a way that an existing
variable is correctly updated without having to @code{set!} it to the
value returned:

@example
address-list
@result{}
(("mary" . "34 Elm Road") ("james" . "16 Bow Street"))

(assoc-set! address-list "james" "1a London Road")
@result{}
(("mary" . "34 Elm Road") ("james" . "1a London Road"))

address-list
@result{}
(("mary" . "34 Elm Road") ("james" . "1a London Road"))
@end example

Or they may not:

@example
(assoc-set! address-list "bob" "11 Newington Avenue")
@result{}
(("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
 ("james" . "1a London Road"))

address-list
@result{}
(("mary" . "34 Elm Road") ("james" . "1a London Road"))
@end example

The only safe way to update an association list variable when adding or
replacing an entry like this is to @code{set!} the variable to the
returned value:

@example
(set! address-list
      (assoc-set! address-list "bob" "11 Newington Avenue"))
address-list
@result{}
(("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
 ("james" . "1a London Road"))
@end example

Because of this slight inconvenience, you may find it more convenient to
use hash tables to store dictionary data.  If your application will not
be modifying the contents of an alist very often, this may not make much
difference to you.

If you need to keep the old value of an association list in a form
independent from the list that results from modification by
@code{acons}, @code{assq-set!}, @code{assv-set!} or @code{assoc-set!},
use @code{list-copy} to copy the old association list before modifying
it.

@c docstring begin (texi-doc-string "guile" "acons")
@deffn primitive acons key value alist
Adds a new key-value pair to @var{alist}.  A new pair is
created whose car is @var{key} and whose cdr is @var{value}, and the
pair is consed onto @var{alist}, and the new list is returned.  This
function is @emph{not} destructive; @var{alist} is not modified.
@end deffn

@c docstring begin (texi-doc-string "guile" "assq-set!")
@deffn primitive assq-set! alist key val
@deffnx primitive assv-set! alist key value
@deffnx primitive assoc-set! alist key value
Reassociate @var{key} in @var{alist} with @var{value}: find any existing
@var{alist} entry for @var{key} and associate it with the new
@var{value}.  If @var{alist} does not contain an entry for @var{key},
add a new one.  Return the (possibly new) alist.

These functions do not attempt to verify the structure of @var{alist},
and so may cause unusual results if passed an object that is not an
association list.
@end deffn

@node Retrieving Alist Entries
@subsubsection Retrieving Alist Entries
@findex assq
@findex assv
@findex assoc
@findex assq-ref
@findex assv-ref
@findex assoc-ref

@code{assq}, @code{assv} and @code{assoc} take an alist and a key as
arguments and return the entry for that key if an entry exists, or
@code{#f} if there is no entry for that key.  Note that, in the cases
where an entry exists, these procedures return the complete entry, that
is @code{(KEY . VALUE)}, not just the value.

@c docstring begin (texi-doc-string "guile" "assq")
@deffn primitive assq key alist
@deffnx primitive assv key alist
@deffnx primitive assoc key alist
Fetches the entry in @var{alist} that is associated with @var{key}.  To
decide whether the argument @var{key} matches a particular entry in
@var{alist}, @code{assq} compares keys with @code{eq?}, @code{assv}
uses @code{eqv?} and @code{assoc} uses @code{equal?}.  If @var{key}
cannot be found in @var{alist} (according to whichever equality
predicate is in use), then @code{#f} is returned.  These functions
return the entire alist entry found (i.e. both the key and the value).
@end deffn

@code{assq-ref}, @code{assv-ref} and @code{assoc-ref}, on the other
hand, take an alist and a key and return @emph{just the value} for that
key, if an entry exists.  If there is no entry for the specified key,
these procedures return @code{#f}.

This creates an ambiguity: if the return value is @code{#f}, it means
either that there is no entry with the specified key, or that there
@emph{is} an entry for the specified key, with value @code{#f}.
Consequently, @code{assq-ref} and friends should only be used where it
is known that an entry exists, or where the ambiguity doesn't matter
for some other reason.

@c docstring begin (texi-doc-string "guile" "assq-ref")
@deffn primitive assq-ref alist key
@deffnx primitive assv-ref alist key
@deffnx primitive assoc-ref alist key
Like @code{assq}, @code{assv} and @code{assoc}, except that only the
value associated with @var{key} in @var{alist} is returned.  These
functions are equivalent to

@lisp
(let ((ent (@var{associator} @var{key} @var{alist})))
  (and ent (cdr ent)))
@end lisp

where @var{associator} is one of @code{assq}, @code{assv} or @code{assoc}.
@end deffn

@node Removing Alist Entries
@subsubsection Removing Alist Entries
@findex assq-remove!
@findex assv-remove!
@findex assoc-remove!

To remove the element from an association list whose key matches a
specified key, use @code{assq-remove!}, @code{assv-remove!} or
@code{assoc-remove!} (depending, as usual, on the level of equality
required between the key that you specify and the keys in the
association list).

As with @code{assq-set!} and friends, the specified alist may or may not
be modified destructively, and the only safe way to update a variable
containing the alist is to @code{set!} it to the value that
@code{assq-remove!} and friends return.

@example
address-list
@result{}
(("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
 ("james" . "1a London Road"))

(set! address-list (assoc-remove! address-list "mary"))
address-list
@result{}
(("bob" . "11 Newington Avenue") ("james" . "1a London Road"))
@end example

Note that, when @code{assq/v/oc-remove!} is used to modify an
association list that has been constructed only using the corresponding
@code{assq/v/oc-set!}, there can be at most one matching entry in the
alist, so the question of multiple entries being removed in one go does
not arise.  If @code{assq/v/oc-remove!} is applied to an association
list that has been constructed using @code{acons}, or an
@code{assq/v/oc-set!} with a different level of equality, or any mixture
of these, it removes only the first matching entry from the alist, even
if the alist might contain further matching entries.  For example:

@example
(define address-list '())
(set! address-list (assq-set! address-list "mary" "11 Elm Street"))
(set! address-list (assq-set! address-list "mary" "57 Pine Drive"))
address-list
@result{}
(("mary" . "57 Pine Drive") ("mary" . "11 Elm Street"))

(set! address-list (assoc-remove! address-list "mary"))
address-list
@result{}
(("mary" . "11 Elm Street"))
@end example

In this example, the two instances of the string "mary" are not the same
when compared using @code{eq?}, so the two @code{assq-set!} calls add
two distinct entries to @code{address-list}.  When compared using
@code{equal?}, both "mary"s in @code{address-list} are the same as the
"mary" in the @code{assoc-remove!} call, but @code{assoc-remove!} stops
after removing the first matching entry that it finds, and so one of the
"mary" entries is left in place.

@c docstring begin (texi-doc-string "guile" "assq-remove!")
@deffn primitive assq-remove! alist key
@deffnx primitive assv-remove! alist key
@deffnx primitive assoc-remove! alist key
Delete the first entry in @var{alist} associated with @var{key}, and return
the resulting alist.
@end deffn

@node Sloppy Alist Functions
@subsubsection Sloppy Alist Functions
@findex sloppy-assq
@findex sloppy-assv
@findex sloppy-assoc

@code{sloppy-assq}, @code{sloppy-assv} and @code{sloppy-assoc} behave
like the corresponding non-@code{sloppy-} procedures, except that they
return @code{#f} when the specified association list is not well-formed,
where the non-@code{sloppy-} versions would signal an error.

Specifically, there are two conditions for which the non-@code{sloppy-}
procedures signal an error, which the @code{sloppy-} procedures handle
instead by returning @code{#f}.  Firstly, if the specified alist as a
whole is not a proper list:

@example
(assoc "mary" '((1 . 2) ("key" . "door") . "open sesame"))
@result{}
ERROR: In procedure assoc in expression (assoc "mary" (quote #)):
ERROR: Wrong type argument in position 2 (expecting NULLP): "open sesame"
ABORT: (wrong-type-arg)

(sloppy-assoc "mary" '((1 . 2) ("key" . "door") . "open sesame"))
@result{}
#f
@end example

Secondly, if one of the entries in the specified alist is not a pair:

@example
(assoc 2 '((1 . 1) 2 (3 . 9)))
@result{}
ERROR: In procedure assoc in expression (assoc 2 (quote #)):
ERROR: Wrong type argument in position 2 (expecting CONSP): 2
ABORT: (wrong-type-arg)

(sloppy-assoc 2 '((1 . 1) 2 (3 . 9)))
@result{}
#f
@end example

Unless you are explicitly working with badly formed association lists,
it is much safer to use the non-@code{sloppy-} procedures, because they
help to highlight coding and data errors that the @code{sloppy-}
versions would silently cover up.

@c docstring begin (texi-doc-string "guile" "sloppy-assq")
@deffn primitive sloppy-assq key alist
Behaves like @code{assq} but does not do any error checking.
Recommended only for use in Guile internals.
@end deffn

@c docstring begin (texi-doc-string "guile" "sloppy-assv")
@deffn primitive sloppy-assv key alist
Behaves like @code{assv} but does not do any error checking.
Recommended only for use in Guile internals.
@end deffn

@c docstring begin (texi-doc-string "guile" "sloppy-assoc")
@deffn primitive sloppy-assoc key alist
Behaves like @code{assoc} but does not do any error checking.
Recommended only for use in Guile internals.
@end deffn

@node Alist Example
@subsubsection Alist Example

Here is a longer example of how alists may be used in practice.

@lisp
(define capitals '(("New York" . "Albany")
                   ("Oregon"   . "Salem")
                   ("Florida"  . "Miami")))

;; What's the capital of Oregon?
(assoc "Oregon" capitals)       @result{} ("Oregon" . "Salem")
(assoc-ref capitals "Oregon")   @result{} "Salem"

;; We left out South Dakota.
(set! capitals
      (assoc-set! capitals "South Dakota" "Bismarck"))
capitals
@result{} (("South Dakota" . "Bismarck")
    ("New York" . "Albany")
    ("Oregon" . "Salem")
    ("Florida" . "Miami"))

;; And we got Florida wrong.
(set! capitals
      (assoc-set! capitals "Florida" "Tallahassee"))
capitals
@result{} (("South Dakota" . "Bismarck")
    ("New York" . "Albany")
    ("Oregon" . "Salem")
    ("Florida" . "Tallahassee"))

;; After Oregon secedes, we can remove it.
(set! capitals
      (assoc-remove! capitals "Oregon"))
capitals
@result{} (("South Dakota" . "Bismarck")
    ("New York" . "Albany")
    ("Florida" . "Tallahassee"))
@end lisp

@node Hash Tables
@subsection Hash Tables

Like the association list functions, the hash table functions come
in several varieties: @code{hashq}, @code{hashv}, and @code{hash}.
The @code{hashq} functions use @code{eq?} to determine whether two
keys match.  The @code{hashv} functions use @code{eqv?}, and the
@code{hash} functions use @code{equal?}.

In each of the functions that follow, the @var{table} argument
must be a vector.  The @var{key} and @var{value} arguments may be
any Scheme object.

@c ARGFIXME obj/key
@c docstring begin (texi-doc-string "guile" "hashq-ref")
@deffn primitive hashq-ref table obj [dflt]
Look up @var{key} in the hash table @var{table}, and return the
value (if any) associated with it.  If @var{key} is not found,
return @var{default} (or @code{#f} if no @var{default} argument is
supplied).  Uses `eq?' for equality testing.
@end deffn

@c ARGFIXME obj/key
@c docstring begin (texi-doc-string "guile" "hashv-ref")
@deffn primitive hashv-ref table obj [dflt]
Look up @var{key} in the hash table @var{table}, and return the
value (if any) associated with it.  If @var{key} is not found,
return @var{default} (or @code{#f} if no @var{default} argument is
supplied).  Uses `eqv?' for equality testing.
@end deffn

@c ARGFIXME obj/key
@c docstring begin (texi-doc-string "guile" "hash-ref")
@deffn primitive hash-ref table obj [dflt]
Look up @var{key} in the hash table @var{table}, and return the
value (if any) associated with it.  If @var{key} is not found,
return @var{default} (or @code{#f} if no @var{default} argument is
supplied).  Uses `equal?' for equality testing.
@end deffn

@c ARGFIXME obj/key
@c docstring begin (texi-doc-string "guile" "hashq-set!")
@deffn primitive hashq-set! table obj val
Find the entry in @var{table} associated with @var{key}, and store
@var{value} there. Uses `eq?' for equality testing.
@end deffn

@c ARGFIXME obj/key
@c docstring begin (texi-doc-string "guile" "hashv-set!")
@deffn primitive hashv-set! table obj val
Find the entry in @var{table} associated with @var{key}, and store
@var{value} there. Uses `eqv?' for equality testing.
@end deffn

@c ARGFIXME obj/key
@c docstring begin (texi-doc-string "guile" "hash-set!")
@deffn primitive hash-set! table obj val
Find the entry in @var{table} associated with @var{key}, and store
@var{value} there. Uses `equal?' for equality testing.
@end deffn

@c ARGFIXME obj/key
@c docstring begin (texi-doc-string "guile" "hashq-remove!")
@deffn primitive hashq-remove! table obj
Remove @var{key} (and any value associated with it) from @var{table}.
Uses `eq?' for equality tests.
@end deffn

@c ARGFIXME obj/key
@c docstring begin (texi-doc-string "guile" "hashv-remove!")
@deffn primitive hashv-remove! table obj
Remove @var{key} (and any value associated with it) from @var{table}.
Uses `eqv?' for equality tests.
@end deffn

@c ARGFIXME obj/key
@c docstring begin (texi-doc-string "guile" "hash-remove!")
@deffn primitive hash-remove! table obj
Remove @var{key} (and any value associated with it) from @var{table}.
Uses `equal?' for equality tests.
@end deffn

The standard hash table functions may be too limited for some
applications.  For example, you may want a hash table to store
strings in a case-insensitive manner, so that references to keys
named ``foobar'', ``FOOBAR'' and ``FooBaR'' will all yield the
same item.  Guile provides you with @dfn{extended} hash tables
that permit you to specify a hash function and associator function
of your choosing.  The functions described in the rest of this section
can be used to implement such custom hash table structures.

If you are unfamiliar with the inner workings of hash tables, then
this facility will probably be a little too abstract for you to
use comfortably.  If you are interested in learning more, see an
introductory textbook on data structures or algorithms for an
explanation of how hash tables are implemented.

@c docstring begin (texi-doc-string "guile" "hashq")
@deffn primitive hashq key size
Determine a hash value for KEY that is suitable for lookups in
a hashtable of size SIZE, where eq? is used as the equality
predicate.  The function returns an integer in the range 0 to
SIZE - 1.  NOTE that `hashq' may use internal addresses.
Thus two calls to hashq where the keys are eq? are not
guaranteed to deliver the same value if the key object gets
garbage collected in between.  This can happen, for example
with symbols:  (hashq 'foo n) (gc) (hashq 'foo n) may produce two
different values, since 'foo will be garbage collected.
@end deffn

@c docstring begin (texi-doc-string "guile" "hashv")
@deffn primitive hashv key size
Determine a hash value for KEY that is suitable for lookups in
a hashtable of size SIZE, where eqv? is used as the equality
predicate.  The function returns an integer in the range 0 to
SIZE - 1.  NOTE that (hashv key) may use internal addresses.
Thus two calls to hashv where the keys are eqv? are not
guaranteed to deliver the same value if the key object gets
garbage collected in between.  This can happen, for example
with symbols:  (hashv 'foo n) (gc) (hashv 'foo n) may produce two
different values, since 'foo will be garbage collected.
@end deffn

@c docstring begin (texi-doc-string "guile" "hash")
@deffn primitive hash key size
Determine a hash value for KEY that is suitable for lookups in
a hashtable of size SIZE, where equal? is used as the equality
predicate.  The function returns an integer in the range 0 to
SIZE - 1.
@end deffn

@c ARGFIXME hash/hasher
@c docstring begin (texi-doc-string "guile" "hashx-ref")
@deffn primitive hashx-ref hash assoc table obj [dflt]
This behaves the same way as the corresponding @code{ref}
function, but uses @var{hasher} as a
hash function and @var{assoc} to compare keys.  @code{hasher} must
be a function that takes two arguments, a key to be hashed and a
table size.  @code{assoc} must be an associator function, like
@code{assoc}, @code{assq} or @code{assv}.

By way of illustration, @code{hashq-ref table key} is equivalent
to @code{hashx-ref hashq assq table key}.
@end deffn

@c docstring begin (texi-doc-string "guile" "hashx-set!")
@deffn primitive hashx-set! hash assoc table obj val
This behaves the same way as the corresponding @code{set!}
function, but uses @var{hasher} as a
hash function and @var{assoc} to compare keys.  @code{hasher} must
be a function that takes two arguments, a key to be hashed and a
table size.  @code{assoc} must be an associator function, like
@code{assoc}, @code{assq} or @code{assv}.

By way of illustration, @code{hashq-set! table key} is equivalent
to @code{hashx-set! hashq assq table key}.
@end deffn

@c docstring begin (texi-doc-string "guile" "hashq-get-handle")
@deffn primitive hashq-get-handle table obj
This procedure is similar to its @code{-ref} cousin, but returns a
@dfn{handle} from the hash table rather than the value associated with
@var{key}.  By convention, a handle in a hash table is the pair which
associates a key with a value.  Where @code{hashq-ref table key} returns
only a @code{value}, @code{hashq-get-handle table key} returns the pair
@code{(key . value)}.
@end deffn

@c docstring begin (texi-doc-string "guile" "hashv-get-handle")
@deffn primitive hashv-get-handle table obj
This procedure is similar to its @code{-ref} cousin, but returns a
@dfn{handle} from the hash table rather than the value associated with
@var{key}.  By convention, a handle in a hash table is the pair which
associates a key with a value.  Where @code{hashv-ref table key} returns
only a @code{value}, @code{hashv-get-handle table key} returns the pair
@code{(key . value)}.
@end deffn

@c docstring begin (texi-doc-string "guile" "hash-get-handle")
@deffn primitive hash-get-handle table obj
This procedure is similar to its @code{-ref} cousin, but returns a
@dfn{handle} from the hash table rather than the value associated with
@var{key}.  By convention, a handle in a hash table is the pair which
associates a key with a value.  Where @code{hash-ref table key} returns
only a @code{value}, @code{hash-get-handle table key} returns the pair
@code{(key . value)}.
@end deffn

@c docstring begin (texi-doc-string "guile" "hashx-get-handle")
@deffn primitive hashx-get-handle hash assoc table obj
This behaves the same way as the corresponding @code{-get-handle}
function, but uses @var{hasher} as a
hash function and @var{assoc} to compare keys.  @code{hasher} must
be a function that takes two arguments, a key to be hashed and a
table size.  @code{assoc} must be an associator function, like
@code{assoc}, @code{assq} or @code{assv}.
@end deffn

@c docstring begin (texi-doc-string "guile" "hashq-create-handle!")
@deffn primitive hashq-create-handle! table key init
This function looks up @var{key} in @var{table} and returns its handle.
If @var{key} is not already present, a new handle is created which
associates @var{key} with @var{init}.
@end deffn

@c docstring begin (texi-doc-string "guile" "hashv-create-handle!")
@deffn primitive hashv-create-handle! table key init
This function looks up @var{key} in @var{table} and returns its handle.
If @var{key} is not already present, a new handle is created which
associates @var{key} with @var{init}.
@end deffn

@c docstring begin (texi-doc-string "guile" "hash-create-handle!")
@deffn primitive hash-create-handle! table key init
This function looks up @var{key} in @var{table} and returns its handle.
If @var{key} is not already present, a new handle is created which
associates @var{key} with @var{init}.
@end deffn

@c docstring begin (texi-doc-string "guile" "hashx-create-handle!")
@deffn primitive hashx-create-handle! hash assoc table obj init
This behaves the same way as the corresponding @code{-create-handle}
function, but uses @var{hasher} as a
hash function and @var{assoc} to compare keys.  @code{hasher} must
be a function that takes two arguments, a key to be hashed and a
table size.  @code{assoc} must be an associator function, like
@code{assoc}, @code{assq} or @code{assv}.
@end deffn

@c docstring begin (texi-doc-string "guile" "hash-fold")
@deffn primitive hash-fold proc init table
An iterator over hash-table elements.
Accumulates and returns a result by applying PROC successively.
The arguments to PROC are "(key value prior-result)" where key
and value are successive pairs from the hash table TABLE, and
prior-result is either INIT (for the first application of PROC)
or the return value of the previous application of PROC.
For example, @code{(hash-fold acons () tab)} will convert a hash
table into an a-list of key-value pairs.
@end deffn


@node Vectors
@section Vectors

@c docstring begin (texi-doc-string "guile" "make-vector")
@deffn primitive make-vector k [fill]
Returns a newly allocated vector of @var{k} elements.  If a second
argument is given, then each element is initialized to @var{fill}.
Otherwise the initial contents of each element is unspecified. (r5rs)
@end deffn

@c docstring begin (texi-doc-string "guile" "vector")
@deffn primitive vector . l
@deffnx primitive list->vector l
Returns a newly allocated vector whose elements contain the given
arguments.  Analogous to @samp{list}. (r5rs)

@format
@t{(vector 'a 'b 'c)                      ==>  #(a b c) }
@end format
@end deffn

@c docstring begin (texi-doc-string "guile" "vector->list")
@deffn primitive vector->list v
@samp{Vector->list} returns a newly allocated list of the objects contained
in the elements of @var{vector}.  (r5rs)

@format
@t{(vector->list '#(dah dah didah))
=>  (dah dah didah)
list->vector '(dididit dah))
=>  #(dididit dah)
}
@end format
@end deffn

@c docstring begin (texi-doc-string "guile" "vector-fill!")
@deffn primitive vector-fill! v fill_x
Stores @var{fill} in every element of @var{vector}.
The value returned by @samp{vector-fill!} is unspecified. (r5rs)
@end deffn

@c docstring begin (texi-doc-string "guile" "vector?")
@deffn primitive vector? obj
Returns @t{#t} if @var{obj} is a vector, otherwise returns @t{#f}. (r5rs)
@end deffn


@page
@node Booleans
@chapter Booleans

@c docstring begin (texi-doc-string "guile" "not")
@deffn primitive not x
Return @code{#t} iff @var{x} is @code{#f}, else return @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "boolean?")
@deffn primitive boolean? obj
Return @code{#t} iff @var{obj} is either @code{#t} or @code{#f}.
@end deffn


@page
@node Equality
@chapter Equality

@c docstring begin (texi-doc-string "guile" "eq?")
@deffn primitive eq? x y
Return @code{#t} iff @var{x} references the same object as @var{y}.
@code{eq?} is similar to @code{eqv?} except that in some cases it is
capable of discerning distinctions finer than those detectable by
@code{eqv?}.
@end deffn

@c docstring begin (texi-doc-string "guile" "eqv?")
@deffn primitive eqv? x y
The @code{eqv?} procedure defines a useful equivalence relation on objects.
Briefly, it returns @code{#t} if @var{x} and @var{y} should normally be
regarded as the same object.  This relation is left slightly open to
interpretation, but works for comparing immediate integers, characters,
and inexact numbers.
@end deffn

@c docstring begin (texi-doc-string "guile" "equal?")
@deffn primitive equal? x y
Return @code{#t} iff @var{x} and @var{y} are recursively @code{eqv?} equivalent.
@code{equal?} recursively compares the contents of pairs,
vectors, and strings, applying @code{eqv?} on other objects such as
numbers and symbols.  A rule of thumb is that objects are generally
@code{equal?}  if they print the same.  @code{equal?} may fail to
terminate if its arguments are circular data structures.
@end deffn


@page
@node Strings
@chapter Strings

[FIXME: this is pasted in from Tom Lord's original guile.texi and should
be reviewed]

For the sake of efficiency, two special kinds of strings are available
in Guile: shared substrings and the misleadingly named ``read-only''
strings.  It is not necessary to know about these to program in Guile,
but you are likely to run into one or both of these special string types
eventually, and it will be helpful to know how they work.

@menu
* String Fun::                  New functions for manipulating strings.
* Shared Substrings::           Strings which share memory with each other.
* Read Only Strings::           Treating certain non-strings as strings.
@end menu

@node String Fun
@section String Fun

@c docstring begin (texi-doc-string "guile" "string")
@deffn primitive string . chrs
@deffnx primitive list->string chrs
Returns a newly allocated string composed of the arguments, CHRS.
@end deffn

@c docstring begin (texi-doc-string "guile" "make-string")
@deffn primitive make-string k [chr]
Returns a newly allocated string of
length K.  If CHR is given, then all elements of the string
are initialized to CHR, otherwise the contents of the
STRING are unspecified.
@end deffn

@c docstring begin (texi-doc-string "guile" "string-append")
@deffn primitive string-append . args
Returns a newly allocated string whose characters form the
concatenation of the given strings, ARGS.
@end deffn

@c docstring begin (texi-doc-string "guile" "string-length")
@deffn primitive string-length string
Returns the number of characters in STRING
@end deffn

@c docstring begin (texi-doc-string "guile" "string-ref")
@deffn primitive string-ref str k
Returns character K of STR using zero-origin indexing.
K must be a valid index of STR.
@end deffn

@c docstring begin (texi-doc-string "guile" "string-set!")
@deffn primitive string-set! str k chr
Stores CHR in element K of STRING and returns an unspecified value.
K must be a valid index of STR.
@end deffn

@c docstring begin (texi-doc-string "guile" "string?")
@deffn primitive string? obj
Returns #t iff OBJ is a string, else returns #f.
@end deffn

@c docstring begin (texi-doc-string "guile" "substring")
@deffn primitive substring str start [end]
Returns a newly allocated string formed from the characters
of STR beginning with index START (inclusive) and ending with
index END (exclusive).
STR must be a string, START and END must be exact integers satisfying:

0 <= START <= END <= (string-length STR).
@end deffn

@c docstring begin (texi-doc-string "guile" "string-index")
@deffn primitive string-index str chr [frm [to]]
Return the index of the first occurrence of @var{chr} in @var{str}.  The
optional integer arguments @var{frm} and @var{to} limit the search to
a portion of the string.  This procedure essentially implements the
@code{index} or @code{strchr} functions from the C library.

(qdocs:)  Returns the index of @var{char} in @var{str}, or @code{#f} if the
@var{char} isn't in @var{str}. If @var{frm} is given and not @code{#f},
it is used as the starting index; if @var{to} is given and not @var{#f},
it is used as the ending index (exclusive).

@example
(string-index "weiner" #\e)
@result{} 1

(string-index "weiner" #\e 2)
@result{} 4

(string-index "weiner" #\e 2 4)
@result{} #f
@end example
@end deffn

@c docstring begin (texi-doc-string "guile" "string-rindex")
@deffn primitive string-rindex str chr [frm [to]]
Like @code{string-index}, but search from the right of the string rather
than from the left.  This procedure essentially implements the
@code{rindex} or @code{strrchr} functions from the C library.

(qdocs:) The same as @code{string-index}, except it gives the rightmost occurance
of @var{char} in the range [@var{frm}, @var{to}-1], which defaults to
the entire string.

@example
(string-rindex "weiner" #\e)
@result{} 4

(string-rindex "weiner" #\e 2 4)
@result{} #f

(string-rindex "weiner" #\e 2 5)
@result{} 4
@end example
@end deffn

@c docstring begin (texi-doc-string "guile" "substring-move!")
@deffn primitive substring-move! str1 start1 end1 str2 start2
@deffnx primitive substring-move-left! str1 start1 end1 str2 start2
@deffnx primitive substring-move-right! str1 start1 end1 str2 start2
Copy the substring of @var{str1} bounded by @var{start1} and @var{end1}
into @var{str2} beginning at position @var{end2}.
@code{substring-move-right!} begins copying from the rightmost character
and moves left, and @code{substring-move-left!} copies from the leftmost
character moving right.

It is useful to have two functions that copy in different directions so
that substrings can be copied back and forth within a single string.  If
you wish to copy text from the left-hand side of a string to the
right-hand side of the same string, and the source and destination
overlap, you must be careful to copy the rightmost characters of the
text first, to avoid clobbering your data.  Hence, when @var{str1} and
@var{str2} are the same string, you should use
@code{substring-move-right!} when moving text from left to right, and
@code{substring-move-left!}  otherwise.  If @code{str1} and @samp{str2}
are different strings, it does not matter which function you use.
@end deffn

@deffn primitive substring-move-left! str1 start1 end1 str2 start2
@end deffn
@deftypefn {C Function} SCM scm_substring_move_left_x (SCM @var{str1}, SCM @var{start1}, SCM @var{end1}, SCM @var{str2}, SCM @var{start2})
[@strong{Note:} this is only valid if you've applied the strop patch].

Moves a substring of @var{str1}, from @var{start1} to @var{end1}
(@var{end1} is exclusive), into @var{str2}, starting at
@var{start2}. Allows overlapping strings.

@example
(define x (make-string 10 #\a))
(define y "bcd")
(substring-move-left! x 2 5 y 0)
y
@result{} "aaa"

x
@result{} "aaaaaaaaaa"

(define y "bcdefg")
(substring-move-left! x 2 5 y 0)
y
@result{} "aaaefg"

(define y "abcdefg")
(substring-move-left! y 2 5 y 3)
y
@result{} "abccccg"
@end example
@end deftypefn

@deffn substring-move-right! str1 start1 end1 str2 start2
@end deffn
@deftypefn {C Function} SCM scm_substring_move_right_x (SCM @var{str1}, SCM @var{start1}, SCM @var{end1}, SCM @var{str2}, SCM @var{start2})
[@strong{Note:} this is only valid if you've applied the strop patch, if
it hasn't made it into the guile tree].

Does much the same thing as @code{substring-move-left!}, except it
starts moving at the end of the sequence, rather than the beginning.
@example
(define y "abcdefg")
(substring-move-right! y 2 5 y 0)
y
@result{} "ededefg"

(define y "abcdefg")
(substring-move-right! y 2 5 y 3)
y
@result{} "abccdeg"
@end example
@end deftypefn

@c docstring begin (texi-doc-string "guile" "vector-move-left!")
@deffn primitive vector-move-left! vec1 start1 end1 vec2 start2
Vector version of @code{substring-move-left!}.
@end deffn

@c docstring begin (texi-doc-string "guile" "vector-move-right!")
@deffn primitive vector-move-right! vec1 start1 end1 vec2 start2
Vector version of @code{substring-move-right!}.
@end deffn

@c ARGFIXME fill/fill-char
@c docstring begin (texi-doc-string "guile" "substring-fill!")
@deffn primitive substring-fill! str start end fill
Change every character in @var{str} between @var{start} and @var{end} to
@var{fill-char}.

(qdocs:) Destructively fills @var{str}, from @var{start} to @var{end}, with @var{fill}.

@example
(define y "abcdefg")
(substring-fill! y 1 3 #\r)
y
@result{} "arrdefg"
@end example
@end deffn

@c docstring begin (texi-doc-string "guile" "string-null?")
@deffn primitive string-null? str
Return @code{#t} if @var{str}'s length is nonzero, and @code{#f}
otherwise.

(qdocs:) Returns @code{#t} if @var{str} is empty, else returns @code{#f}.

@example
(string-null? "")
@result{} #t

(string-null? y)
@result{} #f
@end example
@end deffn

@c ARGFIXME v/str
@c docstring begin (texi-doc-string "guile" "string-upcase!")
@deffn primitive string-upcase! v
Destructively upcase every character in @code{str}.

(qdocs:) Converts each element in @var{str} to upper case.

@example
(string-upcase! y)
@result{} "ARRDEFG"

y
@result{} "ARRDEFG"
@end example
@end deffn

@c docstring begin (texi-doc-string "guile" "string-upcase")
@deffn primitive string-upcase str
Upcase every character in @code{str}.
@end deffn

@c ARGFIXME v/str
@c docstring begin (texi-doc-string "guile" "string-downcase!")
@deffn primitive string-downcase! v
Destructively downcase every character in @code{str}.

(qdocs:) Converts each element in @var{str} to lower case.

@example
y
@result{} "ARRDEFG"

(string-downcase! y)
@result{} "arrdefg"

y
@result{} "arrdefg"
@end example
@end deffn

@c docstring begin (texi-doc-string "guile" "string-downcase")
@deffn primitive string-downcase str
Downcase every character in @code{str}.
@end deffn

@c docstring begin (texi-doc-string "guile" "string-capitalize!")
@deffn primitive string-capitalize! str
Destructively capitalize every character in @code{str}.
@end deffn

@c docstring begin (texi-doc-string "guile" "string-capitalize")
@deffn primitive string-capitalize str
Capitalize every character in @code{str}.
@end deffn

@c docstring begin (texi-doc-string "guile" "string-ci<=?")
@deffn primitive string-ci<=? s1 s2
Case insensitive lexicographic ordering predicate;
returns @t{#t} if @var{s1} is lexicographically less than
or equal to @var{s2} regardless of case.  (r5rs)
@end deffn

@c docstring begin (texi-doc-string "guile" "string-ci<?")
@deffn primitive string-ci<? s1 s2
Case insensitive lexicographic ordering predicate;
returns @t{#t} if @var{s1} is lexicographically less than
@var{s2} regardless of case.  (r5rs)
@end deffn

@c docstring begin (texi-doc-string "guile" "string-ci=?")
@deffn primitive string-ci=? s1 s2
Case-insensitive string equality predicate; returns @t{#t} if
the two strings are the same length and their component characters
match (ignoring case) at each position; otherwise returns @t{#f}. (r5rs)
@end deffn

@c docstring begin (texi-doc-string "guile" "string-ci>=?")
@deffn primitive string-ci>=? s1 s2
Case insensitive lexicographic ordering predicate;
returns @t{#t} if @var{s1} is lexicographically greater than
or equal to @var{s2} regardless of case.  (r5rs)
@end deffn

@c docstring begin (texi-doc-string "guile" "string-ci>?")
@deffn primitive string-ci>? s1 s2
Case insensitive lexicographic ordering predicate;
returns @t{#t} if @var{s1} is lexicographically greater than
@var{s2} regardless of case.  (r5rs)
@end deffn

@c docstring begin (texi-doc-string "guile" "string<=?")
@deffn primitive string<=? s1 s2
Lexicographic ordering predicate; returns @t{#t} if @var{s1}
is lexicographically less than or equal to @var{s2}.  (r5rs)
@end deffn

@c docstring begin (texi-doc-string "guile" "string<?")
@deffn primitive string<? s1 s2
Lexicographic ordering predicate; returns @t{#t} if @var{s1}
is lexicographically less than @var{s2}.  (r5rs)
@end deffn

@c docstring begin (texi-doc-string "guile" "string=?")
@deffn primitive string=? s1 s2
Lexicographic equality predicate;
Returns @t{#t} if the two strings are the same length and contain the same
characters in the same positions, otherwise returns @t{#f}. (r5rs)

@samp{String-ci=?} treats
upper and lower case letters as though they were the same character, but
@samp{string=?} treats upper and lower case as distinct characters.
@end deffn

@c docstring begin (texi-doc-string "guile" "string>=?")
@deffn primitive string>=? s1 s2
Lexicographic ordering predicate; returns @t{#t} if @var{s1}
is lexicographically greater than or equal to @var{s2}.  (r5rs)
@end deffn

@c docstring begin (texi-doc-string "guile" "string>?")
@deffn primitive string>? s1 s2
Lexicographic ordering predicate; returns @t{#t} if @var{s1}
is lexicographically greater than @var{s2}.  (r5rs)
@end deffn

@c docstring begin (texi-doc-string "guile" "string->list")
@deffn primitive string->list str
@samp{String->list} returns a newly allocated list of the
characters that make up the given string.  @samp{List->string}
returns a newly allocated string formed from the characters in the list
@var{list}, which must be a list of characters. @samp{String->list}
and @samp{list->string} are
inverses so far as @samp{equal?} is concerned.  (r5rs)
@end deffn

@c docstring begin (texi-doc-string "guile" "string-ci->symbol")
@deffn primitive string-ci->symbol str
Return the symbol whose name is @var{str}, downcased in necessary(???).
@end deffn

@c docstring begin (texi-doc-string "guile" "string-copy")
@deffn primitive string-copy str
Returns a newly allocated copy of the given @var{string}. (r5rs)
@end deffn

@c docstring begin (texi-doc-string "guile" "string-fill!")
@deffn primitive string-fill! str chr
Stores @var{char} in every element of the given @var{string} and returns an
unspecified value.  (r5rs)
@end deffn


@node Shared Substrings
@section Shared Substrings

Whenever you extract a substring using @code{substring}, the Scheme
interpreter allocates a new string and copies data from the old string.
This is expensive, but @code{substring} is so convenient for
manipulating text that programmers use it often.

Guile Scheme provides the concept of the @dfn{shared substring} to
improve performance of many substring-related operations.  A shared
substring is an object that mostly behaves just like an ordinary
substring, except that it actually shares storage space with its parent
string.

@c ARGFIXME frm/start to/end
@c docstring begin (texi-doc-string "guile" "make-shared-substring")
@deffn primitive make-shared-substring str [frm [to]]
Return a shared substring of @var{str}.  The semantics are the same as
for the @code{substring} function: the shared substring returned
includes all of the text from @var{str} between indexes @var{start}
(inclusive) and @var{end} (exclusive).  If @var{end} is omitted, it
defaults to the end of @var{str}.  The shared substring returned by
@code{make-shared-substring} occupies the same storage space as
@var{str}.
@end deffn

Example:

@example
(define foo "the quick brown fox")
(define bar (make-shared-substring some-string 4 9))

foo => "t h e   q u i c k   b r o w n   f o x"
bar =========> |---------|
@end example

The shared substring @var{bar} is not given its own storage space.
Instead, the Guile interpreter notes internally that @var{bar} points to
a portion of the memory allocated to @var{foo}.  However, @var{bar}
behaves like an ordinary string in most respects: it may be used with
string primitives like @code{string-length}, @code{string-ref},
@code{string=?}.  Guile makes the necessary translation between indices
of @var{bar} and indices of @var{foo} automatically.

@example
(string-length? bar) @result{} 5	; bar only extends from indices 4 to 9
(string-ref bar 3)  @result{} #\c	; same as (string-ref foo 7)
(make-shared-substring bar 2)
  @result{} "ick"			; can even make a shared substring!
@end example

Because creating a shared substring does not require allocating new
storage from the heap, it is a very fast operation.  However, because it
shares memory with its parent string, a change to the contents of the
parent string will implicitly change the contents of its shared
substrings.

@example
(string-set! foo 7 #\r)
bar @result{} "quirk"
@end example

Guile considers shared substrings to be immutable.  This is because
programmers might not always be aware that a given string is really a
shared substring, and might innocently try to mutate it without
realizing that the change would affect its parent string.  (We are
currently considering a "copy-on-write" strategy that would permit
modifying shared substrings without affecting the parent string.)

In general, shared substrings are useful in circumstances where it is
important to divide a string into smaller portions, but you do not
expect to change the contents of any of the strings involved.

@node Read Only Strings
@section Read Only Strings

Type-checking in Guile primitives distinguishes between mutable strings
and read only strings.  Mutable strings answer @code{#t} to
@code{string?}  while read only strings may or may not.   All kinds of
strings, whether or not they are mutable return #t to this:

@c ARGFIXME x/obj
@c docstring begin (texi-doc-string "guile" "read-only-string?")
@deffn primitive read-only-string? x
Return true if OBJ can be read as a string,

This illustrates the difference between @code{string?} and
@code{read-only-string?}:

@example
(string? "a string") @result{} #t
(string? 'a-symbol) @result{} #f

(read-only-string? "a string") @result{} #t
(read-only-string? 'a-symbol) @result{} #t
@end example
@end deffn

"Read-only" refers to how the string will be used, not how the string is
permitted to be used.  In particular, all strings are "read-only
strings" even if they are mutable, because a function that only reads
from a string can certainly operate on even a mutable string.

Symbols are an example of read-only strings.  Many string functions,
such as @code{string-append} are happy to operate on symbols.  Many
functions that expect a string argument, such as @code{open-file}, will
accept a symbol as well.

Shared substrings, discussed in the previous chapter, also happen to be
read-only strings.

@page
@node Characters
@chapter Characters

Most of the characters in the ASCII character set may be referred to by
name: for example, @code{#\tab}, @code{#\esc}, @code{#\stx}, and so on.
The following table describes the ASCII names for each character.

@multitable @columnfractions .25 .25 .25 .25
@item 0 = @code{#\nul}
 @tab 1 = @code{#\soh}
 @tab 2 = @code{#\stx}
 @tab 3 = @code{#\etx}
@item 4 = @code{#\eot}
 @tab 5 = @code{#\enq}
 @tab 6 = @code{#\ack}
 @tab 7 = @code{#\bel}
@item 8 = @code{#\bs}
 @tab 9 = @code{#\ht}
 @tab 10 = @code{#\nl}
 @tab 11 = @code{#\vt}
@item 12 = @code{#\np}
 @tab 13 = @code{#\cr}
 @tab 14 = @code{#\so}
 @tab 15 = @code{#\si}
@item 16 = @code{#\dle}
 @tab 17 = @code{#\dc1}
 @tab 18 = @code{#\dc2}
 @tab 19 = @code{#\dc3}
@item 20 = @code{#\dc4}
 @tab 21 = @code{#\nak}
 @tab 22 = @code{#\syn}
 @tab 23 = @code{#\etb}
@item 24 = @code{#\can}
 @tab 25 = @code{#\em}
 @tab 26 = @code{#\sub}
 @tab 27 = @code{#\esc}
@item 28 = @code{#\fs}
 @tab 29 = @code{#\gs}
 @tab 30 = @code{#\rs}
 @tab 31 = @code{#\us}
@item 32 = @code{#\sp}
@end multitable

The @code{delete} character (octal 177) may be referred to with the name
@code{#\del}.

Several characters have more than one name:

@itemize @bullet
@item
#\space, #\sp
@item
#\newline, #\nl
@item
#\tab, #\ht
@item
#\backspace, #\bs
@item
#\return, #\cr
@item
#\page, #\np
@item
#\null, #\nul
@end itemize

@c docstring begin (texi-doc-string "guile" "char?")
@deffn primitive char? x
Return @code{#t} iff @var{x} is a character, else @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "char=?")
@deffn primitive char=? x y
Return @code{#t} iff @var{x} is the same character as @var{y}, else @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "char<?")
@deffn primitive char<? x y
Return @code{#t} iff @var{x} is less than @var{y} in the ASCII sequence,
else @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "char<=?")
@deffn primitive char<=? x y
Return @code{#t} iff @var{x} is less than or equal to @var{y} in the
ASCII sequence, else @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "char>?")
@deffn primitive char>? x y
Return @code{#t} iff @var{x} is greater than @var{y} in the ASCII
sequence, else @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "char>=?")
@deffn primitive char>=? x y
Return @code{#t} iff @var{x} is greater than or equal to @var{y} in the
ASCII sequence, else @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "char-ci=?")
@deffn primitive char-ci=? x y
Return @code{#t} iff @var{x} is the same character as @var{y} ignoring
case, else @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "char-ci<?")
@deffn primitive char-ci<? x y
Return @code{#t} iff @var{x} is less than @var{y} in the ASCII sequence
ignoring case, else @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "char-ci<=?")
@deffn primitive char-ci<=? x y
Return @code{#t} iff @var{x} is less than or equal to @var{y} in the
ASCII sequence ignoring case, else @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "char-ci>?")
@deffn primitive char-ci>? x y
Return @code{#t} iff @var{x} is greater than @var{y} in the ASCII
sequence ignoring case, else @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "char-ci>=?")
@deffn primitive char-ci>=? x y
Return @code{#t} iff @var{x} is greater than or equal to @var{y} in the
ASCII sequence ignoring case, else @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "char-alphabetic?")
@deffn primitive char-alphabetic? chr
Return @code{#t} iff @var{chr} is alphabetic, else @code{#f}.
Alphabetic means the same thing as the isalpha C library function.
@end deffn

@c docstring begin (texi-doc-string "guile" "char-numeric?")
@deffn primitive char-numeric? chr
Return @code{#t} iff @var{chr} is numeric, else @code{#f}.
Numeric means the same thing as the isdigit C library function.
@end deffn

@c docstring begin (texi-doc-string "guile" "char-whitespace?")
@deffn primitive char-whitespace? chr
Return @code{#t} iff @var{chr} is whitespace, else @code{#f}.
Whitespace means the same thing as the isspace C library function.
@end deffn

@c docstring begin (texi-doc-string "guile" "char-upper-case?")
@deffn primitive char-upper-case? chr
Return @code{#t} iff @var{chr} is uppercase, else @code{#f}.
Uppercase means the same thing as the isupper C library function.
@end deffn

@c docstring begin (texi-doc-string "guile" "char-lower-case?")
@deffn primitive char-lower-case? chr
Return @code{#t} iff @var{chr} is lowercase, else @code{#f}.
Lowercase means the same thing as the islower C library function.
@end deffn

@c docstring begin (texi-doc-string "guile" "char-is-both?")
@deffn primitive char-is-both? chr
Return @code{#t} iff @var{chr} is either uppercase or lowercase, else @code{#f}.
Uppercase and lowercase are as defined by the isupper and islower
C library functions.
@end deffn

@c docstring begin (texi-doc-string "guile" "char->integer")
@deffn primitive char->integer chr
Return the number corresponding to ordinal position of @var{chr} in the
ASCII sequence.
@end deffn

@c docstring begin (texi-doc-string "guile" "integer->char")
@deffn primitive integer->char n
Return the character at position @var{n} in the ASCII sequence.
@end deffn

@c docstring begin (texi-doc-string "guile" "char-upcase")
@deffn primitive char-upcase chr
Return the uppercase character version of @var{chr}.
@end deffn

@c docstring begin (texi-doc-string "guile" "char-downcase")
@deffn primitive char-downcase chr
Return the lowercase character version of @var{chr}.
@end deffn


@page
@node Hooks
@chapter Hooks

@c docstring begin (texi-doc-string "guile" "make-hook-with-name")
@deffn primitive make-hook-with-name name [n_args]
@end deffn

@c docstring begin (texi-doc-string "guile" "make-hook")
@deffn primitive make-hook [n_args]
@end deffn

@c docstring begin (texi-doc-string "guile" "hook?")
@deffn primitive hook? x
@end deffn

@c docstring begin (texi-doc-string "guile" "hook-empty?")
@deffn primitive hook-empty? hook
@end deffn

@c docstring begin (texi-doc-string "guile" "add-hook!")
@deffn primitive add-hook! hook proc [append_p]
@end deffn

@c docstring begin (texi-doc-string "guile" "remove-hook!")
@deffn primitive remove-hook! hook proc
@end deffn

@c docstring begin (texi-doc-string "guile" "reset-hook!")
@deffn primitive reset-hook! hook
@end deffn

@c docstring begin (texi-doc-string "guile" "run-hook")
@deffn primitive run-hook hook . args
@end deffn

@c docstring begin (texi-doc-string "guile" "hook->list")
@deffn primitive hook->list hook
@end deffn


@page
@node Procedures
@chapter Procedures

@c docstring begin (texi-doc-string "guile" "procedure-properties")
@deffn primitive procedure-properties proc
Return @var{obj}'s property list.
@end deffn

@c docstring begin (texi-doc-string "guile" "procedure-property")
@deffn primitive procedure-property p k
Return the property of @var{obj} with name @var{key}.
@end deffn

@c docstring begin (texi-doc-string "guile" "set-procedure-properties!")
@deffn primitive set-procedure-properties! proc new_val
Set @var{obj}'s property list to @var{alist}.
@end deffn

@c docstring begin (texi-doc-string "guile" "set-procedure-property!")
@deffn primitive set-procedure-property! p k v
In @var{obj}'s property list, set the property named @var{key} to
@var{value}.
@end deffn

@c docstring begin (texi-doc-string "guile" "closure?")
@deffn primitive closure? obj
@end deffn

@c docstring begin (texi-doc-string "guile" "make-procedure-with-setter")
@deffn primitive make-procedure-with-setter procedure setter
@end deffn

@c docstring begin (texi-doc-string "guile" "procedure")
@deffn primitive procedure proc
@end deffn

@c docstring begin (texi-doc-string "guile" "procedure-with-setter?")
@deffn primitive procedure-with-setter? obj
@end deffn

@c docstring begin (texi-doc-string "guile" "procedure?")
@deffn primitive procedure? obj
@end deffn

@c docstring begin (texi-doc-string "guile" "thunk?")
@deffn primitive thunk? obj
@end deffn

@c docstring begin (texi-doc-string "guile" "set-source-properties!")
@deffn primitive set-source-properties! obj plist
@end deffn

@c docstring begin (texi-doc-string "guile" "set-source-property!")
@deffn primitive set-source-property! obj key datum
@end deffn

@c docstring begin (texi-doc-string "guile" "source-properties")
@deffn primitive source-properties obj
@end deffn

@c docstring begin (texi-doc-string "guile" "source-property")
@deffn primitive source-property obj key
@end deffn


@page
@node Property Lists
@chapter Property Lists

Every object in the system can have a @dfn{property list} that may
be used for information about that object.  For example, a
function may have a property list that includes information about
the source file in which it is defined.

Property lists are implemented as assq lists (@pxref{Association Lists}).

Currently, property lists are implemented differently for procedures and
closures than for other kinds of objects.  Therefore, when manipulating
a property list associated with a procedure object, use the
@code{procedure} functions; otherwise, use the @code{object} functions.

@c docstring begin (texi-doc-string "guile" "object-properties")
@deffn primitive object-properties obj
@deffnx primitive procedure-properties obj
Return @var{obj}'s property list.
@end deffn

@c ARGFIXME alist/plist
@c docstring begin (texi-doc-string "guile" "set-object-properties!")
@deffn primitive set-object-properties! obj plist
@deffnx primitive set-procedure-properties! obj alist
Set @var{obj}'s property list to @var{alist}.
@end deffn

@c docstring begin (texi-doc-string "guile" "object-property")
@deffn primitive object-property obj key
@deffnx primitive procedure-property obj key
Return the property of @var{obj} with name @var{key}.
@end deffn

@c ARGFIXME val/value
@c docstring begin (texi-doc-string "guile" "set-object-property!")
@deffn primitive set-object-property! obj key val
@deffnx primitive set-procedure-property! obj key value
In @var{obj}'s property list, set the property named @var{key} to
@var{value}.
@end deffn

[Interface bug:  there should be a second level of interface in which
the user provides a "property table" that is possibly private.]


@page
@node Primitive Properties
@chapter Primitive Properties

@c docstring begin (texi-doc-string "guile" "primitive-make-property")
@deffn primitive primitive-make-property not_found_proc
Create a @dfn{property token} that can be used with
@code{primitive-property-ref} and @code{primitive-property-set!}.
See @code{primitive-property-ref} for the significance of
@var{not_found_proc}.
@end deffn

@c docstring begin (texi-doc-string "guile" "primitive-property-ref")
@deffn primitive primitive-property-ref prop obj
Return the property @var{prop} of @var{obj}.  When no value
has yet been associated with @var{prop} and @var{obj}, call
@var{not-found-proc} instead (see @code{primitive-make-property})
and use its return value.  That value is also associated with
@var{obj} via @code{primitive-property-set!}.  When
@var{not-found-proc} is @code{#f}, use @code{#f} as the
default value of @var{prop}.
@end deffn

@c docstring begin (texi-doc-string "guile" "primitive-property-set!")
@deffn primitive primitive-property-set! prop obj val
Associate @var{code} with @var{prop} and @var{obj}.
@end deffn

@c docstring begin (texi-doc-string "guile" "primitive-property-del!")
@deffn primitive primitive-property-del! prop obj
Remove any value associated with @var{prop} and @var{obj}.
@end deffn


@page
@node Ports
@chapter Ports

Sequential input/output in Scheme is represented by operations on a
@dfn{port}.  Characters can be read from an input port and
written to an output port.  This chapter explains the operations
that Guile provides for working with ports.

The formal definition of a port is very generic: an input port is
simply ``an object which can deliver characters on command,'' and
an output port is ``an object which can accept characters.''
Because this definition is so loose, it is easy to write functions
that simulate ports in software.  @dfn{Soft ports} and @dfn{string
ports} are two interesting and powerful examples of this technique.

@menu
* File Ports:: Ports on an operating system file.
* String Ports:: Ports on a Scheme string.
* Soft Ports:: Ports on arbitrary Scheme procedures.
* Void Ports:: Ports on nothing at all.
* Generic Port Operations:: procedures for any type of port: close, flush etc.
* Extended I/O:: read and write lines or delimited text.
* C Port Interface:: Using ports from C.
* Port Implementation:: How to implement a new port type in C.
@end menu

@node File Ports
@section File Ports

The following procedures are used to open file ports.
See also @ref{Ports and File Descriptors, open}, for an interface
to the Unix @code{open} system call.

@c ARGFIXME string/filename mode/modes
@c docstring begin (texi-doc-string "guile" "open-file")
@deffn primitive open-file filename modes
Open the file whose name is @var{string}, and return a port
representing that file.  The attributes of the port are
determined by the @var{mode} string.  The way in
which this is interpreted is similar to C stdio:

The first character must be one of the following:

@table @samp
@item r
Open an existing file for input.
@item w
Open a file for output, creating it if it doesn't already exist
or removing its contents if it does.
@item a
Open a file for output, creating it if it doesn't already exist.
All writes to the port will go to the end of the file.
The "append mode" can be turned off while the port is in use
@pxref{Ports and File Descriptors, fcntl}
@end table

The following additional characters can be appended:

@table @samp
@item +
Open the port for both input and output.  E.g., @code{r+}: open
an existing file for both input and output.
@item 0
Create an "unbuffered" port.  In this case input and output operations
are passed directly to the underlying port implementation without
additional buffering.  This is likely to slow down I/O operations.
The buffering mode can be changed while a port is in use
@pxref{Ports and File Descriptors, setvbuf}
@item l
Add line-buffering to the port.  The port output buffer will be
automatically flushed whenever a newline character is written.
@end table

In theory we could create read/write ports which were buffered in one
direction only.  However this isn't included in the current interfaces.

If a file cannot be opened with the access requested,
@code{open-file} throws an exception.
@end deffn

@c begin (scm-doc-string "r4rs.scm" "open-input-file")
@deffn procedure open-input-file filename
Open @var{filename} for input.  Equivalent to
@smalllisp
(open-file @var{filename} "r")
@end smalllisp
@end deffn

@c begin (scm-doc-string "r4rs.scm" "open-output-file")
@deffn procedure open-output-file filename
Open @var{filename} for output.  Equivalent to
@smalllisp
(open-file @var{filename} "w")
@end smalllisp
@end deffn

@c docstring begin (texi-doc-string "guile" "port-mode")
@deffn primitive port-mode port
Returns the port modes associated with the open port @var{port}.  These
will not necessarily be identical to the modes used when the port was
opened, since modes such as "append" which are used only during
port creation are not retained.
@end deffn

@c docstring begin (texi-doc-string "guile" "port-filename")
@deffn primitive port-filename port
Return the filename associated with @var{port}.  This function returns
the strings "standard input", "standard output" and "standard error"
when called on the current input, output and error ports respectively.
@end deffn

@c docstring begin (texi-doc-string "guile" "set-port-filename!")
@deffn primitive set-port-filename! port filename
Change the filename associated with @var{port}, using the current input
port if none is specified.  Note that this does not change the port's
source of data, but only the value that is returned by
@code{port-filename} and reported in diagnostic output.
@end deffn

@node String Ports
@section String Ports

The following allow string ports to be opened by analogy to R4R*
file port facilities:

@c docstring begin (texi-doc-string "guile" "call-with-output-string")
@deffn primitive call-with-output-string proc
Calls the one-argument procedure @var{proc} with a newly created output
port.  When the function returns, the string composed of the characters
written into the port is returned.
@end deffn

@c ARGFIXME str/string
@c docstring begin (texi-doc-string "guile" "call-with-input-string")
@deffn primitive call-with-input-string str proc
Calls the one-argument procedure @var{proc} with a newly created input
port from which @var{string}'s contents may be read.  The value yielded
by the @var{proc} is returned.
@end deffn

@c begin (scm-doc-string "r4rs.scm" "with-output-to-string")
@deffn procedure with-output-to-string thunk
Calls the zero-argument procedure @var{thunk} with the current output
port set temporarily to a new string port.  It returns a string
composed of the characters written to the current output.
@end deffn

@c begin (scm-doc-string "r4rs.scm" "with-input-from-string")
@deffn procedure with-input-from-string string thunk
Calls the zero-argument procedure @var{thunk} with the current input
port set temporarily to a string port opened on the specified
@var{string}.  The value yielded by @var{thunk} is returned.
@end deffn

A string port can be used in many procedures which accept a port
but which are not dependent on implementation details of fports.
E.g., seeking and truncating will work on a string port,
but trying to extract the file descriptor number will fail.

At present there isn't a procedure that simply returns a new string
port.  There's also no way of opening read/write string ports from
Scheme even though it's possible from C.  SRFI 6 could be implemented
without much difficulty.

@node Soft Ports
@section Soft Ports

A @dfn{soft-port} is a port based on a vector of procedures capable of
accepting or delivering characters.  It allows emulation of I/O ports.

@c ARGFIXME pv/vector
@c docstring begin (texi-doc-string "guile" "make-soft-port")
@deffn primitive make-soft-port pv modes
Returns a port capable of receiving or delivering characters as
specified by the @var{modes} string (@pxref{File Ports,
open-file}).  @var{vector} must be a vector of length 6.  Its components
are as follows:

@enumerate 0
@item
procedure accepting one character for output
@item
procedure accepting a string for output
@item
thunk for flushing output
@item
thunk for getting one character
@item
thunk for closing port (not by garbage collection)
@end enumerate

For an output-only port only elements 0, 1, 2, and 4 need be
procedures.  For an input-only port only elements 3 and 4 need be
procedures.  Thunks 2 and 4 can instead be @code{#f} if there is no useful
operation for them to perform.

If thunk 3 returns @code{#f} or an @code{eof-object} (@pxref{Input,
eof-object?, ,r4rs, The Revised^4 Report on Scheme}) it indicates that
the port has reached end-of-file.  For example:

@example
(define stdout (current-output-port))
(define p (make-soft-port
           (vector
            (lambda (c) (write c stdout))
            (lambda (s) (display s stdout))
            (lambda () (display "." stdout))
            (lambda () (char-upcase (read-char)))
            (lambda () (display "@@" stdout)))
           "rw"))

(write p p) @result{} #<input-output: soft 8081e20>
@end example
@end deffn

@node Void Ports
@section Void Ports

This kind of port just causes errors if you try to use it in
a normal way.

@c docstring begin (texi-doc-string "guile" "%make-void-port")
@deffn primitive %make-void-port mode
Create and return a new void port.  A void port acts like
/dev/null.  The @var{mode} argument
specifies the input/output modes for this port: see the
documentation for @code{open-file} in @ref{File Ports}.
@end deffn

@node Generic Port Operations
@section Generic Port Operations

This section describes port maintainence procedures
which are not specific to a single port type.

@c docstring begin (texi-doc-string "guile" "eof-object?")
@deffn primitive eof-object? x
Returns @code{#t} if @var{x} is an end-of-file object; otherwise
returns @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "char-ready?")
@deffn primitive char-ready? [port]
Returns @code{#t} if a character is ready on input @var{port} and
returns @code{#f} otherwise.  If @code{char-ready?} returns @code{#t}
then the next @code{read-char} operation on @var{port} is
guaranteed not to hang.  If @var{port} is a file port at end of
file then @code{char-ready?} returns @code{#t}.
@footnote{@code{char-ready?} exists to make it possible for a
program to accept characters from interactive ports without getting
stuck waiting for input.  Any input editors associated with such ports
must make sure that characters whose existence has been asserted by
@code{char-ready?} cannot be rubbed out.  If @code{char-ready?} were to
return @code{#f} at end of file, a port at end of file would be
indistinguishable from an interactive port that has no ready
characters.}
@end deffn

@c docstring begin (texi-doc-string "guile" "read-char")
@deffn primitive read-char [port]
Returns the next character available from @var{port}, updating
@var{port} to point to the following character.  If no more
characters are available, an end-of-file object is returned.
@end deffn

@c docstring begin (texi-doc-string "guile" "peek-char")
@deffn primitive peek-char [port]
Returns the next character available from @var{port},
@emph{without} updating @var{port} to point to the following
character.  If no more characters are available, an end-of-file object
is returned.@footnote{The value returned by a call to @code{peek-char}
is the same as the value that would have been returned by a call to
@code{read-char} on the same port.  The only difference is that the very
next call to @code{read-char} or @code{peek-char} on that
@var{port} will return the value returned by the preceding call to
@code{peek-char}.  In particular, a call to @code{peek-char} on an
interactive port will hang waiting for input whenever a call to
@code{read-char} would have hung.}
@end deffn

@c docstring begin (texi-doc-string "guile" "unread-char")
@deffn primitive unread-char cobj port
Place @var{char} in @var{port} so that it will be read by the
next read operation.  If called multiple times, the unread characters
will be read again in last-in first-out order.  If @var{port} is
not supplied, the current input port is used.
@end deffn

@c docstring begin (texi-doc-string "guile" "unread-string")
@deffn primitive unread-string str port
Place the string @var{str} in @var{port} so that its characters will be
read in subsequent read operations.  If called multiple times, the
unread characters will be read again in last-in first-out order.  If
@var{port} is not supplied, the current-input-port is used.
@end deffn

@c docstring begin (texi-doc-string "guile" "close-port")
@deffn primitive close-port port
Close the specified port object.  Returns @code{#t} if it successfully
closes a port or @code{#f} if it was already
closed.  An exception may be raised if an error occurs, for example
when flushing buffered output.
See also @ref{Ports and File Descriptors, close}, for a procedure
which can close file descriptors.
@end deffn

@c docstring begin (texi-doc-string "guile" "close-input-port")
@deffn primitive close-input-port port
Close the specified input port object.  The routine has no effect if
the file has already been closed.  An exception may be raised if an
error occurs.  The value returned is unspecified.

See also @ref{Ports and File Descriptors, close}, for a procedure
which can close file descriptors.
@end deffn

@c docstring begin (texi-doc-string "guile" "close-output-port")
@deffn primitive close-output-port port
Close the specified output port object.  The routine has no effect if
the file has already been closed.  An exception may be raised if an
error occurs.  The value returned is unspecified.

See also @ref{Ports and File Descriptors, close}, for a procedure
which can close file descriptors.
@end deffn

@c docstring begin (texi-doc-string "guile" "input-port?")
@deffn primitive input-port? x
Returns @code{#t} if @var{x} is an input port, otherwise returns
@code{#f}.  Any object satisfying this predicate also satisfies
@code{port?}.
@end deffn

@c docstring begin (texi-doc-string "guile" "output-port?")
@deffn primitive output-port? x
Returns @code{#t} if @var{x} is an output port, otherwise returns
@code{#f}.  Any object satisfying this predicate also satisfies
@code{port?}.
@end deffn

@c docstring begin (texi-doc-string "guile" "port-closed?")
@deffn primitive port-closed? port
Returns @code{#t} if @var{port} is closed or @code{#f} if it is open.
@end deffn

@c docstring begin (texi-doc-string "guile" "current-input-port")
@deffn primitive current-input-port
Returns the current input port.  This is the default port used by many
input procedures.  Initially, @code{current-input-port} returns the
value of @code{???}.
@end deffn

@c docstring begin (texi-doc-string "guile" "current-load-port")
@deffn primitive current-load-port
Return the current-load-port.
The load port is used internally by `primitive-load'.
@end deffn

@c docstring begin (texi-doc-string "guile" "current-output-port")
@deffn primitive current-output-port
Returns the current output port.  This is the default port used by many
output procedures.  Initially, @code{current-output-port} returns the
value of @code{???}.
@end deffn

@c docstring begin (texi-doc-string "guile" "current-error-port")
@deffn primitive current-error-port
Return the port to which errors and warnings should be sent (the
@dfn{standard error} in Unix and C terminology).
@end deffn

@c docstring begin (texi-doc-string "guile" "set-current-input-port")
@deffn primitive set-current-input-port port
@deffnx primitive set-current-output-port port
@deffnx primitive set-current-error-port port
Change the ports returned by @code{current-input-port},
@code{current-output-port} and @code{current-error-port}, respectively,
so that they use the supplied @var{port} for input or output.
@end deffn

@c docstring begin (texi-doc-string "guile" "set-current-output-port")
@deffn primitive set-current-output-port port
Set the current default output port to PORT.
@end deffn

@c docstring begin (texi-doc-string "guile" "set-current-error-port")
@deffn primitive set-current-error-port port
Set the current default error port to PORT.
@end deffn

@findex fflush
@c docstring begin (texi-doc-string "guile" "force-output")
@deffn primitive force-output [port]
Flush the specified output port, or the current output port if @var{port}
is omitted.  The current output buffer contents are passed to the
underlying port implementation (e.g., in the case of fports, the
data will be written to the file and the output buffer will be cleared.)
It has no effect on an unbuffered port.

The return value is unspecified.
@end deffn

@c docstring begin (texi-doc-string "guile" "flush-all-ports")
@deffn primitive flush-all-ports
Equivalent to calling @code{force-output} on
all open output ports.  The return value is unspecified.
@end deffn

@c docstring begin (texi-doc-string "guile" "drain-input")
@deffn primitive drain-input port
Drains @var{PORT}'s read buffers (including any pushed-back characters)
and returns the contents as a single string.
@end deffn

@c ARGFIXME object/fd/port
@c docstring begin (texi-doc-string "guile" "seek")
@deffn primitive seek object offset whence
Sets the current position of @var{fd/port} to the integer @var{offset},
which is interpreted according to the value of @var{whence}.

One of the following variables should be supplied
for @var{whence}:
@defvar SEEK_SET
Seek from the beginning of the file.
@end defvar
@defvar SEEK_CUR
Seek from the current position.
@end defvar
@defvar SEEK_END
Seek from the end of the file.
@end defvar

If @var{fd/port} is a file descriptor, the underlying system call is
@code{lseek}.  @var{port} may be a string port.

The value returned is the new position in the file.  This means that
the current position of a port can be obtained using:
@smalllisp
(seek port 0 SEEK_CUR)
@end smalllisp
@end deffn

@c ARGFIXME object/fd/port
@c docstring begin (texi-doc-string "guile" "fseek")
@deffn primitive fseek object offset whence
Obsolete.  Almost the same as seek, above, but the return value is
unspecified.
@end deffn

@c ARGFIXME object/fd/port
@c docstring begin (texi-doc-string "guile" "ftell")
@deffn primitive ftell object
Returns an integer representing the current position of @var{fd/port},
measured from the beginning.  Equivalent to:
@smalllisp
(seek port 0 SEEK_CUR)
@end smalllisp
@end deffn

@findex truncate
@findex ftruncate
@c ARGFIXME obj/object size/length
@c docstring begin (texi-doc-string "guile" "truncate-file")
@deffn primitive truncate-file object [length]
Truncates the object referred to by @var{obj} to at most @var{size} bytes.
@var{obj} can be a string containing a file name or an integer file
descriptor or a port.  @var{size} may be omitted if @var{obj} is not
a file name, in which case the truncation occurs at the current port.
position.

The return value is unspecified.
@end deffn

@c ARGFIXME port/input-port
@c docstring begin (texi-doc-string "guile" "port-column")
@deffn primitive port-column port
@deffnx primitive port-line [input-port]
Return the current column number or line number of @var{input-port},
using the current input port if none is specified.  If the number is
unknown, the result is #f.  Otherwise, the result is a 0-origin integer
- i.e. the first character of the first line is line 0, column 0.
(However, when you display a file position, for example in an error
message, we recommand you add 1 to get 1-origin integers.  This is
because lines and column numbers traditionally start with 1, and that is
what non-programmers will find most natural.)
@end deffn

@c ARGFIXME port/input-port
@c docstring begin (texi-doc-string "guile" "set-port-column!")
@deffn primitive set-port-column! port column
@deffnx primitive set-port-line! port line
Set the current column or line number of @var{port}, using the
current input port if none is specified.
@end deffn

@node Extended I/O
@section Extended I/O

Extended I/O procedures are available which read or write lines of text
or read text delimited by a specified set of characters.

@findex fwrite
@findex fread
Interfaces to @code{read}/@code{fread} and @code{write}/@code{fwrite} are
also available, as @code{uniform-array-read!} and @code{uniform-array-write!},
@ref{Uniform Arrays}.

@c begin (scm-doc-string "boot-9.scm" "read-line")
@deffn procedure read-line [port] [handle-delim]
Return a line of text from @var{port} if specified, otherwise from the
value returned by @code{(current-input-port)}.  Under Unix, a line of text
is terminated by the first end-of-line character or by end-of-file.

If @var{handle-delim} is specified, it should be one of the following
symbols:
@table @code
@item trim
Discard the terminating delimiter.  This is the default, but it will
be impossible to tell whether the read terminated with a delimiter or
end-of-file.
@item concat
Append the terminating delimiter (if any) to the returned string.
@item peek
Push the terminating delimiter (if any) back on to the port.
@item split
Return a pair containing the string read from the port and the
terminating delimiter or end-of-file object.

NOTE: if the scsh module is loaded then
multiple values are returned instead of a pair.
@end table
@end deffn

@c begin (scm-doc-string "boot-9.scm" "read-line!")
@deffn procedure read-line! buf [port]
Read a line of text into the supplied string @var{buf} and return the
number of characters added to @var{buf}.  If @var{buf} is filled, then
@code{#f} is returned.
Read from @var{port} if
specified, otherwise from the value returned by @code{(current-input-port)}.
@end deffn

@c begin (scm-doc-string "boot-9.scm" "read-delimited")
@deffn procedure read-delimited delims [port] [handle-delim]
Read text until one of the characters in the string @var{delims} is found
or end-of-file is reached.  Read from @var{port} if supplied, otherwise
from the value returned by @code{(current-input-port)}.
@var{handle-delim} takes the same values as described for @code{read-line}.

NOTE: if the scsh module is loaded then @var{delims} must be an scsh
char-set, not a string.
@end deffn

@c begin (scm-doc-string "boot-9.scm" "read-delimited!")
@deffn procedure read-delimited! delims buf [port] [handle-delim] [start] [end]
Read text into the supplied string @var{buf} and return the number of
characters added to @var{buf} (subject to @var{handle-delim}, which takes
the same values specified for @code{read-line}.  If @var{buf} is filled,
@code{#f} is returned for both the number of characters read and the
delimiter.  Also terminates if one of the characters in the string
@var{delims} is found
or end-of-file is reached.  Read from @var{port} if supplied, otherwise
from the value returned by @code{(current-input-port)}.

NOTE: if the scsh module is loaded then @var{delims} must be an scsh
char-set, not a string.
@end deffn

@c docstring begin (texi-doc-string "guile" "write-line")
@deffn primitive write-line obj [port]
Display @var{obj} and a newline character to @var{port}.  If @var{port}
is not specified, @code{(current-output-port)} is used.  This function
is equivalent to:

@smalllisp
(display obj [port])
(newline [port])
@end smalllisp
@end deffn

Some of the abovementioned I/O functions rely on the following C
primitives.  These will mainly be of interest to people hacking Guile
internals.

@c ARGFIXME gobble/gobble?
@c docstring begin (texi-doc-string "guile" "%read-delimited!")
@deffn primitive %read-delimited! delims buf gobble [port [start [end]]]
Read characters from @var{port} into @var{buf} until one of the
characters in the @var{delims} string is encountered.  If @var{gobble?}
is true, store the delimiter character in @var{buf} as well; otherwise,
discard it.  If @var{port} is not specified, use the value of
@code{(current-input-port)}.  If @var{start} or @var{end} are specified,
store data only into the substring of @var{buf} bounded by @var{start}
and @var{end} (which default to the beginning and end of the buffer,
respectively).

Return a pair consisting of the delimiter that terminated the string and
the number of characters read.  If reading stopped at the end of file,
the delimiter returned is the @var{eof-object}; if the buffer was filled
without encountering a delimiter, this value is @var{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "%read-line")
@deffn primitive %read-line [port]
Read a newline-terminated line from @var{port}, allocating storage as
necessary.  The newline terminator (if any) is removed from the string,
and a pair consisting of the line and its delimiter is returned.  The
delimiter may be either a newline or the @var{eof-object}; if
@code{%read-line} is called at the end of file, it returns the pair
@code{(#<eof> . #<eof>)}.
@end deffn

@node C Port Interface
@section C Port Interface
This section describes how to use Scheme ports from C.

@subsection Port basics

There are two main data structures.  A port type object (ptob) is of
type @code{scm_ptob_descriptor}.  A port instance is of type
@code{scm_port}.  Given an @code{SCM} variable which points to a port,
the corresponding C port object can be obtained using the
@code{SCM_PTAB_ENTRY} macro.  The ptob can be obtained by using
@code{SCM_PTOBNUM} to give an index into the @code{scm_ptobs}
global array.

@subsection Port buffers

An input port always has a read buffer and an output port always has a
write buffer.  However the size of these buffers is not guaranteed to be
more than one byte (e.g., the @code{shortbuf} field in @code{scm_port}
which is used when no other buffer is allocated).  The way in which the
buffers are allocated depends on the implementation of the ptob.  For
example in the case of an fport, buffers may be allocated with malloc
when the port is created, but in the case of an strport the underlying
string is used as the buffer.

@subsection The @code{rw_random} flag

Special treatment is required for ports which can be seeked at random.
Before various operations, such as seeking the port or changing from
input to output on a bidirectional port or vice versa, the port
implemention must be given a chance to update its state.  The write
buffer is updated by calling the @code{flush} ptob procedure and the
input buffer is updated by calling the @code{end_input} ptob procedure.
In the case of an fport, @code{flush} causes buffered output to be
written to the file descriptor, while @code{end_input} causes the
descriptor position to be adjusted to account for buffered input which
was never read.

The special treatment must be performed if the @code{rw_random} flag in
the port is non-zero.

@subsection The @code{rw_active} variable

The @code{rw_active} variable in the port is only used if
@code{rw_random} is set.  It's defined as an enum with the following
values:

@table @code
@item SCM_PORT_READ
the read buffer may have unread data.

@item SCM_PORT_WRITE
the write buffer may have unwritten data.

@item SCM_PORT_NEITHER
neither the write nor the read buffer has data.
@end table

@subsection Reading from a port.

To read from a port, it's possible to either call existing libguile
procedures such as @code{scm_getc} and @code{scm_read_line} or to read
data from the read buffer directly.  Reading from the buffer involves
the following steps:

@enumerate
@item
Flush output on the port, if @code{rw_active} is @code{SCM_PORT_WRITE}.

@item
Fill the read buffer, if it's empty, using @code{scm_fill_input}.

@item Read the data from the buffer and update the read position in
the buffer.  Steps 2) and 3) may be repeated as many times as required.

@item Set rw_active to @code{SCM_PORT_READ} if @code{rw_random} is set.

@item update the port's line and column counts.
@end enumerate

@subsection Writing to a port.

To write data to a port, calling @code{scm_lfwrite} should be sufficient for
most purposes.  This takes care of the following steps:

@enumerate
@item
End input on the port, if @code{rw_active} is @code{SCM_PORT_READ}.

@item
Pass the data to the ptob implementation using the @code{write} ptob
procedure.  The advantage of using the ptob @code{write} instead of
manipulating the write buffer directly is that it allows the data to be
written in one operation even if the port is using the single-byte
@code{shortbuf}.

@item
Set @code{rw_active} to @code{SCM_PORT_WRITE} if @code{rw_random}
is set.
@end enumerate

@node Port Implementation
@section Port Implementation
This section describes how to implement a new port type in C.

As described in the previous section, a port type object (ptob) is
a structure of type @code{scm_ptob_descriptor}.  A ptob is created by
calling @code{scm_make_port_type}.

All of the elements of the ptob, apart from @code{name}, are procedures
which collectively implement the port behaviour.  Creating a new port
type mostly involves writing these procedures.

@code{scm_make_port_type} initialises three elements of the structure
(@code{name}, @code{fill_input} and @code{write}) from its arguments.
The remaining elements are initialised with default values and can be
set later if required.

@table @code
@item name
A pointer to a NUL terminated string: the name of the port type.  This
is the only element of @code{scm_ptob_descriptor} which is not
a procedure.  Set via the first argument to @code{scm_make_port_type}.

@item mark
Called during garbage collection to mark any SCM objects that a port
object may contain.  It doesn't need to be set unless the port has
@code{SCM} components.  Set using @code{scm_set_port_mark}.

@item free
Called when the port is collected during gc.  It
should free any resources used by the port.
Set using @code{scm_set_port_free}.

@item print
Called when @code{write} is called on the port object, to print a
port description.  e.g., for an fport it may produce something like:
@code{#<input: /etc/passwd 3>}.   Set using @code{scm_set_port_print}.

@item equalp
Not used at present.  Set using @code{scm_set_port_equalp}.

@item close
Called when the port is closed, unless it was collected during gc.  It
should free any resources used by the port.
Set using @code{scm_set_port_close}.

@item write
Accept data which is to be written using the port.  The port implementation
may choose to buffer the data instead of processing it directly.
Set via the third argument to @code{scm_make_port_type}.

@item flush
Complete the processing of buffered output data.  Reset the value of
@code{rw_active} to @code{SCM_PORT_NEITHER}.
Set using @code{scm_set_port_flush}.

@item end_input
Perform any synchronisation required when switching from input to output
on the port.  Reset the value of @code{rw_active} to @code{SCM_PORT_NEITHER}.
Set using @code{scm_set_port_end_input}.

@item fill_input
Read new data into the read buffer and return the first character.  It
can be assumed that the read buffer is empty when this procedure is called.
Set via the second argument to @code{scm_make_port_type}.

@item input_waiting
Return a lower bound on the number of bytes that could be read from the
port without blocking.  It can be assumed that the current state of
@code{rw_active} is @code{SCM_PORT_NEITHER}.
Set using @code{scm_set_port_input_waiting}.

@item seek
Set the current position of the port.  The procedure can not make
any assumptions about the value of @code{rw_active} when it's
called.  It can reset the buffers first if desired by using something
like:

@example
      if (pt->rw_active == SCM_PORT_READ)
	scm_end_input (object);
      else if (pt->rw_active == SCM_PORT_WRITE)
	ptob->flush (object);
@end example

However note that this will have the side effect of discarding any data
in the unread-char buffer, in addition to any side effects from the
@code{end_input} and @code{flush} ptob procedures.  This is undesirable
when seek is called to measure the current position of the port, i.e.,
@code{(seek p 0 SEEK_CUR)}.  The libguile fport and string port
implementations take care to avoid this problem.

The procedure is set using @code{scm_set_port_seek}.

@item truncate
Truncate the port data to be specified length.  It can be assumed that the
current state of @code{rw_active} is @code{SCM_PORT_NEITHER}.
Set using @code{scm_set_port_truncate}.

@end table


@page
@node Numbers
@chapter Numbers

@c docstring begin (texi-doc-string "guile" "exact?")
@deffn primitive exact? x
Return #t if X is an exact number, #f otherwise.
@end deffn

@c docstring begin (texi-doc-string "guile" "odd?")
@deffn primitive odd? n
Return #t if N is an odd number, #f otherwise.
@end deffn

@c docstring begin (texi-doc-string "guile" "even?")
@deffn primitive even? n
Return #t if N is an even number, #f otherwise.
@end deffn

@c begin (texi-doc-string "guile" "abs")
@deffn primitive abs
@end deffn

@c begin (texi-doc-string "guile" "quotient")
@deffn primitive quotient
@end deffn

@c begin (texi-doc-string "guile" "remainder")
@deffn primitive remainder
@end deffn

@c begin (texi-doc-string "guile" "modulo")
@deffn primitive modulo
@end deffn

@c begin (texi-doc-string "guile" "gcd")
@deffn primitive gcd
@end deffn

@c begin (texi-doc-string "guile" "lcm")
@deffn primitive lcm
@end deffn

@c docstring begin (texi-doc-string "guile" "number->string")
@deffn primitive number->string n [radix]
Return a string holding the external representation of the
number N in the given RADIX.  If N is inexact, a radix of 10
will be used.
@end deffn

@c docstring begin (texi-doc-string "guile" "string->number")
@deffn primitive string->number string [radix]
Returns a number of the maximally precise representation
expressed by the given STRING. RADIX must be an exact integer,
either 2, 8, 10, or 16. If supplied, RADIX is a default radix
that may be overridden by an explicit radix prefix in STRING
(e.g. "#o177"). If RADIX is not supplied, then the default
radix is 10. If string is not a syntactically valid notation
for a number, then `string->number' returns #f.  (r5rs)
@end deffn

@c docstring begin (texi-doc-string "guile" "number?")
@deffn primitive number? x
Return #t if X is any kind of number, #f else.
@end deffn

@c docstring begin (texi-doc-string "guile" "complex?")
@deffn primitive complex? x
Return #t if X is a complex number, #f else.  Note that the
sets of real, rational and integer values form subsets of the
set of complex numbers, i. e. the predicate will also be
fulfilled if X is a real, rational or integer number.
@end deffn

@c docstring begin (texi-doc-string "guile" "real?")
@deffn primitive real? x
Return #t if X is a real number, #f else.  Note that the
sets of integer and rational values form subsets of the set of real
numbers, i.e. the predicate will also be fulfilled if X is an
integer number or a rational number.
@end deffn

@c docstring begin (texi-doc-string "guile" "rational?")
@deffn primitive rational? x
Return #t if X is a rational number, #f else.  Note that the
set of integer values forms a subset of the set of rational
numbers, i. e. the predicate will also be fulfilled if X is an
integer number.
@end deffn

@c docstring begin (texi-doc-string "guile" "integer?")
@deffn primitive integer? x
Return #t if X is an integer number, #f else.
@end deffn

@c docstring begin (texi-doc-string "guile" "inexact?")
@deffn primitive inexact? x
Return #t if X is an inexact number, #f else.
@end deffn

@c begin (texi-doc-string "guile" "=")
@deffn primitive =
@end deffn

@c begin (texi-doc-string "guile" "<")
@deffn primitive <
@end deffn

@c begin (texi-doc-string "guile" ">")
@deffn primitive >
@end deffn

@c begin (texi-doc-string "guile" "<=")
@deffn primitive <=
@end deffn

@c begin (texi-doc-string "guile" ">=")
@deffn primitive >=
@end deffn

@c begin (texi-doc-string "guile" "zero?")
@deffn primitive zero?
@end deffn

@c begin (texi-doc-string "guile" "positive?")
@deffn primitive positive?
@end deffn

@c begin (texi-doc-string "guile" "negative?")
@deffn primitive negative?
@end deffn

@c begin (texi-doc-string "guile" "max")
@deffn primitive max
@end deffn

@c begin (texi-doc-string "guile" "min")
@deffn primitive min
@end deffn

@c begin (texi-doc-string "guile" "+")
@deffn primitive +
@end deffn

@c begin (texi-doc-string "guile" "-")
@deffn primitive -
@end deffn

@c begin (texi-doc-string "guile" "*")
@deffn primitive *
@end deffn

@c begin (texi-doc-string "guile" "/")
@deffn primitive /
@end deffn

@c begin (texi-doc-string "guile" "$asinh")
@deffn primitive $asinh
@end deffn

@c begin (texi-doc-string "guile" "$acosh")
@deffn primitive $acosh
@end deffn

@c begin (texi-doc-string "guile" "$atanh")
@deffn primitive $atanh
@end deffn

@c begin (texi-doc-string "guile" "truncate")
@deffn primitive truncate
@end deffn

@c begin (texi-doc-string "guile" "round")
@deffn primitive round
@end deffn

@c begin (texi-doc-string "guile" "exact->inexact")
@deffn primitive exact->inexact
@end deffn

@c begin (texi-doc-string "guile" "floor")
@deffn primitive floor
@end deffn

@c begin (texi-doc-string "guile" "ceiling")
@deffn primitive ceiling
@end deffn

@c begin (texi-doc-string "guile" "$sqrt")
@deffn primitive $sqrt
@end deffn

@c begin (texi-doc-string "guile" "$abs")
@deffn primitive $abs
@end deffn

@c begin (texi-doc-string "guile" "$exp")
@deffn primitive $exp
@end deffn

@c begin (texi-doc-string "guile" "$log")
@deffn primitive $log
@end deffn

@c begin (texi-doc-string "guile" "$sin")
@deffn primitive $sin
@end deffn

@c begin (texi-doc-string "guile" "$cos")
@deffn primitive $cos
@end deffn

@c begin (texi-doc-string "guile" "$tan")
@deffn primitive $tan
@end deffn

@c begin (texi-doc-string "guile" "$asin")
@deffn primitive $asin
@end deffn

@c begin (texi-doc-string "guile" "$acos")
@deffn primitive $acos
@end deffn

@c begin (texi-doc-string "guile" "$atan")
@deffn primitive $atan
@end deffn

@c begin (texi-doc-string "guile" "$sinh")
@deffn primitive $sinh
@end deffn

@c begin (texi-doc-string "guile" "$cosh")
@deffn primitive $cosh
@end deffn

@c begin (texi-doc-string "guile" "$tanh")
@deffn primitive $tanh
@end deffn

@c docstring begin (texi-doc-string "guile" "$expt")
@deffn primitive $expt z1 z2
@end deffn

@c docstring begin (texi-doc-string "guile" "$atan2")
@deffn primitive $atan2 z1 z2
@end deffn

@c docstring begin (texi-doc-string "guile" "make-rectangular")
@deffn primitive make-rectangular real imaginary
Return a complex number constructed of the given REAL and
IMAGINARY parts.
@end deffn

@c docstring begin (texi-doc-string "guile" "make-polar")
@deffn primitive make-polar z1 z2
Return the complex number Z1 * e^(i * Z2).
@end deffn

@c begin (texi-doc-string "guile" "real-part")
@deffn primitive real-part
@end deffn

@c begin (texi-doc-string "guile" "imag-part")
@deffn primitive imag-part
@end deffn

@c begin (texi-doc-string "guile" "magnitude")
@deffn primitive magnitude
@end deffn

@c begin (texi-doc-string "guile" "angle")
@deffn primitive angle
@end deffn

@c docstring begin (texi-doc-string "guile" "inexact->exact")
@deffn primitive inexact->exact z
Returns an exact number that is numerically closest to Z.
@end deffn


@page
@node Random
@chapter Random

@c docstring begin (texi-doc-string "guile" "copy-random-state")
@deffn primitive copy-random-state [state]
Return a copy of the random state STATE.
@end deffn

@c docstring begin (texi-doc-string "guile" "random")
@deffn primitive random n [state]
Return a number in [0,N).
Accepts a positive integer or real n and returns a
number of the same type between zero (inclusive) and
N (exclusive). The values returned have a uniform
distribution.
The optional argument STATE must be of the type produced by
`seed->random-state'. It defaults to the value of the variable
*random-state*. This object is used to maintain the state of
the pseudo-random-number generator and is altered as a side
effect of the random operation.
@end deffn

@c docstring begin (texi-doc-string "guile" "random:exp")
@deffn primitive random:exp [state]
Returns an inexact real in an exponential distribution with mean 1.
For an exponential distribution with mean u use (* u (random:exp)).
@end deffn

@c docstring begin (texi-doc-string "guile" "random:hollow-sphere!")
@deffn primitive random:hollow-sphere! v [state]
Fills vect with inexact real random numbers
the sum of whose squares is equal to 1.0.
Thinking of vect as coordinates in space of
dimension n = (vector-length vect), the coordinates
are uniformly distributed over the surface of the
unit n-shere.
@end deffn

@c docstring begin (texi-doc-string "guile" "random:normal")
@deffn primitive random:normal [state]
Returns an inexact real in a normal distribution.
The distribution used has mean 0 and standard deviation 1.
For a normal distribution with mean m and standard deviation
d use @code{(+ m (* d (random:normal)))}.
@end deffn

@c docstring begin (texi-doc-string "guile" "random:normal-vector!")
@deffn primitive random:normal-vector! v [state]
Fills vect with inexact real random numbers that are
independent and standard normally distributed
(i.e., with mean 0 and variance 1).
@end deffn

@c docstring begin (texi-doc-string "guile" "random:solid-sphere!")
@deffn primitive random:solid-sphere! v [state]
Fills vect with inexact real random numbers
the sum of whose squares is less than 1.0.
Thinking of vect as coordinates in space of
dimension n = (vector-length vect), the coordinates
are uniformly distributed within the unit n-shere.
The sum of the squares of the numbers is returned.
@end deffn

@c docstring begin (texi-doc-string "guile" "random:uniform")
@deffn primitive random:uniform [state]
Returns a uniformly distributed inexact real random number in [0,1).
@end deffn

@c docstring begin (texi-doc-string "guile" "seed->random-state")
@deffn primitive seed->random-state seed
Return a new random state using SEED.
@end deffn


@page
@node Sorting
@chapter Sorting

@c docstring begin (texi-doc-string "guile" "merge!")
@deffn primitive merge! alist blist less
@end deffn

@c docstring begin (texi-doc-string "guile" "merge")
@deffn primitive merge alist blist less
@end deffn

@c docstring begin (texi-doc-string "guile" "restricted-vector-sort!")
@deffn primitive restricted-vector-sort! vec less startpos endpos
@end deffn

@c docstring begin (texi-doc-string "guile" "sort!")
@deffn primitive sort! items less
@end deffn

@c docstring begin (texi-doc-string "guile" "sort")
@deffn primitive sort items less
@end deffn

@c docstring begin (texi-doc-string "guile" "sort-list!")
@deffn primitive sort-list! items less
@end deffn

@c docstring begin (texi-doc-string "guile" "sort-list")
@deffn primitive sort-list items less
@end deffn

@c docstring begin (texi-doc-string "guile" "sorted?")
@deffn primitive sorted? items less
@end deffn

@c docstring begin (texi-doc-string "guile" "stable-sort!")
@deffn primitive stable-sort! items less
@end deffn

@c docstring begin (texi-doc-string "guile" "stable-sort")
@deffn primitive stable-sort items less
@end deffn


@page
@node Reading and Writing
@chapter Reading and Writing

@c docstring begin (texi-doc-string "guile" "get-print-state")
@deffn primitive get-print-state port
@end deffn

@c docstring begin (texi-doc-string "guile" "newline")
@deffn primitive newline [port]
Send a newline to PORT.
@end deffn

@c docstring begin (texi-doc-string "guile" "port-with-print-state")
@deffn primitive port-with-print-state port pstate
@end deffn

@c docstring begin (texi-doc-string "guile" "print-options-interface")
@deffn primitive print-options-interface [setting]
@end deffn

@c docstring begin (texi-doc-string "guile" "simple-format")
@deffn primitive simple-format destination message . args
Write MESSAGE to DESTINATION, defaulting to `current-output-port'.
MESSAGE can contain ~A (was %s) and ~S (was %S) escapes.  When printed,
the escapes are replaced with corresponding members of ARGS:
~A formats using `display' and ~S formats using `write'.
If DESTINATION is #t, then use the `current-output-port',
if DESTINATION is #f, then return a string containing the formatted text.
Does not add a trailing newline.
@end deffn

@c docstring begin (texi-doc-string "guile" "write-char")
@deffn primitive write-char chr [port]
Send character CHR to PORT.
@end deffn

@c docstring begin (texi-doc-string "guile" "read")
@deffn primitive read [port]
@end deffn

@c docstring begin (texi-doc-string "guile" "read-hash-extend")
@deffn primitive read-hash-extend chr proc
@end deffn

@c docstring begin (texi-doc-string "guile" "read-options-interface")
@deffn primitive read-options-interface [setting]
@end deffn


@page
@node Bitwise Operations
@chapter Bitwise Operations

@c docstring begin (texi-doc-string "guile" "logand")
@deffn primitive logand n1 n2
Returns the integer which is the bit-wise AND of the two integer
arguments.

Example:
@lisp
(number->string (logand #b1100 #b1010) 2)
   @result{} "1000"
@end lisp
@end deffn

@c docstring begin (texi-doc-string "guile" "logior")
@deffn primitive logior n1 n2
Returns the integer which is the bit-wise OR of the two integer
arguments.

Example:
@lisp
(number->string (logior #b1100 #b1010) 2)
   @result{} "1110"
@end lisp
@end deffn

@c docstring begin (texi-doc-string "guile" "logxor")
@deffn primitive logxor n1 n2
Returns the integer which is the bit-wise XOR of the two integer
arguments.

Example:
@lisp
(number->string (logxor #b1100 #b1010) 2)
   @result{} "110"
@end lisp
@end deffn

@c docstring begin (texi-doc-string "guile" "lognot")
@deffn primitive lognot n
Returns the integer which is the 2s-complement of the integer argument.

Example:
@lisp
(number->string (lognot #b10000000) 2)
   @result{} "-10000001"
(number->string (lognot #b0) 2)
   @result{} "-1"
@end lisp
@end deffn

@c ARGFIXME j/n1 k/n2
@c docstring begin (texi-doc-string "guile" "logtest")
@deffn primitive logtest n1 n2
@example
(logtest j k) @equiv{} (not (zero? (logand j k)))

(logtest #b0100 #b1011) @result{} #f
(logtest #b0100 #b0111) @result{} #t
@end example
@end deffn

@c docstring begin (texi-doc-string "guile" "logbit?")
@deffn primitive logbit? index j
@example
(logbit? index j) @equiv{} (logtest (integer-expt 2 index) j)

(logbit? 0 #b1101) @result{} #t
(logbit? 1 #b1101) @result{} #f
(logbit? 2 #b1101) @result{} #t
(logbit? 3 #b1101) @result{} #t
(logbit? 4 #b1101) @result{} #f
@end example
@end deffn

@c ARGFIXME n/int cnt/count
@c docstring begin (texi-doc-string "guile" "ash")
@deffn primitive ash n cnt
The function ash performs an arithmetic shift left by CNT bits
(or shift right, if CNT is negative).  'Arithmetic' means, that
the function does not guarantee to keep the bit structure of N,
but rather guarantees that the result will always be rounded
towards minus infinity.  Therefore, the results of ash and a
corresponding bitwise shift will differ if N is negative.

Formally, the function returns an integer equivalent to
@code{(inexact->exact (floor (* N (expt 2 CNT))))}.@refill

Example:
@lisp
(number->string (ash #b1 3) 2)
   @result{} "1000"
(number->string (ash #b1010 -1) 2)
   @result{} "101"
@end lisp
@end deffn

@c docstring begin (texi-doc-string "guile" "logcount")
@deffn primitive logcount n
Returns the number of bits in integer @var{n}.  If integer is positive,
the 1-bits in its binary representation are counted.  If negative, the
0-bits in its two's-complement binary representation are counted.  If 0,
0 is returned.

Example:
@lisp
(logcount #b10101010)
   @result{} 4
(logcount 0)
   @result{} 0
(logcount -2)
   @result{} 1
@end lisp
@end deffn

@c docstring begin (texi-doc-string "guile" "integer-length")
@deffn primitive integer-length n
Returns the number of bits neccessary to represent @var{n}.

Example:
@lisp
(integer-length #b10101010)
   @result{} 8
(integer-length 0)
   @result{} 0
(integer-length #b1111)
   @result{} 4
@end lisp
@end deffn

@c docstring begin (texi-doc-string "guile" "integer-expt")
@deffn primitive integer-expt n k
Returns @var{n} raised to the non-negative integer exponent @var{k}.

Example:
@lisp
(integer-expt 2 5)
   @result{} 32
(integer-expt -3 3)
   @result{} -27
@end lisp
@end deffn

@c docstring begin (texi-doc-string "guile" "bit-extract")
@deffn primitive bit-extract n start end
Returns the integer composed of the @var{start} (inclusive) through
@var{end} (exclusive) bits of @var{n}.  The @var{start}th bit becomes
the 0-th bit in the result.@refill

Example:
@lisp
(number->string (bit-extract #b1101101010 0 4) 2)
   @result{} "1010"
(number->string (bit-extract #b1101101010 4 9) 2)
   @result{} "10110"
@end lisp
@end deffn

@page
@node Regular Expressions
@chapter Regular Expressions

@cindex regular expressions
@cindex regex
@cindex emacs regexp

A @dfn{regular expression} (or @dfn{regexp}) is a pattern that
describes a whole class of strings.  A full description of regular
expressions and their syntax is beyond the scope of this manual;
an introduction can be found in the Emacs manual (@pxref{Regexps,
, Syntax of Regular Expressions, emacs, The GNU Emacs Manual}, or
in many general Unix reference books.

If your system does not include a POSIX regular expression library, and
you have not linked Guile with a third-party regexp library such as Rx,
these functions will not be available.  You can tell whether your Guile
installation includes regular expression support by checking whether the
@code{*features*} list includes the @code{regex} symbol.

@menu
* Regexp Functions::            Functions that create and match regexps.
* Match Structures::            Finding what was matched by a regexp.
* Backslash Escapes::           Removing the special meaning of regexp metacharacters.
* Rx Interface::                Tom Lord's Rx library does things differently.
@end menu

[FIXME: it may be useful to include an Examples section.  Parts of this
interface are bewildering on first glance.]

@node Regexp Functions
@section Regexp Functions

By default, Guile supports POSIX extended regular expressions.
That means that the characters @samp{(}, @samp{)}, @samp{+} and
@samp{?} are special, and must be escaped if you wish to match the
literal characters.

This regular expression interface was modeled after that
implemented by SCSH, the Scheme Shell.  It is intended to be
upwardly compatible with SCSH regular expressions.

@c begin (scm-doc-string "regex.scm" "string-match")
@deffn procedure string-match pattern str [start]
Compile the string @var{pattern} into a regular expression and compare
it with @var{str}.  The optional numeric argument @var{start} specifies
the position of @var{str} at which to begin matching.

@code{string-match} returns a @dfn{match structure} which
describes what, if anything, was matched by the regular
expression.  @xref{Match Structures}.  If @var{str} does not match
@var{pattern} at all, @code{string-match} returns @code{#f}.
@end deffn

Each time @code{string-match} is called, it must compile its
@var{pattern} argument into a regular expression structure.  This
operation is expensive, which makes @code{string-match} inefficient if
the same regular expression is used several times (for example, in a
loop).  For better performance, you can compile a regular expression in
advance and then match strings against the compiled regexp.

@c ARGFIXME pat/str flags/flag
@c docstring begin (texi-doc-string "guile" "make-regexp")
@deffn primitive make-regexp pat . flags
Compile the regular expression described by @var{str}, and return the
compiled regexp structure.  If @var{str} does not describe a legal
regular expression, @code{make-regexp} throws a
@code{regular-expression-syntax} error.

The @var{flag} arguments change the behavior of the compiled regexp.
The following flags may be supplied:

@table @code
@item regexp/icase
Consider uppercase and lowercase letters to be the same when matching.

@item regexp/newline
If a newline appears in the target string, then permit the @samp{^} and
@samp{$} operators to match immediately after or immediately before the
newline, respectively.  Also, the @samp{.} and @samp{[^...]} operators
will never match a newline character.  The intent of this flag is to
treat the target string as a buffer containing many lines of text, and
the regular expression as a pattern that may match a single one of those
lines.

@item regexp/basic
Compile a basic (``obsolete'') regexp instead of the extended
(``modern'') regexps that are the default.  Basic regexps do not
consider @samp{|}, @samp{+} or @samp{?} to be special characters, and
require the @samp{@{...@}} and @samp{(...)} metacharacters to be
backslash-escaped (@pxref{Backslash Escapes}).  There are several other
differences between basic and extended regular expressions, but these
are the most significant.

@item regexp/extended
Compile an extended regular expression rather than a basic regexp.  This
is the default behavior; this flag will not usually be needed.  If a
call to @code{make-regexp} includes both @code{regexp/basic} and
@code{regexp/extended} flags, the one which comes last will override
the earlier one.
@end table
@end deffn

@c ARGFIXME rx/regexp
@c docstring begin (texi-doc-string "guile" "regexp-exec")
@deffn primitive regexp-exec rx str [start [flags]]
Match the compiled regular expression @var{regexp} against @code{str}.
If the optional integer @var{start} argument is provided, begin matching
from that position in the string.  Return a match structure describing
the results of the match, or @code{#f} if no match could be found.
@end deffn

@c ARGFIXME x/obj
@c docstring begin (texi-doc-string "guile" "regexp?")
@deffn primitive regexp? x
Return @code{#t} if @var{obj} is a compiled regular expression, or
@code{#f} otherwise.
@end deffn

Regular expressions are commonly used to find patterns in one string and
replace them with the contents of another string.

@c begin (scm-doc-string "regex.scm" "regexp-substitute")
@deffn procedure regexp-substitute port match [item@dots{}]
Write to the output port @var{port} selected contents of the match
structure @var{match}.  Each @var{item} specifies what should be
written, and may be one of the following arguments:

@itemize @bullet
@item
A string.  String arguments are written out verbatim.

@item
An integer.  The submatch with that number is written.

@item
The symbol @samp{pre}.  The portion of the matched string preceding
the regexp match is written.

@item
The symbol @samp{post}.  The portion of the matched string following
the regexp match is written.
@end itemize

@var{port} may be @code{#f}, in which case nothing is written; instead,
@code{regexp-substitute} constructs a string from the specified
@var{item}s and returns that.
@end deffn

@c begin (scm-doc-string "regex.scm" "regexp-substitute")
@deffn procedure regexp-substitute/global port regexp target [item@dots{}]
Similar to @code{regexp-substitute}, but can be used to perform global
substitutions on @var{str}.  Instead of taking a match structure as an
argument, @code{regexp-substitute/global} takes two string arguments: a
@var{regexp} string describing a regular expression, and a @var{target}
string which should be matched against this regular expression.

Each @var{item} behaves as in @var{regexp-substitute}, with the
following exceptions:

@itemize @bullet
@item
A function may be supplied.  When this function is called, it will be
passed one argument: a match structure for a given regular expression
match.  It should return a string to be written out to @var{port}.

@item
The @samp{post} symbol causes @code{regexp-substitute/global} to recurse
on the unmatched portion of @var{str}.  This @emph{must} be supplied in
order to perform global search-and-replace on @var{str}; if it is not
present among the @var{item}s, then @code{regexp-substitute/global} will
return after processing a single match.
@end itemize
@end deffn

@node Match Structures
@section Match Structures

@cindex match structures

A @dfn{match structure} is the object returned by @code{string-match} and
@code{regexp-exec}.  It describes which portion of a string, if any,
matched the given regular expression.  Match structures include: a
reference to the string that was checked for matches; the starting and
ending positions of the regexp match; and, if the regexp included any
parenthesized subexpressions, the starting and ending positions of each
submatch.

In each of the regexp match functions described below, the @code{match}
argument must be a match structure returned by a previous call to
@code{string-match} or @code{regexp-exec}.  Most of these functions
return some information about the original target string that was
matched against a regular expression; we will call that string
@var{target} for easy reference.

@c begin (scm-doc-string "regex.scm" "regexp-match?")
@deffn procedure regexp-match? obj
Return @code{#t} if @var{obj} is a match structure returned by a
previous call to @code{regexp-exec}, or @code{#f} otherwise.
@end deffn

@c begin (scm-doc-string "regex.scm" "match:substring")
@deffn procedure match:substring match [n]
Return the portion of @var{target} matched by subexpression number
@var{n}.  Submatch 0 (the default) represents the entire regexp match.
If the regular expression as a whole matched, but the subexpression
number @var{n} did not match, return @code{#f}.
@end deffn

@c begin (scm-doc-string "regex.scm" "match:start")
@deffn procedure match:start match [n]
Return the starting position of submatch number @var{n}.
@end deffn

@c begin (scm-doc-string "regex.scm" "match:end")
@deffn procedure match:end match [n]
Return the ending position of submatch number @var{n}.
@end deffn

@c begin (scm-doc-string "regex.scm" "match:prefix")
@deffn procedure match:prefix match
Return the unmatched portion of @var{target} preceding the regexp match.
@end deffn

@c begin (scm-doc-string "regex.scm" "match:suffix")
@deffn procedure match:suffix match
Return the unmatched portion of @var{target} following the regexp match.
@end deffn

@c begin (scm-doc-string "regex.scm" "match:count")
@deffn procedure match:count match
Return the number of parenthesized subexpressions from @var{match}.
Note that the entire regular expression match itself counts as a
subexpression, and failed submatches are included in the count.
@end deffn

@c begin (scm-doc-string "regex.scm" "match:string")
@deffn procedure match:string match
Return the original @var{target} string.
@end deffn

@node Backslash Escapes
@section Backslash Escapes

Sometimes you will want a regexp to match characters like @samp{*} or
@samp{$} exactly.  For example, to check whether a particular string
represents a menu entry from an Info node, it would be useful to match
it against a regexp like @samp{^* [^:]*::}.  However, this won't work;
because the asterisk is a metacharacter, it won't match the @samp{*} at
the beginning of the string.  In this case, we want to make the first
asterisk un-magic.

You can do this by preceding the metacharacter with a backslash
character @samp{\}.  (This is also called @dfn{quoting} the
metacharacter, and is known as a @dfn{backslash escape}.)  When Guile
sees a backslash in a regular expression, it considers the following
glyph to be an ordinary character, no matter what special meaning it
would ordinarily have.  Therefore, we can make the above example work by
changing the regexp to @samp{^\* [^:]*::}.  The @samp{\*} sequence tells
the regular expression engine to match only a single asterisk in the
target string.

Since the backslash is itself a metacharacter, you may force a regexp to
match a backslash in the target string by preceding the backslash with
itself.  For example, to find variable references in a @TeX{} program,
you might want to find occurrences of the string @samp{\let\} followed
by any number of alphabetic characters.  The regular expression
@samp{\\let\\[A-Za-z]*} would do this: the double backslashes in the
regexp each match a single backslash in the target string.

@c begin (scm-doc-string "regex.scm" "regexp-quote")
@deffn procedure regexp-quote str
Quote each special character found in @var{str} with a backslash, and
return the resulting string.
@end deffn

@strong{Very important:} Using backslash escapes in Guile source code
(as in Emacs Lisp or C) can be tricky, because the backslash character
has special meaning for the Guile reader.  For example, if Guile
encounters the character sequence @samp{\n} in the middle of a string
while processing Scheme code, it replaces those characters with a
newline character.  Similarly, the character sequence @samp{\t} is
replaced by a horizontal tab.  Several of these @dfn{escape sequences}
are processed by the Guile reader before your code is executed.
Unrecognized escape sequences are ignored: if the characters @samp{\*}
appear in a string, they will be translated to the single character
@samp{*}.

This translation is obviously undesirable for regular expressions, since
we want to be able to include backslashes in a string in order to
escape regexp metacharacters.  Therefore, to make sure that a backslash
is preserved in a string in your Guile program, you must use @emph{two}
consecutive backslashes:

@lisp
(define Info-menu-entry-pattern (make-regexp "^\\* [^:]*"))
@end lisp

The string in this example is preprocessed by the Guile reader before
any code is executed.  The resulting argument to @code{make-regexp} is
the string @samp{^\* [^:]*}, which is what we really want.

This also means that in order to write a regular expression that matches
a single backslash character, the regular expression string in the
source code must include @emph{four} backslashes.  Each consecutive pair
of backslashes gets translated by the Guile reader to a single
backslash, and the resulting double-backslash is interpreted by the
regexp engine as matching a single backslash character.  Hence:

@lisp
(define tex-variable-pattern (make-regexp "\\\\let\\\\=[A-Za-z]*"))
@end lisp

The reason for the unwieldiness of this syntax is historical.  Both
regular expression pattern matchers and Unix string processing systems
have traditionally used backslashes with the special meanings
described above.  The POSIX regular expression specification and ANSI C
standard both require these semantics.  Attempting to abandon either
convention would cause other kinds of compatibility problems, possibly
more severe ones.  Therefore, without extending the Scheme reader to
support strings with different quoting conventions (an ungainly and
confusing extension when implemented in other languages), we must adhere
to this cumbersome escape syntax.

@node Rx Interface
@section Rx Interface

[FIXME: this is taken from Gary and Mark's quick summaries and should be
reviewed and expanded.  Rx is pretty stable, so could already be done!]

@cindex rx
@cindex finite automaton

Guile includes an interface to Tom Lord's Rx library (currently only to
POSIX regular expressions).  Use of the library requires a two step
process: compile a regular expression into an efficient structure, then
use the structure in any number of string comparisons.

For example, given the
regular expression @samp{abc.} (which matches any string containing
@samp{abc} followed by any single character):

@smalllisp
guile> @kbd{(define r (regcomp "abc."))}
guile> @kbd{r}
#<rgx abc.>
guile> @kbd{(regexec r "abc")}
#f
guile> @kbd{(regexec r "abcd")}
#((0 . 4))
guile>
@end smalllisp

The definitions of @code{regcomp} and @code{regexec} are as follows:

@c NJFIXME not in libguile!
@deffn primitive regcomp pattern [flags]
Compile the regular expression pattern using POSIX rules.  Flags is
optional and should be specified using symbolic names:
@defvar REG_EXTENDED
use extended POSIX syntax
@end defvar
@defvar REG_ICASE
use case-insensitive matching
@end defvar
@defvar REG_NEWLINE
allow anchors to match after newline characters in the
string and prevents @code{.} or @code{[^...]} from matching newlines.
@end defvar

The @code{logior} procedure can be used to combine multiple flags.
The default is to use
POSIX basic syntax, which makes @code{+} and @code{?}  literals and @code{\+}
and @code{\?}
operators.  Backslashes in @var{pattern} must be escaped if specified in a
literal string e.g., @code{"\\(a\\)\\?"}.
@end deffn

@c NJFIXME not in libguile!
@deffn primitive regexec regex string [match-pick] [flags]

Match @var{string} against the compiled POSIX regular expression
@var{regex}.
@var{match-pick} and @var{flags} are optional.  Possible flags (which can be
combined using the logior procedure) are:

@defvar REG_NOTBOL
The beginning of line operator won't match the beginning of
@var{string} (presumably because it's not the beginning of a line)
@end defvar

@defvar REG_NOTEOL
Similar to REG_NOTBOL, but prevents the end of line operator
from matching the end of @var{string}.
@end defvar

If no match is possible, regexec returns #f.  Otherwise @var{match-pick}
determines the return value:

@code{#t} or unspecified: a newly-allocated vector is returned,
containing pairs with the indices of the matched part of @var{string} and any
substrings.

@code{""}: a list is returned: the first element contains a nested list
with the matched part of @var{string} surrounded by the the unmatched parts.
Remaining elements are matched substrings (if any).  All returned
substrings share memory with @var{string}.

@code{#f}: regexec returns #t if a match is made, otherwise #f.

vector: the supplied vector is returned, with the first element replaced
by a pair containing the indices of the matched portion of @var{string} and
further elements replaced by pairs containing the indices of matched
substrings (if any).

list: a list will be returned, with each member of the list
specified by a code in the corresponding position of the supplied list:

a number: the numbered matching substring (0 for the entire match).

@code{#\<}: the beginning of @var{string} to the beginning of the part matched
by regex.

@code{#\>}: the end of the matched part of @var{string} to the end of
@var{string}.

@code{#\c}: the "final tag", which seems to be associated with the "cut
operator", which doesn't seem to be available through the posix
interface.

e.g., @code{(list #\< 0 1 #\>)}.  The returned substrings share memory with
@var{string}.
@end deffn

Here are some other procedures that might be used when using regular
expressions:

@c NJFIXME not in libguile!
@deffn primitive compiled-regexp? obj
Test whether obj is a compiled regular expression.
@end deffn

@c NJFIXME not in libguile!
@deffn primitive regexp->dfa regex [flags]
@end deffn

@c NJFIXME not in libguile!
@deffn primitive dfa-fork dfa
@end deffn

@c NJFIXME not in libguile!
@deffn primitive reset-dfa! dfa
@end deffn

@c NJFIXME not in libguile!
@deffn primitive dfa-final-tag dfa
@end deffn

@c NJFIXME not in libguile!
@deffn primitive dfa-continuable? dfa
@end deffn

@c NJFIXME not in libguile!
@deffn primitive advance-dfa! dfa string
@end deffn


@page
@node Dynamic Linking from Marius
@chapter Dynamic Linking from Marius

@c NJFIXME primitive documentation here duplicates (and is generally
@c better than) documentation for the same primitives earlier on.

Most modern Unices have something called @dfn{shared libraries}.  This
ordinarily means that they have the capability to share the executable
image of a library between several running programs to save memory and
disk space.  But generally, shared libraries give a lot of additional
flexibility compared to the traditional static libraries.  In fact,
calling them `dynamic' libraries is as correct as calling them `shared'.

Shared libraries really give you a lot of flexibility in addition to the
memory and disk space savings.  When you link a program against a shared
library, that library is not closely incorporated into the final
executable.  Instead, the executable of your program only contains
enough information to find the needed shared libraries when the program
is actually run.  Only then, when the program is starting, is the final
step of the linking process performed.  This means that you need not
recompile all programs when you install a new, only slightly modified
version of a shared library.  The programs will pick up the changes
automatically the next time they are run.

Now, when all the necessary machinery is there to perform part of the
linking at run-time, why not take the next step and allow the programmer
to explicitly take advantage of it from within his program?  Of course,
many operating systems that support shared libraries do just that, and
chances are that Guile will allow you to access this feature from within
your Scheme programs.  As you might have guessed already, this feature
is called @dfn{dynamic linking}@footnote{Some people also refer to the
final linking stage at program startup as `dynamic linking', so if you
want to make yourself perfectly clear, it is probably best to use the
more technical term @dfn{dlopening}, as suggested by Gordon Matzigkeit
in his libtool documentation.}

As with many aspects of Guile, there is a low-level way to access the
dynamic linking apparatus, and a more high-level interface that
integrates dynamically linked libraries into the module system.

@menu
* Low level dynamic linking::
* Compiled Code Modules::
* Dynamic Linking and Compiled Code Modules::
@end menu

@node Low level dynamic linking
@section Low level dynamic linking

When using the low level procedures to do your dynamic linking, you have
complete control over which library is loaded when and what get's done
with it.

@deffn primitive dynamic-link library
Find the shared library denoted by @var{library} (a string) and link it
into the running Guile application.  When everything works out, return a
Scheme object suitable for representing the linked object file.
Otherwise an error is thrown.  How object files are searched is system
dependent.

Normally, @var{library} is just the name of some shared library file
that will be searched for in the places where shared libraries usually
reside, such as in @file{/usr/lib} and @file{/usr/local/lib}.
@end deffn

@deffn primitive dynamic-object? val
Determine whether @var{val} represents a dynamically linked object file.
@end deffn

@deffn primitive dynamic-unlink dynobj
Unlink the indicated object file from the application.  The argument
@var{dynobj} should be one of the values returned by
@code{dynamic-link}.  When @code{dynamic-unlink} has been called on
@var{dynobj}, it is no longer usable as an argument to the functions
below and you will get type mismatch errors when you try to.
@end deffn

@deffn primitive dynamic-func function dynobj
Search the C function indicated by @var{function} (a string or symbol)
in @var{dynobj} and return some Scheme object that can later be used
with @code{dynamic-call} to actually call this function.  Right now,
these Scheme objects are formed by casting the address of the function
to @code{long} and converting this number to its Scheme representation.

Regardless whether your C compiler prepends an underscore @samp{_} to
the global names in a program, you should @strong{not} include this
underscore in @var{function}.  Guile knows whether the underscore is
needed or not and will add it when necessary.
@end deffn

@deffn primitive dynamic-call function dynobj
Call the C function indicated by @var{function} and @var{dynobj}.  The
function is passed no arguments and its return value is ignored.  When
@var{function} is something returned by @code{dynamic-func}, call that
function and ignore @var{dynobj}.  When @var{function} is a string (or
symbol, etc.), look it up in @var{dynobj}; this is equivalent to

@smallexample
(dynamic-call (dynamic-func @var{function} @var{dynobj} #f))
@end smallexample

Interrupts are deferred while the C function is executing (with
@code{SCM_DEFER_INTS}/@code{SCM_ALLOW_INTS}).
@end deffn

@deffn primitive dynamic-args-call function dynobj args
Call the C function indicated by @var{function} and @var{dynobj}, just
like @code{dynamic-call}, but pass it some arguments and return its
return value.  The C function is expected to take two arguments and
return an @code{int}, just like @code{main}:

@smallexample
int c_func (int argc, char **argv);
@end smallexample

The parameter @var{args} must be a list of strings and is converted into
an array of @code{char *}.  The array is passed in @var{argv} and its
size in @var{argc}.  The return value is converted to a Scheme number
and returned from the call to @code{dynamic-args-call}.
@end deffn

When dynamic linking is disabled or not supported on your system,
the above functions throw errors, but they are still available.

Here is a small example that works on GNU/Linux:

@smallexample
(define libc-obj (dynamic-link "libc.so"))
libc-obj
@result{} #<dynamic-object "libc.so">
(dynamic-args-call 'rand libc-obj '())
@result{} 269167349
(dynamic-unlink libc-obj)
libc-obj
@result{} #<dynamic-object "libc.so" (unlinked)>
@end smallexample

As you can see, after calling @code{dynamic-unlink} on a dynamically
linked library, it is marked as @samp{(unlinked)} and you are no longer
able to use it with @code{dynamic-call}, etc.  Whether the library is
really removed from you program is system-dependent and will generally
not happen when some other parts of your program still use it.  In the
example above, @code{libc} is almost certainly not removed from your
program because it is badly needed by almost everything.

The functions to call a function from a dynamically linked library,
@code{dynamic-call} and @code{dynamic-args-call}, are not very powerful.
They are mostly intended to be used for calling specially written
initialization functions that will then add new primitives to Guile.
For example, we do not expect that you will dynamically link
@file{libX11} with @code{dynamic-link} and then construct a beautiful
graphical user interface just by using @code{dynamic-call} and
@code{dynamic-args-call}.  Instead, the usual way would be to write a
special Guile<->X11 glue library that has intimate knowledge about both
Guile and X11 and does whatever is necessary to make them inter-operate
smoothly.  This glue library could then be dynamically linked into a
vanilla Guile interpreter and activated by calling its initialization
function.  That function would add all the new types and primitives to
the Guile interpreter that it has to offer.

From this setup the next logical step is to integrate these glue
libraries into the module system of Guile so that you can load new
primitives into a running system just as you can load new Scheme code.

There is, however, another possibility to get a more thorough access to
the functions contained in a dynamically linked library.  Anthony Green
has written @file{libffi}, a library that implements a @dfn{foreign
function interface} for a number of different platforms.  With it, you
can extend the Spartan functionality of @code{dynamic-call} and
@code{dynamic-args-call} considerably.  There is glue code available in
the Guile contrib archive to make @file{libffi} accessible from Guile.

@node Compiled Code Modules
@section Putting Compiled Code into Modules

The new primitives that you add to Guile with @code{gh_new_procedure} or
with any of the other mechanisms are normally placed into the same
module as all the other builtin procedures (like @code{display}).
However, it is also possible to put new primitives into their own
module.

The mechanism for doing so is not very well thought out and is likely to
change when the module system of Guile itself is revised, but it is
simple and useful enough to document it as it stands.

What @code{gh_new_procedure} and the functions used by the snarfer
really do is to add the new primitives to whatever module is the
@emph{current module} when they are called.  This is analogous to the
way Scheme code is put into modules: the @code{define-module} expression
at the top of a Scheme source file creates a new module and makes it the
current module while the rest of the file is evaluated.  The
@code{define} expressions in that file then add their new definitions to
this current module.

Therefore, all we need to do is to make sure that the right module is
current when calling @code{gh_new_procedure} for our new primitives.
Unfortunately, there is not yet an easy way to access the module system
from C, so we are better off with a more indirect approach.  Instead of
adding our primitives at initialization time we merely register with
Guile that we are ready to provide the contents of a certain module,
should it ever be needed.

@deftypefun void scm_register_module_xxx (char *@var{name}, void (*@var{initfunc})(void))
Register with Guile that @var{initfunc} will provide the contents of the
module @var{name}.

The function @var{initfunc} should perform the usual initialization
actions for your new primitives, like calling @code{gh_new_procedure} or
including the file produced by the snarfer.  When @var{initfunc} is
called, the current module is a newly created module with a name as
indicated by @var{name}.  Each definition that is added to it will be
automatically exported.

The string @var{name} indicates the hierachical name of the new module.
It should consist of the individual components of the module name
separated by single spaces.  That is, the Scheme module name @code{(foo
bar)}, which is a list, should be written as @code{"foo bar"} for the
@var{name} parameter.

You can call @code{scm_register_module_xxx} at any time, even before
Guile has been initialized.  This might be useful when you want to put
the call to it in some initialization code that is magically called
before main, like constructors for global C++ objects.

An example for @code{scm_register_module_xxx} appears in the next section.
@end deftypefun

Now, instead of calling the initialization function at program startup,
you should simply call @code{scm_register_module_xxx} and pass it the
initialization function.  When the named module is later requested by
Scheme code with @code{use-modules} for example, Guile will notice that
it knows how to create this module and will call the initialization
function at the right time in the right context.

@node Dynamic Linking and Compiled Code Modules
@section Dynamic Linking and Compiled Code Modules

The most interesting application of dynamically linked libraries is
probably to use them for providing @emph{compiled code modules} to
Scheme programs.  As much fun as programming in Scheme is, every now and
then comes the need to write some low-level C stuff to make Scheme even
more fun.

Not only can you put these new primitives into their own module (see the
previous section), you can even put them into a shared library that is
only then linked to your running Guile image when it is actually
needed.

An example will hopefully make everything clear.  Suppose we want to
make the Bessel functions of the C library available to Scheme in the
module @samp{(math bessel)}.  First we need to write the appropriate
glue code to convert the arguments and return values of the functions
from Scheme to C and back.  Additionally, we need a function that will
add them to the set of Guile primitives.  Because this is just an
example, we will only implement this for the @code{j0} function, tho.

@smallexample
#include <math.h>
#include <guile/gh.h>

SCM
j0_wrapper (SCM x)
@{
  return gh_double2scm (j0 (gh_scm2double (x)));
@}

void
init_math_bessel ()
@{
  gh_new_procedure1_0 ("j0", j0_wrapper);
@}
@end smallexample

We can already try to bring this into action by manually calling the low
level functions for performing dynamic linking.  The C source file needs
to be compiled into a shared library.  Here is how to do it on
GNU/Linux, please refer to the @code{libtool} documentation for how to
create dynamically linkable libraries portably.

@smallexample
gcc -shared -o libbessel.so -fPIC bessel.c
@end smallexample

Now fire up Guile:

@smalllisp
(define bessel-lib (dynamic-link "./libbessel.so"))
(dynamic-call "init_math_bessel" bessel-lib)
(j0 2)
@result{} 0.223890779141236
@end smalllisp

The filename @file{./libbessel.so} should be pointing to the shared
library produced with the @code{gcc} command above, of course.  The
second line of the Guile interaction will call the
@code{init_math_bessel} function which in turn will register the C
function @code{j0_wrapper} with the Guile interpreter under the name
@code{j0}.  This function becomes immediately available and we can call
it from Scheme.

Fun, isn't it?  But we are only half way there.  This is what
@code{apropos} has to say about @code{j0}:

@smallexample
(apropos 'j0)
@print{} the-root-module: j0     #<primitive-procedure j0>
@end smallexample

As you can see, @code{j0} is contained in the root module, where all
the other Guile primitives like @code{display}, etc live.  In general,
a primitive is put into whatever module is the @dfn{current module} at
the time @code{gh_new_procedure} is called.  To put @code{j0} into its
own module named @samp{(math bessel)}, we need to make a call to
@code{scm_register_module_xxx}.  Additionally, to have Guile perform
the dynamic linking automatically, we need to put @file{libbessel.so}
into a place where Guile can find it.  The call to
@code{scm_register_module_xxx} should be contained in a specially
named @dfn{module init function}.  Guile knows about this special name
and will call that function automatically after having linked in the
shared library.  For our example, we add the following code to
@file{bessel.c}:

@smallexample
void scm_init_math_bessel_module ()
@{
  scm_register_module_xxx ("math bessel", init_math_bessel);
@}
@end smallexample

The general pattern for the name of a module init function is:
@samp{scm_init_}, followed by the name of the module where the
individual hierarchical components are concatenated with underscores,
followed by @samp{_module}.  It should call
@code{scm_register_module_xxx} with the correct module name and the
appropriate initialization function.  When that initialization function
will be called, a newly created module with the right name will be the
@emph{current module} so that all definitions that the initialization
functions makes will end up in the correct module.

After @file{libbessel.so} has been rebuild, we need to place the shared
library into the right place.  When Guile tries to autoload the
@samp{(math bessel)} module, it looks not only for a file called
@file{math/bessel.scm} in its @code{%load-path}, but also for
@file{math/libbessel.so}.  So all we need to do is to create a directory
called @file{math} somewhere in Guile's @code{%load-path} and place
@file{libbessel.so} there.  Normally, the current directory @file{.} is
in the @code{%load-path}, so we just use that for this example.

@smallexample
% mkdir maths
% cd maths
% ln -s ../libbessel.so .
% cd ..
% guile
guile> (use-modules (math bessel))
guile> (j0 2)
0.223890779141236
guile> (apropos 'j0)
@print{} bessel: j0      #<primitive-procedure j0>
@end smallexample

That's it!

Note that we used a symlink to make @file{libbessel.so} appear in the
right spot.  This is probably not a bad idea in general.  The
directories that the @file{%load-path} normally contains are supposed to
contain only architecture independent files.  They are not really the
right place for a shared library.  You might want to install the
libraries somewhere below @samp{exec_prefix} and then symlink to them
from the architecture independent directory.  This will at least work on
heterogenous systems where the architecture dependent stuff resides in
the same place on all machines (which seems like a good idea to me
anyway).



@page
@node Dynamic Wind
@chapter Dynamic Wind

[FIXME: this is pasted in from Tom Lord's original guile.texi and should
be reviewed]

@c ARGFIXME in-guard/thunk1 thunk/thunk2 out-guard/thunk3
@c docstring begin (texi-doc-string "guile" "dynamic-wind")
@deffn primitive dynamic-wind thunk1 thunk2 thunk3
All three arguments must be 0-argument procedures.

@var{in-guard} is called, then @var{thunk}, then @var{out-guard}.

If, any time during the execution of @var{thunk}, the continuation
of the @code{dynamic-wind} expression is escaped non-locally, @var{out-guard}
is called.   If the continuation of the dynamic-wind is re-entered,
@var{in-guard} is called.   Thus @var{in-guard} and @var{out-guard} may
be called any number of times.

@example
(define x 'normal-binding)
@result{} x

(define a-cont  (call-with-current-continuation
		  (lambda (escape)
		     (let ((old-x x))
		       (dynamic-wind
			  ;; in-guard:
			  ;;
			  (lambda () (set! x 'special-binding))

			  ;; thunk
			  ;;
		 	  (lambda () (display x) (newline)
				     (call-with-current-continuation escape)
				     (display x) (newline)
				     x)

			  ;; out-guard:
			  ;;
			  (lambda () (set! x old-x)))))))

;; Prints:
special-binding
;; Evaluates to:
@result{} a-cont

x
@result{} normal-binding

(a-cont #f)
;; Prints:
special-binding
;; Evaluates to:
@result{} a-cont  ;; the value of the (define a-cont...)

x
@result{} normal-binding

a-cont
@result{} special-binding
@end example
@end deffn



@page
@node Threads and Dynamic Roots
@chapter Threads and Dynamic Roots

[FIXME: This is pasted in from Tom Lord's original guile.texi chapter
plus the Cygnus programmer's manual; it should be *very* carefully
reviewed and largely reorganized.]


@menu
* Arbiters::
* Asyncs::
* Dynamic Roots::
* Threads::
* Fluids::
@end menu


@node Arbiters
@section Arbiters

@c docstring begin (texi-doc-string "guile" "make-arbiter")
@deffn primitive make-arbiter name
Returns an object of type arbiter and name name. Its state is initially unlocked.
Arbiters are a way to achieve process synchronization.
@end deffn

@c docstring begin (texi-doc-string "guile" "try-arbiter")
@deffn primitive try-arbiter arb
Returns #t and locks arbiter if arbiter was unlocked. Otherwise, returns #f.
@end deffn

@c docstring begin (texi-doc-string "guile" "release-arbiter")
@deffn primitive release-arbiter arb
Returns #t and unlocks arbiter if arbiter was locked. Otherwise, returns #f.
@end deffn


@node Asyncs
@section Asyncs

@c docstring begin (texi-doc-string "guile" "async")
@deffn primitive async thunk
@end deffn

@c docstring begin (texi-doc-string "guile" "system-async")
@deffn primitive system-async thunk
@end deffn

@c docstring begin (texi-doc-string "guile" "async-mark")
@deffn primitive async-mark a
@end deffn

@c docstring begin (texi-doc-string "guile" "system-async-mark")
@deffn primitive system-async-mark a
@end deffn

@c docstring begin (texi-doc-string "guile" "run-asyncs")
@deffn primitive run-asyncs list_of_a
@end deffn

@c docstring begin (texi-doc-string "guile" "noop")
@deffn primitive noop . args
@end deffn

@c docstring begin (texi-doc-string "guile" "unmask-signals")
@deffn primitive unmask-signals
@end deffn

@c docstring begin (texi-doc-string "guile" "mask-signals")
@deffn primitive mask-signals
@end deffn


@node Dynamic Roots
@section Dynamic Roots
@cindex dynamic roots

A @dfn{dynamic root} is a root frame of Scheme evaluation.
The top-level repl, for example, is an instance of a dynamic root.

Each dynamic root has its own chain of dynamic-wind information.  Each
has its own set of continuations, jump-buffers, and pending CATCH
statements which are inaccessible from the dynamic scope of any
other dynamic root.

In a thread-based system, each thread has its own dynamic root.  Therefore,
continuations created by one thread may not be invoked by another.

Even in a single-threaded system, it is sometimes useful to create a new
dynamic root.  For example, if you want to apply a procedure, but to
not allow that procedure to capture the current continuation, calling
the procedure under a new dynamic root will do the job.

@c docstring begin (texi-doc-string "guile" "call-with-dynamic-root")
@deffn primitive call-with-dynamic-root thunk handler
Evaluate @code{(thunk)} in a new dynamic context, returning its value.

If an error occurs during evaluation, apply @var{handler} to the
arguments to the throw, just as @code{throw} would.  If this happens,
@var{handler} is called outside the scope of the new root -- it is
called in the same dynamic context in which
@code{call-with-dynamic-root} was evaluated.

If @var{thunk} captures a continuation, the continuation is rooted at
the call to @var{thunk}.  In particular, the call to
@code{call-with-dynamic-root} is not captured.  Therefore,
@code{call-with-dynamic-root} always returns at most one time.

Before calling @var{thunk}, the dynamic-wind chain is un-wound back to
the root and a new chain started for @var{thunk}.  Therefore, this call
may not do what you expect:

@example
;; Almost certainly a bug:
(with-output-to-port
 some-port

 (lambda ()
   (call-with-dynamic-root
    (lambda ()
      (display 'fnord)
      (newline))
    (lambda (errcode) errcode))))
@end example

The problem is, on what port will @samp{fnord} be displayed?  You
might expect that because of the @code{with-output-to-port} that
it will be displayed on the port bound to @code{some-port}.  But it
probably won't -- before evaluating the thunk, dynamic winds are
unwound, including those created by @code{with-output-to-port}.
So, the standard output port will have been re-set to its default value
before @code{display} is evaluated.

(This function was added to Guile mostly to help calls to functions in C
libraries that can not tolerate non-local exits or calls that return
multiple times.  If such functions call back to the interpreter, it should
be under a new dynamic root.)
@end deffn


@c docstring begin (texi-doc-string "guile" "dynamic-root")
@deffn primitive dynamic-root
Return an object representing the current dynamic root.

These objects are only useful for comparison using @code{eq?}.
They are currently represented as numbers, but your code should
in no way depend on this.
@end deffn

@c begin (scm-doc-string "boot-9.scm" "quit")
@deffn procedure quit [exit_val]
Throw back to the error handler of the current dynamic root.

If integer @var{exit_val} is specified and if Guile is being used
stand-alone and if quit is called from the initial dynamic-root,
@var{exit_val} becomes the exit status of the Guile process and the
process exits.
@end deffn

When Guile is run interactively, errors are caught from within the
read-eval-print loop.  An error message will be printed and @code{abort}
called.  A default set of signal handlers is installed, e.g., to allow
user interrupt of the interpreter.

It is possible to switch to a "batch mode", in which the interpreter
will terminate after an error and in which all signals cause their
default actions.  Switching to batch mode causes any handlers installed
from Scheme code to be removed.  An example of where this is useful is
after forking a new process intended to run non-interactively.

@c begin (scm-doc-string "boot-9.scm" "batch-mode?")
@deffn procedure batch-mode?
Returns a boolean indicating whether the interpreter is in batch mode.
@end deffn

@c begin (scm-doc-string "boot-9.scm" "set-batch-mode?!")
@deffn procedure set-batch-mode?! arg
If @var{arg} is true, switches the interpreter to batch mode.
The @code{#f} case has not been implemented.
@end deffn

@node Threads
@section Threads
@cindex threads
@cindex Guile threads

@strong{[NOTE: this chapter was written for Cygnus Guile and has not yet
been updated for the Guile 1.x release.]}

Here is a the reference for Guile's threads.  In this chapter I simply
quote verbatim Tom Lord's description of the low-level primitives
written in C (basically an interface to the POSIX threads library) and
Anthony Green's description of the higher-level thread procedures
written in scheme.
@cindex posix threads
@cindex Lord, Tom
@cindex Green, Anthony

When using Guile threads, keep in mind that each guile thread is
executed in a new dynamic root.

@menu
* Low level thread primitives::
* Higher level thread procedures::
@end menu


@node Low level thread primitives
@subsection Low level thread primitives

@c NJFIXME no current mechanism for making sure that these docstrings
@c are in sync.

@c begin (texi-doc-string "guile" "call-with-new-thread")
@deffn primitive call-with-new-thread thunk error-thunk
Evaluate @code{(thunk)} in a new thread, and new dynamic context,
returning a new thread object representing the thread.

If an error occurs during evaluation, call error-thunk, passing it an
error code describing the condition.  [Error codes are currently
meaningless integers.  In the future, real values will be specified.]
If this happens, the error-thunk is called outside the scope of the new
root -- it is called in the same dynamic context in which
with-new-thread was evaluated, but not in the callers thread.

All the evaluation rules for dynamic roots apply to threads.
@end deffn

@c begin (texi-doc-string "guile" "join-thread")
@deffn primitive join-thread thread
Suspend execution of the calling thread until the target @var{thread}
terminates, unless the target @var{thread} has already terminated.
@end deffn

@c begin (texi-doc-string "guile" "yield")
@deffn primitive yield
If one or more threads are waiting to execute, calling yield forces an
immediate context switch to one of them. Otherwise, yield has no effect.
@end deffn

@c begin (texi-doc-string "guile" "make-mutex")
@deffn primitive make-mutex
Create a new mutex object.
@end deffn

@c begin (texi-doc-string "guile" "lock-mutex")
@deffn primitive lock-mutex mutex
Lock @var{mutex}. If the mutex is already locked, the calling thread
blocks until the mutex becomes available. The function returns when
the calling thread owns the lock on @var{mutex}.
@end deffn

@c begin (texi-doc-string "guile" "unlock-mutex")
@deffn primitive unlock-mutex mutex
Unlocks @var{mutex} if the calling thread owns the lock on @var{mutex}.
Calling unlock-mutex on a mutex not owned by the current thread results
in undefined behaviour. Once a mutex has been unlocked, one thread
blocked on @var{mutex} is awakened and grabs the mutex lock.
@end deffn

@c begin (texi-doc-string "guile" "make-condition-variable")
@deffn primitive make-condition-variable
@end deffn

@c begin (texi-doc-string "guile" "wait-condition-variable")
@deffn primitive wait-condition-variable cond-var mutex
@end deffn

@c begin (texi-doc-string "guile" "signal-condition-variable")
@deffn primitive signal-condition-variable cond-var
@end deffn


@node Higher level thread procedures
@subsection Higher level thread procedures

@c NJFIXME the following doc is a repeat of the previous node!

@c begin (texi-doc-string "guile" "call-with-new-thread")
@deffn primitive call-with-new-thread thunk error-thunk
Evaluate @code{(thunk)} in a new thread, and new dynamic context,
returning a new thread object representing the thread.

If an error occurs during evaluation, call error-thunk, passing it an
error code describing the condition.  [Error codes are currently
meaningless integers.  In the future, real values will be specified.]
If this happens, the error-thunk is called outside the scope of the new
root -- it is called in the same dynamic context in which
with-new-thread was evaluated, but not in the callers thread.

All the evaluation rules for dynamic roots apply to threads.
@end deffn

@c begin (texi-doc-string "guile" "join-thread")
@deffn primitive join-thread thread
Suspend execution of the calling thread until the target @var{thread}
terminates, unless the target @var{thread} has already terminated.
@end deffn

@c begin (texi-doc-string "guile" "yield")
@deffn primitive yield
If one or more threads are waiting to execute, calling yield forces an
immediate context switch to one of them. Otherwise, yield has no effect.
@end deffn

@c begin (texi-doc-string "guile" "make-mutex")
@deffn primitive make-mutex
Create a new mutex object.
@end deffn

@c begin (texi-doc-string "guile" "lock-mutex")
@deffn primitive lock-mutex mutex
Lock @var{mutex}. If the mutex is already locked, the calling thread
blocks until the mutex becomes available. The function returns when
the calling thread owns the lock on @var{mutex}.
@end deffn

@c docstring begin (texi-doc-string "guile" "unlock-mutex")
@deffn primitive unlock-mutex mutex
Unlocks @var{mutex} if the calling thread owns the lock on @var{mutex}.
Calling unlock-mutex on a mutex not owned by the current thread results
in undefined behaviour. Once a mutex has been unlocked, one thread
blocked on @var{mutex} is awakened and grabs the mutex lock.
@end deffn


@node Fluids
@section Fluids

@c docstring begin (texi-doc-string "guile" "make-fluid")
@deffn primitive make-fluid
Return a newly created fluid.
Fluids are objects of a certain type (a smob) that can hold one SCM
value per dynamic root.  That is, modifications to this value are
only visible to code that executes within the same dynamic root as
the modifying code.  When a new dynamic root is constructed, it
inherits the values from its parent.  Because each thread executes
in its own dynamic root, you can use fluids for thread local storage.
@end deffn

@c docstring begin (texi-doc-string "guile" "fluid?")
@deffn primitive fluid? obj
Return #t iff @var{obj} is a fluid; otherwise, return #f.
@end deffn

@c docstring begin (texi-doc-string "guile" "fluid-ref")
@deffn primitive fluid-ref fluid
Return the value associated with @var{fluid} in the current dynamic root.
If @var{fluid} has not been set, then this returns #f.
@end deffn

@c docstring begin (texi-doc-string "guile" "fluid-set!")
@deffn primitive fluid-set! fluid value
Set the value associated with @var{fluid} in the current dynamic root.
@end deffn

@c docstring begin (texi-doc-string "guile" "with-fluids*")
@deffn primitive with-fluids* fluids values thunk
Set @var{fluids} to @var{values} temporary, and call @var{thunk}.
@var{fluids} must be a list of fluids and @var{values} must be the same
number of their values to be applied.  Each substitution is done
one after another.  @var{thunk} must be a procedure with no argument.
@end deffn


@page
@node Weak References
@chapter Weak References

[FIXME: This chapter is based on Mikael Djurfeldt's answer to a question
by Michael Livshin. Any mistakes are not theirs, of course. ]

Weak references let you attach bookkeeping information to data so that
the additional information automatically disappears when the original
data is no longer in use and gets garbage collected. In a weak key hash,
the hash entry for that key disappears as soon as the key is no longer
referneced from anywhere else. For weak value hashes, the same happens
as soon as the value is no longer in use. Entries in a doubly weak hash
disappear when either the key or the value are not used anywhere else
anymore.

Property lists offer the same kind of functionality as weak key hashes
in many situations. (@pxref{Property Lists})

Here's an example (a little bit strained perhaps, but one of the
examples is actually used in Guile):

Assume that you're implementing a debugging system where you want to
associate information about filename and position of source code
expressions with the expressions themselves.

Hashtables can be used for that, but if you use ordinary hash tables
it will be impossible for the scheme interpreter to "forget" old
source when, for example, a file is reloaded.

To implement the mapping from source code expressions to positional
information it is necessary to use weak-key tables since we don't want
the expressions to be remembered just because they are in our table.

To implement a mapping from source file line numbers to source code
expressions you would use a weak-value table.

To implement a mapping from source code expressions to the procedures
they constitute a doubly-weak table has to be used.

@menu
* Weak key hashes::
* Weak vectors::
@end menu


@node Weak key hashes
@section Weak key hashes

@c ARGFIXME k/size
@c docstring begin (texi-doc-string "guile" "make-weak-key-hash-table")
@deffn primitive make-weak-key-hash-table k
@deffnx primitive make-weak-value-hash-table size
@deffnx primitive make-doubly-weak-hash-table size
Return a weak hash table with @var{size} buckets. As with any hash
table, choosing a good size for the table requires some caution.

You can modify weak hash tables in exactly the same way you would modify
regular hash tables. (@pxref{Hash Tables})
@end deffn

@c ARGFIXME x/obj
@c docstring begin (texi-doc-string "guile" "weak-key-hash-table?")
@deffn primitive weak-key-hash-table? x
@deffnx primitive weak-value-hash-table? obj
@deffnx primitive doubly-weak-hash-table? obj
Return @var{#t} if @var{obj} is the specified weak hash table. Note
that a doubly weak hash table is neither a weak key nor a weak value
hash table.
@end deffn

@c docstring begin (texi-doc-string "guile" "make-weak-value-hash-table")
@deffn primitive make-weak-value-hash-table k
@end deffn

@c docstring begin (texi-doc-string "guile" "weak-value-hash-table?")
@deffn primitive weak-value-hash-table? x
@end deffn

@c docstring begin (texi-doc-string "guile" "make-doubly-weak-hash-table")
@deffn primitive make-doubly-weak-hash-table k
@end deffn

@c docstring begin (texi-doc-string "guile" "doubly-weak-hash-table?")
@deffn primitive doubly-weak-hash-table? x
@end deffn


@node Weak vectors
@section Weak vectors

Weak vectors are mainly useful in Guile's implementation of weak hash
tables.

@c ARGFIXME k/size
@c docstring begin (texi-doc-string "guile" "make-weak-vector")
@deffn primitive make-weak-vector k [fill]
Return a weak vector with @var{size} elements. If the optional
argument @var{fill} is given, all entries in the vector will be set to
@var{fill}. The default value for @var{fill} is the empty list.
@end deffn

@c NJFIXME should vector->list here be list->vector ?
@c docstring begin (texi-doc-string "guile" "weak-vector")
@deffn primitive weak-vector . l
@deffnx primitive list->weak-vector l
Construct a weak vector from a list: @code{weak-vector} uses the list of
its arguments while @code{list->weak-vector} uses its only argument
@var{l} (a list) to construct a weak vector the same way
@code{vector->list} would.
@end deffn

@c ARGFIXME x/obj
@c docstring begin (texi-doc-string "guile" "weak-vector?")
@deffn primitive weak-vector? x
Return @var{#t} if @var{obj} is a weak vector. Note that all weak
hashes are also weak vectors.
@end deffn


@page
@node Objects
@chapter Objects

@c docstring begin (texi-doc-string "guile" "entity?")
@deffn primitive entity? obj
@end deffn

@c docstring begin (texi-doc-string "guile" "operator?")
@deffn primitive operator? obj
@end deffn

@c docstring begin (texi-doc-string "guile" "set-object-procedure!")
@deffn primitive set-object-procedure! obj proc
@end deffn

@c docstring begin (texi-doc-string "guile" "make-class-object")
@deffn primitive make-class-object metaclass layout
@end deffn

@c docstring begin (texi-doc-string "guile" "make-subclass-object")
@deffn primitive make-subclass-object class layout
@end deffn


@page
@node Guardians
@chapter Guardians

@c docstring begin (texi-doc-string "guile" "make-guardian")
@deffn primitive make-guardian
Create a new guardian.
A guardian protects a set of objects from garbage collection,
allowing a program to apply cleanup or other actions.

make-guardian returns a procedure representing the guardian.
Calling the guardian procedure with an argument adds the
argument to the guardian's set of protected objects.
Calling the guardian procedure without an argument returns
one of the protected objects which are ready for garbage
collection or @code{#f} if no such object is available.
Objects which are returned in this way are removed from
the guardian.

See R. Kent Dybvig, Carl Bruggeman, and David Eby (1993)
"Guardians in a Generation-Based Garbage Collector".
ACM SIGPLAN Conference on Programming Language Design
and Implementation, June 1993.
@end deffn


@page
@node Emacs Lisp Support
@chapter Emacs Lisp Support

@c docstring begin (texi-doc-string "guile" "nil-car")
@deffn primitive nil-car x
@end deffn

@c docstring begin (texi-doc-string "guile" "nil-cdr")
@deffn primitive nil-cdr x
@end deffn

@c docstring begin (texi-doc-string "guile" "nil-cons")
@deffn primitive nil-cons x y
@end deffn

@c docstring begin (texi-doc-string "guile" "nil-eq")
@deffn primitive nil-eq x y
@end deffn

@c docstring begin (texi-doc-string "guile" "null")
@deffn primitive null x
@end deffn


@page
@node Symbols and Variables
@chapter Symbols and Variables

@c docstring begin (texi-doc-string "guile" "builtin-bindings")
@deffn primitive builtin-bindings
Create and return a copy of the global symbol table, removing all
unbound symbols.
@end deffn

@c docstring begin (texi-doc-string "guile" "builtin-weak-bindings")
@deffn primitive builtin-weak-bindings
@end deffn

@c docstring begin (texi-doc-string "guile" "gensym")
@deffn primitive gensym [prefix]
Create a new symbol with name constructed from a prefix and a counter value.
The string PREFIX can be specified as an optional argument.
Default prefix is @code{g}.  The counter is increased by 1 at each call.
There is no provision for resetting the counter.
@end deffn

@c docstring begin (texi-doc-string "guile" "gentemp")
@deffn primitive gentemp [prefix [obarray]]
Create a new symbol with a name unique in an obarray.
The name is constructed from an optional string PREFIX and a counter
value.  The default prefix is @var{t}.  The OBARRAY is specified as a
second optional argument.  Default is the system obarray where all
normal symbols are interned.  The counter is increased by 1 at each
call.  There is no provision for resetting the counter.
@end deffn

@c docstring begin (texi-doc-string "guile" "intern-symbol")
@deffn primitive intern-symbol o s
Add a new symbol to @var{obarray} with name @var{string}, bound to an
unspecified initial value.  The symbol table is not modified if a symbol
with this name is already present.
@end deffn

@c docstring begin (texi-doc-string "guile" "string->obarray-symbol")
@deffn primitive string->obarray-symbol o s [softp]
Intern a new symbol in @var{obarray}, a symbol table, with name
@var{string}.

If @var{obarray} is @code{#f}, use the default system symbol table.  If
@var{obarray} is @code{#t}, the symbol should not be interned in any
symbol table; merely return the pair (@var{symbol}
. @var{#<undefined>}).

The @var{soft?} argument determines whether new symbol table entries
should be created when the specified symbol is not already present in
@var{obarray}.  If @var{soft?} is specified and is a true value, then
new entries should not be added for symbols not already present in the
table; instead, simply return @code{#f}.
@end deffn

@c docstring begin (texi-doc-string "guile" "string->symbol")
@deffn primitive string->symbol s
Returns the symbol whose name is @var{string}.  This procedure can
create symbols with names containing special characters or letters in
the non-standard case, but it is usually a bad idea to create such
symbols because in some implementations of Scheme they cannot be read as
themselves.  See @samp{symbol->string}.

The following examples assume that the implementation's standard case is
lower case:

@format
@t{(eq? 'mISSISSIppi 'mississippi)
          ==>  #t
(string->symbol "mISSISSIppi")
          ==>
  @r{}the symbol with name "mISSISSIppi"
(eq? 'bitBlt (string->symbol "bitBlt"))
          ==>  #f
(eq? 'JollyWog
     (string->symbol
       (symbol->string 'JollyWog)))
          ==>  #t
(string=? "K. Harper, M.D."
          (symbol->string
            (string->symbol "K. Harper, M.D.")))
          ==>  #t
}
@end format
@end deffn

@c docstring begin (texi-doc-string "guile" "symbol->string")
@deffn primitive symbol->string s
Returns the name of @var{symbol} as a string.  If the symbol was part of
an object returned as the value of a literal expression (section
@pxref{Literal expressions,,,r4rs, The Revised^4 Report on Scheme}) or
by a call to the @samp{read} procedure, and its name contains alphabetic
characters, then the string returned will contain characters in the
implementation's preferred standard case---some implementations will
prefer upper case, others lower case.  If the symbol was returned by
@samp{string->symbol}, the case of characters in the string returned
will be the same as the case in the string that was passed to
@samp{string->symbol}.  It is an error to apply mutation procedures like
@code{string-set!} to strings returned by this procedure. (r5rs)

The following examples assume that the implementation's standard case is
lower case:

@format
@t{(symbol->string 'flying-fish)
                                ==>  "flying-fish"
(symbol->string 'Martin)               ==>  "martin"
(symbol->string
   (string->symbol "Malvina"))
                           ==>  "Malvina"
}
@end format
@end deffn

@c docstring begin (texi-doc-string "guile" "symbol-binding")
@deffn primitive symbol-binding o s
Look up in @var{obarray} the symbol whose name is @var{string}, and
return the value to which it is bound.  If @var{obarray} is @code{#f},
use the global symbol table.  If @var{string} is not interned in
@var{obarray}, an error is signalled.
@end deffn

@c docstring begin (texi-doc-string "guile" "symbol-bound?")
@deffn primitive symbol-bound? o s
Return @var{#t} if @var{obarray} contains a symbol with name
@var{string} bound to a defined value.  This differs from
@var{symbol-bound?} in that the mere mention of a symbol usually causes
it to be interned; @code{symbol-bound?} determines whether a symbol has
been given any meaningful value.
@end deffn

@c docstring begin (texi-doc-string "guile" "symbol-fref")
@deffn primitive symbol-fref s
Return the contents of @var{symbol}'s @dfn{function slot}.
@end deffn

@c docstring begin (texi-doc-string "guile" "symbol-fset!")
@deffn primitive symbol-fset! s val
Change the binding of @var{symbol}'s function slot.
@end deffn

@c docstring begin (texi-doc-string "guile" "symbol-hash")
@deffn primitive symbol-hash symbol
Return a hash value for @var{symbol}.
@end deffn

@c docstring begin (texi-doc-string "guile" "symbol-interned?")
@deffn primitive symbol-interned? o s
Return @var{#t} if @var{obarray} contains a symbol with name
@var{string}, and @var{#f} otherwise.
@end deffn

@c docstring begin (texi-doc-string "guile" "symbol-pref")
@deffn primitive symbol-pref s
Return the @dfn{property list} currently associated with @var{symbol}.
@end deffn

@c docstring begin (texi-doc-string "guile" "symbol-pset!")
@deffn primitive symbol-pset! s val
Change the binding of @var{symbol}'s property slot.
@end deffn

@c docstring begin (texi-doc-string "guile" "symbol-set!")
@deffn primitive symbol-set! o s v
Find the symbol in @var{obarray} whose name is @var{string}, and rebind
it to @var{value}.  An error is signalled if @var{string} is not present
in @var{obarray}.
@end deffn

@c docstring begin (texi-doc-string "guile" "symbol?")
@deffn primitive symbol? obj
Returns @t{#t} if @var{obj} is a symbol, otherwise returns @t{#f}. (r5rs)
@end deffn

@c docstring begin (texi-doc-string "guile" "unintern-symbol")
@deffn primitive unintern-symbol o s
Remove the symbol with name @var{string} from @var{obarray}.  This
function returns @code{#t} if the symbol was present and @code{#f}
otherwise.
@end deffn

@c docstring begin (texi-doc-string "guile" "builtin-variable")
@deffn primitive builtin-variable name
Return the built-in variable with the name NAME.
NAME must be a symbol (not a string).
Then use `variable-ref' to access its value.
@end deffn

@c docstring begin (texi-doc-string "guile" "make-undefined-variable")
@deffn primitive make-undefined-variable [name_hint]
Return a variable object initialized to an undefined value.
If given, uses NAME-HINT as its internal (debugging)
name, otherwise just treat it as an anonymous variable.
Remember, of course, that multiple bindings to the same
variable may exist, so NAME-HINT is just that---a hint.
@end deffn

@c docstring begin (texi-doc-string "guile" "make-variable")
@deffn primitive make-variable init [name_hint]
Return a variable object initialized to value INIT.
If given, uses NAME-HINT as its internal (debugging)
name, otherwise just treat it as an anonymous variable.
Remember, of course, that multiple bindings to the same
variable may exist, so NAME-HINT is just that---a hint.
@end deffn

@c docstring begin (texi-doc-string "guile" "variable-bound?")
@deffn primitive variable-bound? var
Return #t iff VAR is bound to a value.
Throws an error if VAR is not a variable object.
@end deffn

@c docstring begin (texi-doc-string "guile" "variable-ref")
@deffn primitive variable-ref var
Dereference VAR and return its value.
VAR must be a variable object;  see `make-variable' and
`make-undefined-variable'
@end deffn

@c docstring begin (texi-doc-string "guile" "variable-set!")
@deffn primitive variable-set! var val
Set the value of the variable VAR to VAL.
VAR must be a variable object, VAL can be any value.
Returns an unspecified value.
@end deffn

@c docstring begin (texi-doc-string "guile" "variable?")
@deffn primitive variable? obj
Return #t iff OBJ is a variable object, else return #f
@end deffn


@page
@node Garbage Collection
@chapter Garbage Collection

[FIXME: this is pasted in from Tom Lord's original guile.texi and should
be reviewed]

@c docstring begin (texi-doc-string "guile" "gc")
@deffn primitive gc
Scans all of SCM objects and reclaims for further use those that are
no longer accessible.
@end deffn

@c docstring begin (texi-doc-string "guile" "gc-stats")
@deffn primitive gc-stats
Returns an association list of statistics about Guile's current use of storage.
@end deffn

@c docstring begin (texi-doc-string "guile" "object-address")
@deffn primitive object-address obj
Return an integer that for the lifetime of @var{obj} is uniquely
returned by this function for @var{obj}
@end deffn

@c docstring begin (texi-doc-string "guile" "unhash-name")
@deffn primitive unhash-name name
@end deffn


@page
@node Configuration Data
@chapter Configuration Data

It is often useful to have site-specific information about the current
Guile installation.  This chapter describes how to find out about
Guile's configuration at run time.

@c docstring begin (texi-doc-string "guile" "version")
@deffn primitive version
@deffnx primitive major-version
@deffnx primitive minor-version
Return a string describing Guile's version number, or its major or minor
version numbers, respectively.

@example
(version) @result{} "1.3a"
(major-version) @result{} "1"
(minor-version) @result{} "3a"
@end example
@end deffn

@c NJFIXME not in libguile!
@deffn primitive libguile-config-stamp
Return a string describing the date on which @code{libguile} was
configured.  This is used to determine whether the Guile core
interpreter and the ice-9 runtime have grown out of date with one
another.
@end deffn

@c docstring begin (texi-doc-string "guile" "%package-data-dir")
@deffn primitive %package-data-dir
Return the name of the directory where Scheme packages, modules and
libraries are kept.  On most Unix systems, this will be
@samp{/usr/local/share/guile}.
@end deffn

@c docstring begin (texi-doc-string "guile" "%library-dir")
@deffn primitive %library-dir
Return the directory where the Guile Scheme library files are installed.
E.g., may return "/usr/share/guile/1.3.5".
@end deffn

@c docstring begin (texi-doc-string "guile" "%site-dir")
@deffn primitive %site-dir
Return the directory where the Guile site files are installed.
E.g., may return "/usr/share/guile/site".
@end deffn

@c docstring begin (texi-doc-string "guile" "parse-path")
@deffn primitive parse-path path [tail]
@end deffn

@c docstring begin (texi-doc-string "guile" "search-path")
@deffn primitive search-path path filename [extensions]
@end deffn

@defvar %load-path
Return the list of directories which should be searched for Scheme
modules and libraries.
@end defvar

@page
@node Internal Debugging Interface
@chapter Internal Debugging Interface

--- The name of this chapter needs to clearly distinguish it
    from the appendix describing the debugger UI.  The intro
    should have a pointer to the UI appendix.

@c docstring begin (texi-doc-string "guile" "display-error")
@deffn primitive display-error stack port subr message args rest
@end deffn

@c docstring begin (texi-doc-string "guile" "display-application")
@deffn primitive display-application frame [port [indent]]
@end deffn

@c docstring begin (texi-doc-string "guile" "display-backtrace")
@deffn primitive display-backtrace stack port [first [depth]]
@end deffn

@c docstring begin (texi-doc-string "guile" "backtrace")
@deffn primitive backtrace
@end deffn

@c docstring begin (texi-doc-string "guile" "malloc-stats")
@deffn primitive malloc-stats
Return an alist ((WHAT . N) ...) describing number of malloced objects.
WHAT is the second argument to scm_must_malloc, N is the number of objects
of that type currently allocated.
@end deffn

@c docstring begin (texi-doc-string "guile" "debug-options-interface")
@deffn primitive debug-options-interface [setting]
@end deffn

@c docstring begin (texi-doc-string "guile" "with-traps")
@deffn primitive with-traps thunk
@end deffn

@c docstring begin (texi-doc-string "guile" "memoized?")
@deffn primitive memoized? obj
@end deffn

@c docstring begin (texi-doc-string "guile" "unmemoize")
@deffn primitive unmemoize m
@end deffn

@c docstring begin (texi-doc-string "guile" "memoized-environment")
@deffn primitive memoized-environment m
@end deffn

@c docstring begin (texi-doc-string "guile" "procedure-name")
@deffn primitive procedure-name proc
@end deffn

@c docstring begin (texi-doc-string "guile" "procedure-source")
@deffn primitive procedure-source proc
@end deffn

@c docstring begin (texi-doc-string "guile" "procedure-environment")
@deffn primitive procedure-environment proc
@end deffn

@c docstring begin (texi-doc-string "guile" "debug-object?")
@deffn primitive debug-object? obj
@end deffn

@c docstring begin (texi-doc-string "guile" "frame-arguments")
@deffn primitive frame-arguments frame
@end deffn

@c docstring begin (texi-doc-string "guile" "frame-evaluating-args?")
@deffn primitive frame-evaluating-args? frame
@end deffn

@c docstring begin (texi-doc-string "guile" "frame-next")
@deffn primitive frame-next frame
@end deffn

@c docstring begin (texi-doc-string "guile" "frame-number")
@deffn primitive frame-number frame
@end deffn

@c docstring begin (texi-doc-string "guile" "frame-overflow?")
@deffn primitive frame-overflow? frame
@end deffn

@c docstring begin (texi-doc-string "guile" "frame-previous")
@deffn primitive frame-previous frame
@end deffn

@c docstring begin (texi-doc-string "guile" "frame-procedure")
@deffn primitive frame-procedure frame
@end deffn

@c docstring begin (texi-doc-string "guile" "frame-procedure?")
@deffn primitive frame-procedure? frame
@end deffn

@c docstring begin (texi-doc-string "guile" "frame-real?")
@deffn primitive frame-real? frame
@end deffn

@c docstring begin (texi-doc-string "guile" "frame-source")
@deffn primitive frame-source frame
@end deffn

@c docstring begin (texi-doc-string "guile" "frame?")
@deffn primitive frame? obj
@end deffn

@c docstring begin (texi-doc-string "guile" "last-stack-frame")
@deffn primitive last-stack-frame obj
@end deffn

@c docstring begin (texi-doc-string "guile" "make-stack")
@deffn primitive make-stack obj . args
@end deffn

@c docstring begin (texi-doc-string "guile" "stack-id")
@deffn primitive stack-id stack
Return the identifier given to @var{stack} by @code{start-stack}.
@end deffn

@c docstring begin (texi-doc-string "guile" "stack-length")
@deffn primitive stack-length stack
@end deffn

@c docstring begin (texi-doc-string "guile" "stack-ref")
@deffn primitive stack-ref stack i
@end deffn

@c docstring begin (texi-doc-string "guile" "stack?")
@deffn primitive stack? obj
Return @code{#t} if @var{obj} is a calling stack.
@end deffn


@page
@node SLIB
@chapter SLIB

Before the the SLIB facilities can be used, the following Scheme
expression must be executed:

@smalllisp
(use-modules (ice-9 slib))
@end smalllisp

@code{require} can then be used as described in
@ref{Top, , SLIB, slib, The SLIB Manual}.

For example:

@smalllisp
guile> (use-modules (ice-9 slib))
guile> (require 'primes)
guile> (probably-prime? 13)
@end smalllisp

@menu
* SLIB installation::
* JACAL::
@end menu

@node SLIB installation
@section SLIB installation

The following seems to work, at least with slib 2c7:

@enumerate
@item
Unpack slib somewhere, e.g., /usr/local/lib/slib.

@item
Create a symlink in the Guile site directory to slib, e.g.,:

@example
ln -s /usr/local/lib/slib /usr/local/share/guile/site/slib
@end example

@item
Use Guile to create the catalogue file, e.g.,:

@example
# guile
guile> (use-modules (ice-9 slib))
guile> (load "/usr/local/lib/slib/mklibcat.scm")
guile> (quit)
@end example

The catalogue data should now be in
@code{/usr/local/share/guile/site/slibcat}.

If instead you get an error such as:

@example
Unbound variable: scheme-implementation-type
@end example

then a solution is to get a newer version of Guile,
or to modify ice-9/slib.scm to use define-public for the
offending variables.

@item
Install the documentation:

@example
cd /usr/local/lib/slib
rm /usr/local/info/slib.info*
cp slib.info /usr/local/info
install-info slib.info /usr/local/info/dir
@end example
@end enumerate

@node JACAL
@section JACAL

@cindex Jaffer, Aubrey
@cindex symbolic math
@cindex math -- symbolic
Jacal is a symbolic math package written in Scheme by Aubrey Jaffer.  It
is usually installed as an extra package in SLIB (@pxref{Packages not
shipped with Guile}).

You can use Guile's interface to SLIB to invoke Jacal:

@smalllisp
(use-modules (ice-9 slib))
(slib:load "math")
(math)
@end smalllisp

@noindent
For complete documentation on Jacal, please read the Jacal manual.  If
it has been installed on line, you can look at @ref{Top, , Jacal, jacal,
The SLIB Manual}.  Otherwise you can find it on the web at
@url{http://www-swiss.ai.mit.edu/~jaffer/JACAL.html}

@c Local Variables:
@c TeX-master: "guile.texi"
@c End:
