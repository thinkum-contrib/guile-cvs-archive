@node R4RS Scheme as a starting point
@chapter R4RS Scheme as a starting point





with
enhancements to support 


an extended version of the Scheme programming language,
as defined in the @cite{Revised^4 Report on the Algorithmic Language
Scheme}, or @dfn{R4RS}.  In addition to the features described in R4RS,
Guile provides the following enhancements:

@table @asis

@item system call access
Guile provides full access to the POSIX system calls.

@item scripting support
To help you write scripts in Scheme, Guile adopts some minor
modifications to the Scheme syntax.  

@end table

That specification is freely available via the
Internet; to get a copy, see @ref{Obtaining and Installing Guile}.



Guile also provides the following extensions to
R4RS:

@table @asis

@item Unix support

@end table


, with many extensions.


To get a copy of @xref{Obtaining and Installing Guile}, 




[FIXME: this is babbling to fill it somewhat; should be reviewed]

The current ``standard'' for the Scheme language is the
@strong{Revised^4 Report on the Algorithmic Language Scheme}
(@cite{r4rs}), and it is commonly referred to as R4RS.  Most Scheme
implementations conform to all the required features in R4RS as well as
the optional ones.

But most Scheme implementations go beyond R4RS in some ways, mostly
because R4RS does not give specifications (or even recommendations)
regarding some issues that are quite important in practical programming.

[FIXME: hmm; what else goes in this chapter?  we have chapters for just
about everything.  I'll put a reference to R4RS and leave it.]

The Scheme language implemented in Guile is R4RS compliant, so R4RS is a
valid document describing the basic Guile language.  This part of the
Guile Reference Manual describes the extensions to Scheme provided in
Guile.


@page
@node Block comments and interpreter triggers
@chapter Block comments and interpreter triggers

Guile provides the block comment tokens @code{#!} and @code{!#} to
mark off a block of text that may span several lines.

@example
#! This is an example of a multi-line comment in Guile
   Scheme.  The Guile lexer ignores everything between
   the opening and closing comment tokens, just as if
   each line began with a semicolon.
!#
@end example

Note that the closing @code{!#} token must appear on a line by
itself.  Even excess whitespace on the closing line will cause the
closing token to be ignored.

The @code{#!} block comment is the same as the @code{#!} token
used in Unix to denote an executable shell script.  This is not
entirely accidental; the choice of @code{#!} and @code{!#} tokens
to mark block comments was made in order to facilitate the use of
Guile in writing scripts.  As a result, it is important to follow
the block comment syntax when writing a shell script in Guile;
@xref{Invoking Guile}.

@page
@node Symbol case
@chapter Symbol case


@page
@node Keywords
@chapter Keywords

[FIXME: in state of flux right now]


@page
@node Exceptions
@chapter Exceptions

@page
@node Modules
@chapter Modules
@cindex modules

[FIXME: somewhat babbling; shoudl be reviewed by someone who understands
modules, once the new module system is in place]

When programs become large, naming conflicts can occur when a function
or global variable defined in one file has the same name as a function
or global variable in another file.  Even just a @emph{similarity}
between function names can cause hard-to-find bugs, since a programmer
might type the wrong function name.

The approach used to tackle this problem is called @emph{information
encapsulation}, which consists of packaging functional units into a
given name space that is clearly separated from other name spaces.
@cindex encapsulation
@cindex information encapsulation
@cindex name space

The language features that allow this are usually called @emph{the
module system} because programs are broken up into modules that are
compiled separately (or loaded separately in an interpreter).

Older languages, like C, have limited support for name space
manipulation and protection.  In C a variable or function is public by
default, and can be made local to a module with the @code{static}
keyword.  But you cannot reference public variables and functions from
another module with different names.

More advanced module systems have become a common feature in recently
designed languages: ML, Python, Perl, and Modula 3 all allow the
@emph{renaming} of objects from a foreign module, so they will not
clutter the global name space.
@cindex name space - private

@menu
* Scheme and modules::          
* The Guile module system::     
@end menu

@node Scheme and modules
@section Scheme and modules

Scheme, as defined in R4RS, does @emph{not} have a module system at all.

Aubrey Jaffer, mostly to support his portable Scheme library SLIB,
implemented a provide/require mechanism for many Scheme implementations.
Library files in SLIB @emph{provide} a feature, and when user programs
@emph{require} that feature, the library file is loaded in.

For example, the file @file{random.scm} in the SLIB package contains the
line
@smalllisp
(provide 'random)
@end smalllisp
so to use its procedures, a user would type
@smalllisp
(require 'random)
@end smalllisp
and they would magically become available, @emph{but still have the same
names!}  So this method is nice, but not as good as a full-featured
module system.

@node The Guile module system
@section The Guile module system

In 1996 Tom Lord implemented a full-featured module system for Guile
which allows loading Scheme source files into private name space.

This module system is regarded as being rather idiosyncratic, and will
probably change to something more like the ML module system, so for now
I will simply descrive how it works for a couple of simple cases.

First of all, the Guile module system sets up a hierarchical name space,
and that name space can be represented like Unix pathnames preceded by a
@key{#} character.  The root name space for all Guile-supplied modules
is called @code{ice-9}.

So for example, the SLIB interface, contained in
@file{$srcdir/ice-9/slib.scm}, starts out with
@smalllisp
(define-module #/ice-9/slib)
@end smalllisp
and the user program can use
@smalllisp
(define-module (guile) :use-module (ice-9 slib))
@end smalllisp

This [FIXME: must say more, and explain, and also demonstrate a private
name space use, and demonstrate how one would do Python's "from Tkinter
import *" versus "import Tkinter"]



@page
@node Exception Handling
@chapter Exception Handling
@cindex Exceptions
@cindex Error Handling

[FIXME: pasted in from Cygnus Guile docs; should be reviewed]

@defun catch key thunk handler
Invoke @var{thunk} in the dynamic context of @var{handler} for
exceptions matching @var{key}.  If thunk throws to the symbol @var{key},
then @var{handler} is invoked this way:

@example
(handler key args ...)
@end example

@var{key} may be a symbol.  In that case, @var{thunk} takes no
arguments.  If @var{thunk} returns normally, that is the return value of
@code{catch}.

Handler is invoked outside the scope of its own @code{catch}.  If
@var{handler} again throws to the same key, a new handler from further
up the call chain is invoked.

If the key is @code{#t}, then a throw to @emph{any} symbol will match
this call to @code{catch}.

Key may also be the value @code{#f}.  In that case, @var{thunk} takes
one argument which will be passed a @dfn{jump buffer object}.  A jump
buffer object may be used as the key argument to @code{throw} to throw
to a specific @code{catch} without an intervening search for a symbolic
key.
@end defun

@defun throw key &rest args ...
Invoke the catch form matching @var{key}, passing @var{args} to the
@var{handler}.  

If the key is a symbol it will match catches of the same
symbol or of #t.

If there is no handler at all, an error is signaled.
@end defun

@defun error msg args ...
Raise an error with key @code{misc-error} and a message constructed by
displaying @var{msg} and writing @var{args}.
@end defun

@defmac false-if-exception expr
Returns the result of evaluating its argument; however
if an exception occurs then @code{#f} is returned instead.
@end defmac

It is traditional in Scheme to implement exception systems using
@code{call-with-current-continuation}, but his has not been done, for
performance reasons.  The implementation of
@code{call-with-current-continuation} is a stack copying implementation.
This allows it to interact well with ordinary C code.  Unfortunately, a
stack-copying implementation can be slow -- creating a new continuation
involves a block copy of the stack.

Instead of using @code{call-with-current-continuation}, the exception
primitives are implemented as built-ins that take advantage of the
@emph{upward only} nature of exceptions.




@page
@node Dynamic Wind
@chapter Dynamic Wind

[FIXME: this is pasted in from Tom Lord's original guile.texi and should
be reviewed]

@defun dynamic-wind in-guard thunk out-guard
All three arguments must be 0-argument procedures.

@var{in-guard} is called, then @var{thunk}, then @var{out-guard}.

If, any time during the execution of @var{thunk}, the continuation
of the @code{dynamic-wind} expression is escaped non-locally, @var{out-guard}
is called.   If the continuation of the dynamic-wind is re-entered,
@var{in-guard} is called.   Thus @var{in-guard} and @var{out-guard} may
be called any number of times.

@example
(define x 'normal-binding)
@result{} x

(define a-cont  (call-with-current-continuation 
		  (lambda (escape)
		     (let ((old-x x))
		       (dynamic-wind
			  ;; in-guard:
			  ;;
			  (lambda () (set! x 'special-binding))

			  ;; thunk
			  ;;
		 	  (lambda () (display x) (newline)
				     (call-with-current-continuation escape)
				     (display x) (newline)
				     x)

			  ;; out-guard:
			  ;;
			  (lambda () (set! x old-x)))))))

;; Prints: 
special-binding
;; Evaluates to:
@result{} a-cont

x
@result{} normal-binding

(a-cont #f)
;; Prints:
special-binding
;; Evaluates to:
@result{} a-cont  ;; the value of the (define a-cont...)

x
@result{} normal-binding

a-cont
@result{} special-binding
@end example

@end defun



@page
@node Records
@chapter Records

[FIXME: this is pasted in from Tom Lord's original guile.texi and should
be reviewed]

A @dfn{record type} is a first class object representing a user-defined
data type.  A @dfn{record} is an instance of a record type.

@defun record? obj
Returns @code{#t} if @var{obj} is a record of any type and @code{#f}
otherwise.

Note that @code{record?} may be true of any Scheme value; there is no
promise that records are disjoint with other Scheme types.
@end defun

@defun make-record-type type-name field-names
Returns a @dfn{record-type descriptor}, a value representing a new data
type disjoint from all others.  The @var{type-name} argument must be a
string, but is only used for debugging purposes (such as the printed
representation of a record of the new type).  The @var{field-names}
argument is a list of symbols naming the @dfn{fields} of a record of the
new type.  It is an error if the list contains any duplicates.  It is
unspecified how record-type descriptors are represented.@refill
@end defun

@defun record-constructor rtd [field-names]
Returns a procedure for constructing new members of the type represented
by @var{rtd}.  The returned procedure accepts exactly as many arguments
as there are symbols in the given list, @var{field-names}; these are
used, in order, as the initial values of those fields in a new record,
which is returned by the constructor procedure.  The values of any
fields not named in that list are unspecified.  The @var{field-names}
argument defaults to the list of field names in the call to
@code{make-record-type} that created the type represented by @var{rtd};
if the @var{field-names} argument is provided, it is an error if it
contains any duplicates or any symbols not in the default list.@refill
@end defun

@defun record-predicate rtd
Returns a procedure for testing membership in the type represented by
@var{rtd}.  The returned procedure accepts exactly one argument and
returns a true value if the argument is a member of the indicated record
type; it returns a false value otherwise.@refill
@end defun

@defun record-accessor rtd field-name
Returns a procedure for reading the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly one argument which must be a record of the appropriate
type; it returns the current value of the field named by the symbol
@var{field-name} in that record.  The symbol @var{field-name} must be a
member of the list of field-names in the call to @code{make-record-type}
that created the type represented by @var{rtd}.@refill
@end defun

@defun record-modifier rtd field-name
Returns a procedure for writing the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly two arguments: first, a record of the appropriate type,
and second, an arbitrary Scheme value; it modifies the field named by
the symbol @var{field-name} in that record to contain the given value.
The returned value of the modifier procedure is unspecified.  The symbol
@var{field-name} must be a member of the list of field-names in the call
to @code{make-record-type} that created the type represented by
@var{rtd}.@refill
@end defun

@defun record-type-descriptor record
Returns a record-type descriptor representing the type of the given
record.  That is, for example, if the returned descriptor were passed to
@code{record-predicate}, the resulting predicate would return a true
value when passed the given record.  Note that it is not necessarily the
case that the returned descriptor is the one that was passed to
@code{record-constructor} in the call that created the constructor
procedure that created the given record.@refill
@end defun

@defun record-type-name rtd
Returns the type-name associated with the type represented by rtd.  The
returned value is @code{eqv?} to the @var{type-name} argument given in
the call to @code{make-record-type} that created the type represented by
@var{rtd}.@refill
@end defun

@defun record-type-field-names rtd
Returns a list of the symbols naming the fields in members of the type
represented by @var{rtd}.  The returned value is @code{equal?} to the
field-names argument given in the call to @code{make-record-type} that
created the type represented by @var{rtd}.@refill
@end defun


@page
@node Structures
@chapter Structures

[FIXME: this is pasted in from Tom Lord's original guile.texi and should
be reviewed]

A @dfn{structure type} is a first class user-defined data type.  A
@dfn{structure} is an instance of a structure type.  A structure type is
itself a structure.

Structures are less abstract and more general than traditional records.
In fact, in Guile Scheme, records are implemented using structures.

@menu
* Structure Concepts::          The structure of Structures
* Structure Layout::            Defining the layout of structure types
* Structure Basics::            make-, -ref and -set! procedures for structs
* Vtables::                     Accessing type-specific data
@end menu

@node  Structure Concepts
@section Structure Concepts

A structure object consists of a handle, structure data, and a vtable.
The handle is a Scheme value which points to both the vtable and the
structure's data.  Structure data is a dynamically allocated region of
memory, private to the structure, divided up into typed fields.  A
vtable is another structure used to hold type-specific data.  Multiple
structures can share a common vtable.

Three concepts are key to understanding structures.  

@itemize @bullet{}
@item @dfn{layout specifications}

Layout specifications determine how memory allocated to structures is
divided up into fields.  Programmers must write a layout specification
whenever a new type of structure is defined.

@item @dfn{structural accessors}

Structure access is by field number.   There is only one set of
accessors common to all structure objects.

@item @dfn{vtables}

Vtables, themselves structures, are first class representations of
disjoint sub-types of structures in general.   In most cases, when a 
new structure is created, programmers must specifiy a vtable for the
new structure.   Each vtable has a field describing the layout of its
instances.   Vtables can have additional, user-defined fields as well.
@end itemize



@node  Structure Layout
@section Structure Layout

When a structure is created, a region of memory is allocated to hold its
state.  The @dfn{layout} of the structure's type determines how that
memory is divided into fields.

Each field has a specified type.  There are only three types allowed, each
corresponding to a one letter code.  The allowed types are: 

@itemize @bullet{}
@item 'u' -- unprotected

The field holds binary data that is not GC protected.

@item 'p' -- protected

The field holds a Scheme value and is GC protected.

@item 's' -- self

The field holds a Scheme value and is GC protected.  When a structure is
created with this type of field, the field is initialized to refer to
the structure's own handle.  This kind of field is mainly useful when
mixing Scheme and C code in which the C code may need to compute a
structure's handle given only the address of its malloced data.
@end itemize


Each field also has an associated access protection.   There are only
three kinds of protection, each corresponding to a one letter code.
The allowed protections are:

@itemize @bullet{}
@item 'w' -- writable

The field can be read and written.

@item 'r' -- readable

The field can be read, but not written.

@item 'o' -- opaque

The field can be neither read nor written.   This kind
of protection is for fields useful only to built-in routines.
@end itemize

A layout specification is described by stringing together pairs
of letters: one to specify a field type and one to specify a field
protection.    For example, a traditional cons pair type object could
be described as:

@example
; cons pairs have two writable fields of Scheme data
"pwpw"
@end example

A pair object in which the first field is held constant could be:

@example
"prpw"
@end example

Binary fields, (fields of type "u"), hold one @emph{word} each.  The
size of a word is a machine dependent value defined to be equal to the
value of the C expression: @code{sizeof (long)}.

The last field of a structure layout may specify a tail array.
A tail array is indicated by capitalizing the field's protection 
code ('W', 'R' or 'O').   A tail-array field is replaced by 
a read-only binary data field containing an array size.   The array
size is determined at the time the structure is created.  It is followed
by a corresponding number of fields of the type specified for the
tail array.   For example, a conventional Scheme vector can be
described as:

@example
; A vector is an arbitrary number of writable fields holding Scheme
; values:
"pW"
@end example

In the above example, field 0 contains the size of the vector and 
fields beginning at 1 contain the vector elements.

A kind of tagged vector (a constant tag followed by conventioal
vector elements) might be:

@example
"prpW"
@end example


Structure layouts are represented by specially interned symbols whose
name is a string of type and protection codes.  To create a new
structure layout, use this procedure:

@defun make-struct-layout fields
Return a new structure layout object.

@var{fields} must be a read-only string made up of pairs of characters
strung together.  The first character of each pair describes a field
type, the second a field protection.  Allowed types are 'p' for
GC-protected Scheme data, 'u' for unprotected binary data, and 's' for
fields that should point to the structure itself.    Allowed protections
are 'w' for mutable fields, 'r' for read-only fields, and 'o' for opaque 
fields.  The last field protection specification may be capitalized to
indicate that the field is a tail-array.
@end defun



@node Structure Basics
@section Structure Basics

This section describes the basic procedures for creating and accessing
structures.

@defun make-struct type tail-elts . inits
Create a new structure.

@var{type} must be a vtable structure (@xref{Vtables}).

@var{tail-elts} must be a non-negative integer.  If the layout
specification indicated by @var{type} includes a tail-array,
this is the number of elements allocated to that array.

The @var{inits} are optional arguments describing how successive fields
of the structure should be initialized.  Only fields with protection 'r'
or 'w' can be initialized -- fields of protection 's' are automatically
initialized to point to the new structure itself;  fields of protection 'o'
can not be initialized by Scheme programs.
@end defun

@defun struct? obj
Return #t iff @var{obj} is a structure object.
@end defun


@defun struct-ref struct n
@defunx struct-set! struct n value
Access (or modify) the @var{n}th field of @var{struct}.

If the field is of type 'p', then it can be set to an arbitrary value.

If the field is of type 'u', then it can only be set to a non-negative
integer value small enough to fit in one machine word.
@end defun



@node  Vtables
@section Vtables

Vtables are structures that are used to represent structure types.
Each vtable contains a layout specification in field 0 -- instances
of the type are laid out according to that specification.  Vtables
contain additional fields which are used only internally to libguile.
The variable @code{struct-vtable-offset} is bound to a field number.
Vtable fields at that position or greater are user definable.

@defun struct-vtable struct
Return the vtable structure that describes the type of @var{struct}.
@end defun

@defun struct-vtable? obj
Return #t iff obj is a vtable structure.
@end defun

If you have a vtable structure, @code{V}, you can create an instance of
the type it describes by using @code{(make-struct V ...)}.  But where
does @code{V} itself come from?  One possibility is that @code{V} is an
instance of a user-defined vtable type, @code{V'}, so that @code{V} is
created by using @code{(make-struct V' ...)}.  Another possibility is
that @code{V} is an instance of the type it itself describes.  Vtable
structures of the second sort are created by this procedure:

@defun make-vtable-vtable new-fields tail-size . inits
Return a new, self-describing vtable structure.

@var{new-fields} is a layout specification describing fields
of the resulting structure beginning at the position bound to
@code{struct-vtable-offset}.

@var{tail-size} specifies the size of the tail-array (if any) of
this vtable.

@var{inits} initializes the fields of the vtable.  Minimally, one
initializer must be provided: the layout specification for instances
of the type this vtable will describe.

@example
;;; loading ,a...
(define x
  (make-vtable-vtable (make-struct-layout (quote pw))
                      0
                      'foo))

(struct? x)
@result{} #t
(struct-vtable? x)
@result{} #t
(eq? x (struct-vtable x))
@result{} #t
(struct-ref x struct-vtable-offset)
@result{} foo
(struct-ref x 0)
@result{} pruosrpw


(define y
  (make-struct x
               0
               (make-struct-layout (quote pwpwpw))
               'bar))

(struct? y)
@result{} #t
(struct-vtable? y)
@result{} #t
(eq? x y)
@result{} ()
(eq? x (struct-vtable y))
@result{} #t
(struct-ref y 0)
@result{} pwpwpw
(struct-ref y struct-vtable-offset)
@result{} bar


(define z (make-struct y 0 'a 'b 'c))

(struct? z)
@result{} #t
(struct-vtable? z)
@result{} ()
(eq? y (struct-vtable z))
@result{} #t
(map (lambda (n) (struct-ref z n)) '(0 1 2))
@result{} (a b c)
@end example

@end defun




@page
@node Arrays
@chapter Arrays

[FIXME: this is pasted in from Tom Lord's original guile.texi and should
be reviewed]

@menu
* Conventional Arrays::         
* Array Mapping::               
* Uniform Array::               
* Bit Vectors::                 
@end menu

@node Conventional Arrays
@section Conventional Arrays

@dfn{Arrays} read and write as a @code{#} followed by the @dfn{rank}
(number of dimensions) followed by what appear as lists (of lists) of
elements.  The lists must be nested to the depth of the rank.  For each
depth, all lists must be the same length.
@example
(make-array 'ho 3 3) @result{}
#2((ho ho ho) (ho ho ho) (ho ho ho))
@end example

Unshared conventional (not uniform) 0-based arrays of rank 1 (dimension)
are equivalent to (and can't be distinguished from) vectors.
@example
(make-array 'ho 3) @result{} (ho ho ho)
@end example

When constructing an array, @var{bound} is either an inclusive range of
indices expressed as a two element list, or an upper bound expressed
as a single integer.  So
@example
(make-array 'foo 3 3) @equiv{} (make-array 'foo '(0 2) '(0 2))
@end example

@defun array? obj
Returns @code{#t} if the @var{obj} is an array, and @code{#f} if not.
@end defun

@defun make-array initial-value bound1 bound2 @dots{}
Creates and returns an array that has as many dimensions as there are
@var{bound}s and fills it with @var{initial-value}.
@end defun

@defun array-ref array index1 index2 @dots{}
Returns the element at the @code{(index1, index2)} element in @var{array}.
@end defun

@defun array-in-bounds? array index1 index2 @dots{}
Returns @code{#t} if its arguments would be acceptable to array-ref.
@end defun

@defun array-set! array new-value index1 index2 @dots{}
Sets the element at the @code{(index1, index2)} element in @var{array} to
@var{new-value}.  The value returned by array-set! is unspecified.
@end defun

@defun make-shared-array array mapper bound1 bound2 @dots{}
@code{make-shared-array} can be used to create shared subarrays of other
arrays.  The @var{mapper} is a function that translates coordinates in
the new array into coordinates in the old array.  A @var{mapper} must be
linear, and its range must stay within the bounds of the old array, but
it can be otherwise arbitrary.  A simple example:
@example
(define fred (make-array #f 8 8))
(define freds-diagonal
  (make-shared-array fred (lambda (i) (list i i)) 8))
(array-set! freds-diagonal 'foo 3)
(array-ref fred 3 3) @result{} foo
(define freds-center
  (make-shared-array fred (lambda (i j) (list (+ 3 i) (+ 3 j))) 2 2))
(array-ref freds-center 0 0) @result{} foo
@end example
@end defun

@defun transpose-array array dim0 dim1 @dots{}
Returns an array sharing contents with @var{array}, but with dimensions
arranged in a different order.  There must be one @var{dim} argument for
each dimension of @var{array}.  @var{dim0}, @var{dim1}, @dots{} should
be integers between 0 and the rank of the array to be returned.  Each
integer in that range must appear at least once in the argument list.

The values of @var{dim0}, @var{dim1}, @dots{} correspond to dimensions
in the array to be returned, their positions in the argument list to
dimensions of @var{array}.  Several @var{dim}s may have the same value,
in which case the returned array will have smaller rank than
@var{array}.

examples:
@example
(transpose-array '#2((a b) (c d)) 1 0) @result{} #2((a c) (b d))
(transpose-array '#2((a b) (c d)) 0 0) @result{} #1(a d)
(transpose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 1 0) @result{}
                #2((a 4) (b 5) (c 6))
@end example
@end defun

@defun enclose-array array dim0 dim1 @dots{}
@var{dim0}, @var{dim1} @dots{} should be nonnegative integers less than
the rank of @var{array}.  @var{enclose-array} returns an array
resembling an array of shared arrays.  The dimensions of each shared
array are the same as the @var{dim}th dimensions of the original array,
the dimensions of the outer array are the same as those of the original
array that did not match a @var{dim}.

An enclosed array is not a general Scheme array.  Its elements may not
be set using @code{array-set!}.  Two references to the same element of
an enclosed array will be @code{equal?} but will not in general be
@code{eq?}.  The value returned by @var{array-prototype} when given an
enclosed array is unspecified.

examples:
@example
(enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1) @result{}
   #<enclosed-array (#1(a d) #1(b e) #1(c f)) (#1(1 4) #1(2 5) #1(3 6))>

(enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 0) @result{}
   #<enclosed-array #2((a 1) (d 4)) #2((b 2) (e 5)) #2((c 3) (f 6))>
@end example
@end defun

@defun array-shape array
Returns a list of inclusive bounds of integers.
@example
(array-shape (make-array 'foo '(-1 3) 5)) @result{} ((-1 3) (0 4))
@end example
@end defun

@defun array-dimensions array
@code{Array-dimensions} is similar to @code{array-shape} but replaces
elements with a @code{0} minimum with one greater than the maximum. So:
@example
(array-dimensions (make-array 'foo '(-1 3) 5)) @result{} ((-1 3) 5)
@end example
@end defun

@defun array-rank obj
Returns the number of dimensions of @var{obj}.  If @var{obj} is not an
array, @code{0} is returned.
@end defun

@defun array->list array
Returns a list consisting of all the elements, in order, of @var{array}.
@end defun

@defun array-copy! source destination
Copies every element from vector or array @var{source} to the
corresponding element of @var{destination}.  @var{destination} must have
the same rank as @var{source}, and be at least as large in each
dimension.  The order is unspecified.
@end defun

@defun serial-array-copy! source destination
Same as @code{array-copy!} but guaranteed to copy in row-major order.
@end defun

@defun array-fill! array fill
Stores @var{fill} in every element of @var{array}.  The value returned
is unspecified.
@end defun

@defun array-equal? array0 array1 @dots{}
Returns @code{#t} iff all arguments are arrays with the same shape, the
same type, and have corresponding elements which are either
@code{equal?}  or @code{array-equal?}.  This function differs from
@code{equal?} in that a one dimensional shared array may be
@var{array-equal?} but not @var{equal?} to a vector or uniform vector.
@end defun

@defun array-contents array
@defunx array-contents array strict
If @var{array} may be @dfn{unrolled} into a one dimensional shared array
without changing their order (last subscript changing fastest), then
@code{array-contents} returns that shared array, otherwise it returns
@code{#f}.  All arrays made by @var{make-array} and
@var{make-uniform-array} may be unrolled, some arrays made by
@var{make-shared-array} may not be.

If the optional argument @var{strict} is provided, a shared array will
be returned only if its elements are stored internally contiguous in
memory.
@end defun

@node Array Mapping
@section Array Mapping

@defun array-map! array0 proc array1 @dots{}
@var{array1}, @dots{} must have the same number of dimensions as
@var{array0} and have a range for each index which includes the range
for the corresponding index in @var{array0}.  @var{proc} is applied to
each tuple of elements of @var{array1} @dots{} and the result is stored
as the corresponding element in @var{array0}.  The value returned is
unspecified.  The order of application is unspecified.
@end defun

@defun serial-array-map! array0 proc array1 @dots{}
Same as @var{array-map!}, but guaranteed to apply @var{proc} in
row-major order.
@end defun

@defun array-for-each proc array0 @dots{}
@var{proc} is applied to each tuple of elements of @var{array0} @dots{}
in row-major order.  The value returned is unspecified.
@end defun

@defun array-index-map! array proc
applies @var{proc} to the indices of each element of @var{array} in
turn, storing the result in the corresponding element.  The value
returned and the order of application are unspecified.

One can implement @var{array-indexes} as
@example
(define (array-indexes array)
    (let ((ra (apply make-array #f (array-shape array))))
      (array-index-map! ra (lambda x x))
      ra))
@end example
Another example:
@example
(define (apl:index-generator n)
    (let ((v (make-uniform-vector n 1)))
      (array-index-map! v (lambda (i) i))
      v))
@end example
@end defun

@node Uniform Array
@section Uniform Array

@noindent
@dfn{Uniform Array} and vectors are arrays whose elements are all of the
same type.  Uniform vectors occupy less storage than conventional
vectors.  Uniform Array procedures also work on vectors,
uniform-vectors, bit-vectors, and strings.

@noindent
@var{prototype} arguments in the following procedures are interpreted
according to the table:

@example
prototype       type                            printing character

#t              boolean (bit-vector)                    b
#\a             char (string)                           a
integer >0      unsigned integer                        u
integer <0      signed integer                          e
1.0             float (single precision)                s
1/3             double (double precision float)         i
+i              complex (double precision)              c
()              conventional vector
@end example

@noindent
Unshared uniform character 0-based arrays of rank 1 (dimension)
are equivalent to (and can't be distinguished from) strings.
@example
(make-uniform-array #\a 3) @result{} "$q2"
@end example

@noindent
Unshared uniform boolean 0-based arrays of rank 1 (dimension) are
equivalent to (and can't be distinguished from) @ref{Bit Vectors,
bit-vectors}.
@example
(make-uniform-array #t 3) @result{} #*000
@equiv{}
#b(#f #f #f) @result{} #*000
@equiv{}
#1b(#f #f #f) @result{} #*000
@end example

@noindent
Other uniform vectors are written in a form similar to that of vectors,
except that a single character from the above table is put between
@code{#} and @code{(}.  For example, @code{'#e(3 5 9)} returns a uniform
vector of signed integers.

@defun array? obj prototype
Returns @code{#t} if the @var{obj} is an array of type corresponding to
@var{prototype}, and @code{#f} if not.
@end defun

@defun make-uniform-array prototype bound1 bound2 @dots{}
Creates and returns a uniform array of type corresponding to
@var{prototype} that has as many dimensions as there are @var{bound}s
and fills it with @var{prototype}.
@end defun

@defun array-prototype array
Returns an object that would produce an array of the same type as
@var{array}, if used as the @var{prototype} for
@code{make-uniform-array}.
@end defun

@defun list->uniform-array rank prot lst
@defunx list->uniform-vector prot lst
Returns a uniform array of the type indicated by prototype @var{prot}
with elements the same as those of @var{lst}.  Elements must be of the
appropriate type, no coercions are done.
@end defun

@defun uniform-vector-fill! uve fill
Stores @var{fill} in every element of @var{uve}.  The value returned is
unspecified.
@end defun

@defun uniform-vector-length uve
Returns the number of elements in @var{uve}.
@end defun

@defun dimensions->uniform-array dims prototype fill
@defunx dimensions->uniform-array dims prototype
@defunx make-uniform-vector length prototype fill
@defunx make-uniform-vector length prototype
Creates and returns a uniform array or vector of type corresponding to
@var{prototype} with dimensions @var{dims} or length @var{length}.  If
the @var{fill} argument is supplied, the returned array is filled with
this value.
@end defun

@defun uniform-array-read! ura
@defunx uniform-array-read! ura port
@defunx uniform-vector-read! uve
@defunx uniform-vector-read! uve port
Attempts to read all elements of @var{ura}, in lexicographic order, as
binary objects from @var{port}.  If an end of file is encountered during
uniform-array-read! the objects up to that point only are put into @var{ura}
(starting at the beginning) and the remainder of the array is
unchanged.

@code{uniform-array-read!} returns the number of objects read.
@var{port} may be omitted, in which case it defaults to the value
returned by @code{(current-input-port)}.
@end defun

@defun uniform-array-write ura
@defunx uniform-array-write ura port
@defunx uniform-vector-write uve
@defunx uniform-vector-write uve port
Writes all elements of @var{ura} as binary objects to @var{port}. The
number of objects actually written is returned. @var{port} may be
omitted, in which case it defaults to the value returned by
@code{(current-output-port)}.
@end defun

@node Bit Vectors
@section Bit Vectors

@noindent
Bit vectors can be written and read as a sequence of @code{0}s and
@code{1}s prefixed by @code{#*}.

@example
#b(#f #f #f #t #f #t #f) @result{} #*0001010
@end example

@noindent
Some of these operations will eventually be generalized to other
uniform-arrays.

@defun bit-count bool bv
Returns the number occurrences of @var{bool} in @var{bv}.
@end defun

@defun bit-position bool bv k
Returns the minimum index of an occurrence of @var{bool} in @var{bv}
which is at least @var{k}.  If no @var{bool} occurs within the specified
range @code{#f} is returned.
@end defun

@defun bit-invert! bv
Modifies @var{bv} by replacing each element with its negation.
@end defun

@defun bit-set*! bv uve bool
If uve is a bit-vector @var{bv} and uve must be of the same length.  If
@var{bool} is @code{#t}, uve is OR'ed into @var{bv}; If @var{bool} is @code{#f}, the
inversion of uve is AND'ed into @var{bv}.

If uve is a unsigned integer vector all the elements of uve must be
between 0 and the @code{LENGTH} of @var{bv}.  The bits of @var{bv}
corresponding to the indexes in uve are set to @var{bool}.

The return value is unspecified.
@end defun

@defun bit-count* bv uve bool
Returns
@example
(bit-count (bit-set*! (if bool bv (bit-invert! bv)) uve #t) #t).
@end example
@var{bv} is not modified.
@end defun


@page
@node Binary Numeric Operations
@chapter Binary Numeric Operations

@defun logand n1 n2
Returns the integer which is the bit-wise AND of the two integer
arguments.

Example:
@lisp
(number->string (logand #b1100 #b1010) 2)
   @result{} "1000"
@end lisp
@end defun

@defun logior n1 n2
Returns the integer which is the bit-wise OR of the two integer
arguments.

Example:
@lisp
(number->string (logior #b1100 #b1010) 2)
   @result{} "1110"
@end lisp
@end defun

@defun logxor n1 n2
Returns the integer which is the bit-wise XOR of the two integer
arguments.

Example:
@lisp
(number->string (logxor #b1100 #b1010) 2)
   @result{} "110"
@end lisp
@end defun

@defun lognot n
Returns the integer which is the 2s-complement of the integer argument.

Example:
@lisp
(number->string (lognot #b10000000) 2)
   @result{} "-10000001"
(number->string (lognot #b0) 2)
   @result{} "-1"
@end lisp
@end defun

@defun logtest j k
@example
(logtest j k) @equiv{} (not (zero? (logand j k)))

(logtest #b0100 #b1011) @result{} #f
(logtest #b0100 #b0111) @result{} #t
@end example
@end defun

@defun logbit? index j
@example
(logbit? index j) @equiv{} (logtest (integer-expt 2 index) j)

(logbit? 0 #b1101) @result{} #t
(logbit? 1 #b1101) @result{} #f
(logbit? 2 #b1101) @result{} #t
(logbit? 3 #b1101) @result{} #t
(logbit? 4 #b1101) @result{} #f
@end example
@end defun

@defun ash int count
Returns an integer equivalent to
@code{(inexact->exact (floor (* @var{int} (expt 2 @var{count}))))}.@refill

Example:
@lisp
(number->string (ash #b1 3) 2)
   @result{} "1000"
(number->string (ash #b1010 -1) 2)
   @result{} "101"
@end lisp
@end defun

@defun logcount n
Returns the number of bits in integer @var{n}.  If integer is positive,
the 1-bits in its binary representation are counted.  If negative, the
0-bits in its two's-complement binary representation are counted.  If 0,
0 is returned.

Example:
@lisp
(logcount #b10101010)
   @result{} 4
(logcount 0)
   @result{} 0
(logcount -2)
   @result{} 1
@end lisp
@end defun

@defun integer-length n
Returns the number of bits neccessary to represent @var{n}.

Example:
@lisp
(integer-length #b10101010)
   @result{} 8
(integer-length 0)
   @result{} 0
(integer-length #b1111)
   @result{} 4
@end lisp
@end defun

@defun integer-expt n k
Returns @var{n} raised to the non-negative integer exponent @var{k}.

Example:
@lisp
(integer-expt 2 5)
   @result{} 32
(integer-expt -3 3)
   @result{} -27
@end lisp
@end defun

@defun bit-extract n start end
Returns the integer composed of the @var{start} (inclusive) through
@var{end} (exclusive) bits of @var{n}.  The @var{start}th bit becomes
the 0-th bit in the result.@refill

Example:
@lisp
(number->string (bit-extract #b1101101010 0 4) 2)
   @result{} "1010"
(number->string (bit-extract #b1101101010 4 9) 2)
   @result{} "10110"
@end lisp
@end defun

@page
@node Shared and Read-Only Strings
@chapter Shared and Read-Only Strings

[FIXME: this is pasted in from Tom Lord's original guile.texi and should
be reviewed]

@menu
* Shared Substrings::           
* Read Only Strings::           
@end menu

@node  Shared Substrings
@section Shared Substrings

Whenever you extract a substring using @code{substring}, the Scheme
interpreter allocates a new string and copies data from the old string.
This is expensive, but @code{substring} is so convenient for
manipulating text that programmers use it often.

Guile Scheme provides the concept of the @dfn{shared substring} to
improve performance of many substring-related operations.  A shared
substring is an object that mostly behaves just like an ordinary
substring, except that it actually shares storage space with its parent
string.

@defun make-shared-substring str start [end]
Return a shared substring of @var{str}.  The semantics are the same as
for the @code{substring} function: the shared substring returned
includes all of the text from @var{str} between indexes @var{start}
(inclusive) and @var{end} (exclusive).  If @var{end} is omitted, it
defaults to the end of @var{str}.  The shared substring returned by
@code{make-shared-substring} occupies the same storage space as
@var{str}.
@end defun

Example:

@example
(define foo "the quick brown fox")
(define bar (make-shared-substring some-string 4 9))

foo => "t h e   q u i c k   b r o w n   f o x"
bar =========> |---------|
@end example

The shared substring @var{bar} is not given its own storage space.
Instead, the Guile interpreter notes internally that @var{bar} points to
a portion of the memory allocated to @var{foo}.  However, @var{bar}
behaves like an ordinary string in most respects: it may be used with
string primitives like @code{string-length}, @code{string-ref},
@code{string=?}.  Guile makes the necessary translation between indices
of @var{bar} and indices of @var{foo} automatically.

@example
(string-length? bar) @result{} 5	; bar only extends from indices 4 to 9
(string-ref bar 3)  @result{} #\c	; same as (string-ref foo 7)
(make-shared-substring bar 2)
  @result{} "ick"			; can even make a shared substring!
@end example

Because creating a shared substring does not require allocating new
storage from the heap, it is a very fast operation.  However, because it
shares memory with its parent string, a change to the contents of the
parent string will implicitly change the contents of its shared
substrings.

@example
(string-set! foo 7 #\r)
bar @result{} "quirk"
@end example

Shared substrings are also treated as read-only strings by Guile.  This
is because programmers might not always be aware that a given string is
really a shared substring, and might innocently try to mutate it without
realizing that the change would affect its parent string.

In general, shared substrings are useful in circumstances where it is
important to divide a string into smaller portions, but you do not
expect to change the contents of any of the strings involved.

@node Read Only Strings
@section Read Only Strings

Type-checking in Guile primitives distinguishes between mutable strings
and read only strings.  Mutable strings answer @code{#t} to
@code{string?}  while read only strings may or may not.   All kinds of
strings, whether or not they are mutable return #t to this:

@defun read-only-string? OBJ
Return true of OBJ can be read as a string,

This illustrates the difference between @code{string?} and
@code{read-only-string?}:

@example
(string? "a string") @result{} #t
(string? 'a-symbol") @result{} #f

(read-only-string? "a string") @result{} #t
(read-only-string? 'a-symbol") @result{} #t
@end example
@end defun


"Read only" refers to how the string will be used, not how the string is
permitted to be used.  In particular, all strings are "read only
strings" even if they are mutable, because a function that only reads
from a string can certainly operate on even a mutable string.

Symbols are an example of read only strings.  Many string functions,
such as @code{string-append} are happy to operate on symbols.  Many
functions that expect a string argument, such as @code{open-file}, will
accept a symbol as well.

Another of example of a read-only string is a "shared substring".
Shared substrings are defined in the next chapter.

@page
@node Property Lists
@chapter Property Lists

Every object in the system can have a @dfn{property list} that may
be used for information about that object.  For example, a
function may have a property list that includes information about
the source file in which it is defined.

Property lists are implemented as assq lists (@pxref{Association Lists}).

Currently, property lists are implemented differently for procedures and
closures than for other kinds of objects.  Therefore, when manipulating
a property list associated with a procedure object, use the
@code{procedure} functions; otherwise, use the @code{object} functions.

@defun object-properties obj
@defunx procedure-properties obj
Return @var{obj}'s property list.
@end defun

@defun set-object-properties! obj alist
@defunx set-procedure-properties! obj alist
Set @var{obj}'s property list to @var{alist}.
@end defun

@defun object-property obj key
@defunx procedure-property obj key
Return the property of @var{obj} with name @var{key}.
@end defun

@defun set-object-property! obj key value
@defunx set-procedure-property! obj key value
In @var{obj}'s property list, set the property named @var{key} to
@var{value}.
@end defun

[Interface bug:  there should be a second level of interface in which
the user provides a "property table" that is possibly private.]

@page
@node Association Lists and Hash Tables
@chapter Association Lists and Hash Tables

This chapter discusses dictionary objects: data structures that are
useful for organizing and indexing large bodies of information.

@menu
* Dictionary Types::  About dictionary types; what they're good for.
* Association Lists::           
* Hash Tables::   
@end menu

@node Dictionary Types
@section Dictionary Types

A @dfn{dictionary} object is a data structure used to index
information in a user-defined way.  In standard Scheme, the main
aggregate data types are lists and vectors.  Lists are not really
indexed at all, and vectors are indexed only by number
(e.g. @code{(vector-ref foo 5)}).  Often you will find it useful
to index your data on some other type; for example, in a library
catalog you might want to look up a book by the name of its
author.  Dictionaries are used to help you organize information in
such a way.

An @dfn{association list} (or @dfn{alist} for short) is a list of
key-value pairs.  Each pair represents a single quantity or
object; the @code{car} of the pair is a key which is used to
identify the object, and the @code{cdr} is the object's value.

A @dfn{hash table} also permits you to index objects with
arbitrary keys, but in a way that makes looking up any one object
extremely fast.  A well-designed hash system makes hash table
lookups almost as fast as conventional array or vector references.

Alists are popular among Lisp programmers because they use only
the language's primitive operations (lists, @dfn{car}, @dfn{cdr}
and the equality primitives).  No changes to the language core are
necessary.  Therefore, with Scheme's built-in list manipulation
facilities, it is very convenient to handle data stored in an
association list.  Also, alists are highly portable and can be
easily implemented on even the most minimal Lisp systems.

However, alists are inefficient, especially for storing large
quantities of data.  Because we want Guile to be useful for large
software systems as well as small ones, Guile provides a rich set
of tools for using either association lists or hash tables.

@node Association Lists
@section Association Lists

@defun assq key alist
@defunx assv key alist
@defunx assoc key alist
Fetches the entry in @var{alist} that is associated with @var{key}.  To
decide whether the argument @var{key} matches a particular entry in
@var{alist}, @code{assq} compares keys with @code{eq?}, @code{assv}
uses @code{eqv?} and @code{assoc} uses @code{equal?}.  If @var{key}
cannot be found in @var{alist} (according to whichever equality
predicate is in use), then @code{#f} is returned.  These functions
return the entire alist entry found (i.e. both the key and the value).
@end defun

@defun assq-ref alist key
@defunx assv-ref alist key
@defunx assoc-ref alist key
Like @code{assq}, @code{assv} and @code{assoc}, except that only the
value associated with @var{key} in @var{alist} is returned.  These
functions are equivalent to

@lisp
(let ((ent (@var{associator} @var{key} @var{alist})))
  (and ent (cdr ent)))
@end lisp

where @var{associator} is one of @code{assq}, @code{assv} or @code{assoc}.
@end defun

@deffn Procedure assq-set! alist key value
@deffnx Procedure assv-set! alist key value
@deffnx Procedure assoc-set! alist key value
Reassociate @var{key} in @var{alist} with @var{value}: find any existing
@var{alist} entry for @var{key} and associate it with the new
@var{value}.  If @var{alist} does not contain an entry for @var{key},
add a new one.  Return the (possibly new) alist.

These functions do not attempt to verify the structure of @var{alist},
and so may cause unusual results if passed an object that is not an
association list.
@end deffn

@deffn Procedure assq-remove! alist key
@deffnx Procedure assv-remove! alist key
@deffnx Procedure assoc-remove! alist key
Delete any entry in @var{alist} associated with @var{key}, and return
the resulting alist.
@end deffn

@strong{Caution:} it is important to remember that the @var{set!} and
@var{remove!} functions do not always operate as intended.  In some
circumstances, the functions will try to modify the first element in the
list; for example, when adding a new entry to an alist,
@code{assoc-set!} conses the new key-value pair on to the beginning of
the alist.  However, when this happens, the symbol to which the alist is
bound has not been modified---it still points to the old ``beginning''
of the list, which still does not contain the new entry.  In order to be
sure that these functions always succeed, even when modifying the
beginning of the alist, you will have to rebind the alist symbol
explicitly to point to the value returned by @code{assoc-set!}, like so:

@lisp
(set! my-alist
      (assq-set! my-alist 'sun4 "sparc-sun-solaris"))
@end lisp

Because of this restriction, you may find it more convenient to use hash
tables to store dictionary data.  If your application will not be
modifying the contents of an alist very often, this may not make much
difference to you.

Here is a longer example of how alists may be used in practice.

@lisp
(define capitals '(("New York" . "Albany")
                   ("Oregon"   . "Salem")
                   ("Florida"  . "Miami")))

;; What's the capital of Oregon?
(assoc "Oregon" capitals)       @result{} ("Oregon" . "Salem")
(assoc-ref capitals "Oregon")   @result{} "Salem"

;; We left out South Dakota.
(set! capitals
      (assoc-set! capitals "South Dakota" "Bismarck"))
capitals
@result{} (("South Dakota" . "Bismarck")
    ("New York" . "Albany")
    ("Oregon" . "Salem")
    ("Florida" . "Miami"))

;; And we got Florida wrong.
(set! capitals
      (assoc-set! capitals "Florida" "Tallahassee"))
capitals
@result{} (("South Dakota" . "Bismarck")
    ("New York" . "Albany")
    ("Oregon" . "Salem")
    ("Florida" . "Tallahassee"))

;; After Oregon secedes, we can remove it.
(set! capitals
      (assoc-remove! capitals "Oregon"))
capitals
@result{} (("South Dakota" . "Bismarck")
    ("New York" . "Albany")
    ("Florida" . "Tallahassee"))
@end lisp

@node Hash Tables
@section Hash Tables

Like the association list functions, the hash table functions come
in several varieties: @code{hashq}, @code{hashv}, and @code{hash}.
The @code{hashq} functions use @code{eq?} to determine whether two
keys match.  The @code{hashv} functions use @code{eqv?}, and the
@code{hash} functions use @code{equal?}.

In each of the functions that follow, the @var{table} argument
must be a vector.  The @var{key} and @var{value} arguments may be
any Scheme object.

@defun hashq-ref table key [default]
@defunx hashv-ref table key [default]
@defunx hash-ref table key [default]
Look up @var{key} in the hash table @var{table}, and return the
value (if any) associated with it.  If @var{key} is not found,
return @var{default} (or @code{#f} if no @var{default} argument is
supplied).
@end defun

@deffn Procedure hashq-set! table key value
@deffnx Procedure hashv-set! table key value
@deffnx Procedure hash-set! table key value
Find the entry in @var{table} associated with @var{key}, and store
@var{value} there.
@end deffn

@deffn Procedure hashq-remove! table key
@deffnx Procedure hashv-remove! table key
@deffnx Procedure hash-remove! table key
Remove @var{key} (and any value associated with it) from @var{table}.
@end deffn

The standard hash table functions may be too limited for some
applications.  For example, you may want a hash table to store
strings in a case-insensitive manner, so that references to keys
named ``foobar'', ``FOOBAR'' and ``FooBaR'' will all yield the
same item.  Guile provides you with @dfn{extended} hash tables
that permit you to specify a hash function and associator function
of your choosing.

If you are unfamiliar with the inner workings of hash tables, then
this facility will probably be a little too abstract for you to
use comfortably.  If you are interested in learning more, see an
introductory textbook on data structures or algorithms for an
explanation of how hash tables are implemented.

@defun hashq key size
@defunx hashv key size
@defunx hash key size
Default hash functions for Guile hash tables.  @var{key} is the
object to be hashed, and @var{size} is the size of the target hash
table.  Each function returns an integer in the range 0 to
@var{size}-1.
@end defun

@deffn Function hashx-ref hasher assoc table key [default]
@deffnx Procedure hashx-set! hasher assoc table key value
@deffnx Procedure hashx-remove! hasher assoc table key
These behave the same way as the corresponding @code{ref} and
@code{set!} functions described above, but use @var{hasher} as a
hash function and @var{assoc} to compare keys.  @code{hasher} must
be a function that takes two arguments, a key to be hashed and a
table size.  @code{assoc} must be an associator function, like
@code{assoc}, @code{assq} or @code{assv}.

By way of illustration, @code{hashq-ref table key} is equivalent
to @code{hashx-ref hashq assq table key}.
@end deffn

[FIXME: I have not included the `-get-handle' and
`-create-handle!' functions here, since the typical guile user
will probably only need to use the ref and set! functions, and
extra documentation they don't need to know may only be
confusing. -twp]

@page
@node Input/Output Ports
@chapter Input/Output Ports

Input and output devices in Scheme are represented by @dfn{ports}.
All input and output in Scheme programs is accomplished by
operating on a port: characters are read from an input port and
written to an output port.  This chapter explains the operations
that Guile provides for working with ports.

The formal definition of a port is very generic: an input port is
simply ``an object which can deliver characters on command,'' and
an output port is ``an object which can accept characters.''
Because this definition is so loose, it is easy to write functions
that simulate ports in software.  @dfn{Soft ports} and @dfn{string
ports} are two interesting and powerful examples of this technique.

@menu
* File Ports::                  
* Soft Ports::                  
* String Ports::                
* Extended I/O (fseek and line read/write)::  
@end menu

@node File Ports
@section File Ports

@defun open-file string modes
Open the file whose name is @var{string}, and return a port
representing that file.  Whether an input or output port is
allocated is determined by the @var{modes} string.  This is
interpreted in the traditional Unix manner: use @samp{r} for
reading, @samp{w} for writing, and @samp{a} for appending.  See
the @code{stdio} documentation for your system for more details on
how to specify I/O modes.

If a file cannot be opened, @code{open-file} returns @code{#f}.
@end defun

@defun port-mode port
Return the mode flags from the open @var{port}.
@end defun

@node Soft Ports
@section Soft Ports

A @dfn{soft-port} is a port based on a vector of procedures capable of
accepting or delivering characters.  It allows emulation of I/O ports.

@defun make-soft-port vector modes
Returns a port capable of receiving or delivering characters as
specified by the @var{modes} string (@pxref{File Ports,
open-file}).  @var{vector} must be a vector of length 6.  Its components
are as follows:

@enumerate 0
@item
procedure accepting one character for output
@item
procedure accepting a string for output
@item
thunk for flushing output
@item
thunk for getting one character
@item
thunk for closing port (not by garbage collection)
@end enumerate

For an output-only port only elements 0, 1, 2, and 4 need be
procedures.  For an input-only port only elements 3 and 4 need be
procedures.  Thunks 2 and 4 can instead be @code{#f} if there is no useful
operation for them to perform.

If thunk 3 returns @code{#f} or an @code{eof-object} (@pxref{Input,
eof-object?, ,r4rs, Revised(4) Scheme}) it indicates that the port has
reached end-of-file.  For example:

@example
(define stdout (current-output-port))
(define p (make-soft-port
           (vector
            (lambda (c) (write c stdout))
            (lambda (s) (display s stdout))
            (lambda () (display "." stdout))
            (lambda () (char-upcase (read-char)))
            (lambda () (display "@@" stdout)))
           "rw"))

(write p p) @result{} #<input-output-soft#\space45d10#\>
@end example
@end defun

@node String Ports
@section String Ports

@deffn Procedure call-with-output-string proc
@var{proc} must be a procedure of one argument.  This procedure calls
@var{proc} with one argument: a (newly created) output port.  When the
function returns, the string composed of the characters written into the
port is returned.
@end deffn

@deffn Procedure call-with-input-string string proc
@var{proc} must be a procedure of one argument.  This procedure calls
@var{proc} with one argument: an (newly created) input port from which
@var{string}'s contents may be read.  When @var{proc} returns, the port
is closed and the value yielded by the procedure @var{proc} is
returned.
@end deffn

@defun eval-string string
Evaluate @var{string} as the text representation of a Scheme form
or forms, and return whatever value they produce.
[FIXME: figure out where this should go... eval-string is not
really closely related to other string port functions.  It just
happens to appear in strports.c because it uses a string port to
read from the string. -twp]
@end defun

@node Extended I/O (fseek and line read/write)
@section Extended I/O (fseek and line read/write)


Extended I/O procedures are available which read or write lines of text,
read text delimited by a specified set of characters, or report or
set the current position of a port.

@findex fwrite
@findex fread
Interfaces to @code{read}/@code{fread} and @code{write}/@code{fwrite} are
also available, as @code{uniform-array-read!} and @code{uniform-array-write!},
@ref{Uniform Array}.

@deffn procedure read-line [port] [handle-delim]
Return a line of text from @var{port} if specified, otherwise from the
value returned by @code{(current-input-port)}.  Under Unix, a line of text
is terminated by the first end-of-line character or by end-of-file.

If @var{handle-delim} is specified, it should be one of the following
symbols:
@table @code
@item trim
Discard the terminating delimiter.  This is the default, but it will
be impossible to tell whether the read terminated with a delimiter or
end-of-file.
@item concat
Append the terminating delimiter (if any) to the returned string.
@item peek
Push the terminating delimiter (if any) back on to the port.
@item split
Return a pair containing the string read from the port and the 
terminating delimiter or end-of-file object.

NOTE: if the scsh module is loaded then
multiple values are returned instead of a pair.
@end table
@end deffn
@deffn procedure read-line! buf [port]
Read a line of text into the supplied string @var{buf} and return the
number of characters added to @var{buf}.  If @var{buf} is filled, then
@code{#f} is returned.
Read from @var{port} if
specified, otherwise from the value returned by @code{(current-input-port)}.
@end deffn
@deffn procedure read-delimited delims [port] [handle-delim]
Read text until one of the characters in the string @var{delims} is found
or end-of-file is reached.  Read from @var{port} if supplied, otherwise
from the value returned by @code{(current-input-port)}.
@var{handle-delim} takes the same values as described for @code{read-line}.

NOTE: if the scsh module is loaded then @var{delims} must be an scsh
char-set, not a string.
@end deffn
@deffn procedure read-delimited! delims buf [port] [handle-delim] [start] [end]
Read text into the supplied string @var{buf} and return the number of
characters added to @var{buf} (subject to @var{handle-delim}, which takes
the same values specified for @code{read-line}.  If @var{buf} is filled,
@code{#f} is returned for both the number of characters read and the
delimiter.  Also terminates if one of the characters in the string
@var{delims} is found
or end-of-file is reached.  Read from @var{port} if supplied, otherwise
from the value returned by @code{(current-input-port)}.

NOTE: if the scsh module is loaded then @var{delims} must be an scsh
char-set, not a string.
@end deffn
@deffn procedure write-line obj [port]
Display @var{obj} and a new-line character to @var{port} if specified,
otherwise to the
value returned by @code{(current-output-port)}; equivalent to:

@smalllisp
(display obj [port])
(newline [port])
@end smalllisp
@end deffn

@deffn procedure ftell port
Returns an integer representing the current position of @var{port},
measured from the beginning.
@end deffn

@deffn procedure fseek port offset whence
Sets the current position of @var{port} to the integer @var{offset},
which is interpreted according to the value of @var{whence}.

One of the following variables should be supplied
for @var{whence}:
@defvar SEEK_SET
Seek from the beginning of the file.
@end defvar
@defvar SEEK_CUR
Seek from the current position.
@end defvar
@defvar SEEK_END
Seek from the end of the file.
@end defvar
@end deffn


@page
@node Garbage Collection
@chapter Garbage Collection

[FIXME: this is pasted in from Tom Lord's original guile.texi and should
be reviewed]

@defun gc
Scans all of SCM objects and reclaims for further use those that are
no longer accessible.
@end defun

@defun gc-stats
Returns an association list of statistics about Guile's current use of storage.  
@end defun

@defun object-address obj
Return an integer that for the lifetime of @var{obj} is uniquely
returned by this function for @var{obj}
@end defun



@page
@node Threads and Dynamic Roots
@chapter Threads and Dynamic Roots

[FIXME: This is pasted in from Tom Lord's original guile.texi chapter
plus the Cygnus programmer's manual; it should be *very* carefully
reviewed and largely reorganized.]


@menu
* Dynamic Roots::               
* Threads::                     
@end menu

@node Dynamic Roots
@section Dynamic Roots
@cindex dynamic roots

A @dfn{dynamic root} is a root frame of Scheme evaluation.
The top-level repl, for example, is an instance of a dynamic root.

Each dynamic root has its own chain of dynamic-wind information.  Each
has its own set of continuations, jump-buffers, and pending CATCH
statements which are inaccessible from the dynamic scope of any
other dynamic root.

In a thread-based system, each thread has its own dynamic root.  Therefore,
continuations created by one thread may not be invoked by another.

Even in a single-threaded system, it is sometimes useful to create a new
dynamic root.  For example, if you want to apply a procedure, but to
not allow that procedure to capture the current continuation, calling
the procedure under a new dynamic root will do the job.

@defun call-with-dynamic-root thunk handler
Evaluate @var{(thunk)} in a new dynamic context, returning its value.

If an error occurs during evaluation, apply @var{handler} to the
arguments to the throw, just as @code{throw} would.  If this happens,
@var{handler} is called outside the scope of the new root -- it is
called in the same dynamic context in which
@code{call-with-dynamic-root} was evaluated.

If @var{thunk} captures a continuation, the continuation is rooted at
the call to @var{thunk}.  In particular, the call to
@code{call-with-dynamic-root} is not captured.  Therefore,
@code{call-with-dynamic-root} always returns at most one time.

Before calling @var{thunk}, the dynamic-wind chain is un-wound back to
the root and a new chain started for @var{thunk}.  Therefore, this call
may not do what you expect:

@example
;; Almost certainly a bug:
(with-output-to-port
 some-port

 (lambda ()
   (call-with-dynamic-root
    (lambda ()
      (display 'fnord)
      (newline))
    (lambda (errcode) errcode))))
@end example

The problem is, on what port will @samp{fnord\n} be displayed?  You
might expect that because of the @code{with-output-to-port} that
it will be displayed on the port bound to @code{some-port}.  But it
probably won't -- before evaluating the thunk, dynamic winds are
unwound, including those created by @code{with-output-to-port}.
So, the standard output port will have been re-set to its default value
before @code{display} is evaluated.

(This function was added to Guile mostly to help calls to functions in C
libraries that can not tolerate non-local exits or calls that return
multiple times.  If such functions call back to the interpreter, it should
be under a new dynamic root.)
@end defun


@defun dynamic-root
Return an object representing the current dynamic root.

These objects are only useful for comparison using @code{eq?}.
They are currently represented as numbers, but your code should
in no way depend on this.
@end defun

@defun quit &opt exit_val
@defunx restart
@defunx abort
Throw back to the error handler of the current dynamic root.

If integer @var{exit_val} is specified and if Guile is being used
stand-alone and if quit is called from the initial dynamic-root,
@var{exit_val} becomes the exit status of the Guile process and the
process exits.
@end defun

@node Threads
@section Threads
@cindex threads
@cindex Guile threads

@strong{[NOTE: this chapter was written for Cygnus Guile and has not yet
been updated for the Guile 1.x release.]}

Here is a the reference for Guile's threads.  In this chapter I simply
quote verbatim Tom Lord's description of the low-level primitives
written in C (basically an interface to the POSIX threads library) and
Anthony Green's description of the higher-level thread procedures
written in scheme.
@cindex posix threads
@cindex Lord, Tom
@cindex Green, Anthony

When using Guile threads, keep in mind that each guile thread is
executed in a new dynamic root.


@menu
* Low level thread primitives::  
* Higher level thread procedures::  
@end menu

@node Low level thread primitives
@subsection Low level thread primitives

@defun with-new-thread thunk error-thunk
Evaluate @var{(thunk)} in a new thread, and new dynamic context,
returning a new thread object representing the thread.

If an error occurs during evaluation, call error-thunk, passing it an
error code describing the condition.  [Error codes are currently
meaningless integers.  In the future, real values will be specified.]
If this happens, the error-thunk is called outside the scope of the new
root -- it is called in the same dynamic context in which
with-new-thread was evaluated, but not in the callers thread.

All the evaluation rules for dynamic roots apply to threads.
@end defun

@defun join-thread thread
Suspend execution of the calling thread until the target @var{thread}
terminates, unless the target @var{thread} has already terminated.
@end defun

@defun yield
If one or more threads are waiting to execute, calling yield forces an
immediate context switch to one of them. Otherwise, yield has no effect.
@end defun

@defun make-mutex
Create a new mutex object.
@end defun

@defun lock-mutex mutex
Lock @var{mutex}. If the mutex is already locked, the calling thread
blocks until the mutex becomes available. The function returns when
the calling thread owns the lock on @var{mutex}.
@end defun

@defun unlock-mutex mutex
Unlocks @var{mutex} if the calling thread owns the lock on @var{mutex}.
Calling unlock-mutex on a mutex not owned by the current thread results
in undefined behaviour. Once a mutex has been unlocked, one thread
blocked on @var{mutex} is awakened and grabs the mutex lock. 
@end defun

@node Higher level thread procedures
@subsection Higher level thread procedures

@defun with-new-thread thunk error-thunk
Evaluate @var{(thunk)} in a new thread, and new dynamic context,
returning a new thread object representing the thread.

If an error occurs during evaluation, call error-thunk, passing it an
error code describing the condition.  [Error codes are currently
meaningless integers.  In the future, real values will be specified.]
If this happens, the error-thunk is called outside the scope of the new
root -- it is called in the same dynamic context in which
with-new-thread was evaluated, but not in the callers thread.

All the evaluation rules for dynamic roots apply to threads.
@end defun

@defun join-thread thread
Suspend execution of the calling thread until the target @var{thread}
terminates, unless the target @var{thread} has already terminated.
@end defun

@defun yield
If one or more threads are waiting to execute, calling yield forces an
immediate context switch to one of them. Otherwise, yield has no effect.
@end defun

@defun make-mutex
Create a new mutex object.
@end defun

@defun lock-mutex mutex
Lock @var{mutex}. If the mutex is already locked, the calling thread
blocks until the mutex becomes available. The function returns when
the calling thread owns the lock on @var{mutex}.
@end defun

@defun unlock-mutex mutex
Unlocks @var{mutex} if the calling thread owns the lock on @var{mutex}.
Calling unlock-mutex on a mutex not owned by the current thread results
in undefined behaviour. Once a mutex has been unlocked, one thread
blocked on @var{mutex} is awakened and grabs the mutex lock. 
@end defun


@page
@node Reflection
@chapter Reflection

[FIXME: this is pasted in from Tom Lord's original guile.texi and should
be reviewed]

@menu
* eval::                        
* Tag Values::                  
@end menu

@node eval
@section eval

@node Tag Values
@section Tag Values


@page
@node Weak References
@chapter Weak References


@page
@node Regular Expressions
@chapter Regular Expressions

@cindex regular expressions
@cindex regex
@cindex emacs regexp

A @dfn{regular expression} (or @dfn{regexp}) is a pattern that
describes a whole class of strings.  A full description of regular
expressions and their syntax is beyond the scope of this manual;
an introduction can be found in the Emacs manual (@pxref{Regexps,
, Syntax of Regular Expressions, emacs, The GNU Emacs Manual}, or
in many general Unix reference books.

If your system does not include a POSIX regular expression library, and
you have not linked Guile with a third-party regexp library such as Rx,
these functions will not be available.  You can tell whether your Guile
installation includes regular expression support by checking whether the
@code{*features*} list includes the @code{regex} symbol.

@menu
* Regexp Functions::    Functions that create and match regexps.
* Match Structures::    Finding what was matched by a regexp.
* Backslash Escapes::   Removing the special meaning of regexp metacharacters.
* Rx Interface::	Tom Lord's Rx library does things differently.
@end menu

[FIXME: it may be useful to include an Examples section.  Parts of this
interface are bewildering on first glance.]

@node Regexp Functions
@section Regexp Functions

By default, Guile supports POSIX extended regular expressions.
That means that the characters @samp{(}, @samp{)}, @samp{+} and
@samp{?} are special, and must be escaped if you wish to match the
literal characters.

This regular expression interface was modeled after that
implemented by SCSH, the Scheme Shell.  It is intended to be
upwardly compatible with SCSH regular expressions.

@defun string-match pattern str [start]
Compile the string @var{pattern} into a regular expression and compare
it with @var{str}.  The optional numeric argument @var{start} specifies
the position of @var{str} at which to begin matching.

@code{string-match} returns a @dfn{match structure} which
describes what, if anything, was matched by the regular
expression.  @xref{Match Structures}.  If @var{str} does not match
@var{pattern} at all, @code{string-match} returns @code{#f}.
@end defun

Each time @code{string-match} is called, it must compile its
@var{pattern} argument into a regular expression structure.  This
operation is expensive, which makes @code{string-match} inefficient if
the same regular expression is used several times (for example, in a
loop).  For better performance, you can compile a regular expression in
advance and then match strings against the compiled regexp.

@defun make-regexp str [flag @dots{}]
Compile the regular expression described by @var{str}, and return the
compiled regexp structure.  If @var{str} does not describe a legal
regular expression, @code{make-regexp} throws a
@code{regular-expression-syntax} error.

The @var{flag} arguments change the behavior of the compiled regexp.
The following flags may be supplied:

@table @code
@item regexp/icase
Consider uppercase and lowercase letters to be the same when matching.

@item regexp/newline
If a newline appears in the target string, then permit the @samp{^} and
@samp{$} operators to match immediately after or immediately before the
newline, respectively.  Also, the @samp{.} and @samp{[^...]} operators
will never match a newline character.  The intent of this flag is to
treat the target string as a buffer containing many lines of text, and
the regular expression as a pattern that may match a single one of those
lines.

@item regexp/basic
Compile a basic (``obsolete'') regexp instead of the extended
(``modern'') regexps that are the default.  Basic regexps do not
consider @samp{|}, @samp{+} or @samp{?} to be special characters, and
require the @samp{@{...@}} and @samp{(...)} metacharacters to be
backslash-escaped (@pxref{Backslash Escapes}).  There are several other
differences between basic and extended regular expressions, but these
are the most significant.

@item regexp/extended
Compile an extended regular expression rather than a basic regexp.  This
is the default behavior; this flag will not usually be needed.  If a
call to @code{make-regexp} includes both @code{regexp/basic} and
@code{regexp/extended} flags, the one which comes last will override
the earlier one.
@end table

@end defun

@defun regexp-exec regexp str [start]
Match the compiled regular expression @var{regexp} against @code{str}.
If the optional integer @var{start} argument is provided, begin matching
>From that position in the string.  Return a match structure describing
the results of the match, or @code{#f} if no match could be found.
@end defun

@defun regexp? obj
Return @code{#t} if @var{obj} is a compiled regular expression, or
@code{#f} otherwise.
@end defun

Regular expressions are commonly used to find patterns in one string and
replace them with the contents of another string.

@defun regexp-substitute port match [item@dots{}]
Write to the output port @var{port} selected contents of the match
structure @var{match}.  Each @var{item} specifies what should be
written, and may be one of the following arguments:

@itemize @bullet
@item
A string.  String arguments are written out verbatim.

@item
An integer.  The submatch with that number is written.

@item
The symbol @samp{pre}.  The portion of the matched string preceding
the regexp match is written.

@item
The symbol @samp{post}.  The portion of the matched string following
the regexp match is written.
@end itemize

@var{port} may be @code{#f}, in which case nothing is written; instead,
@code{regexp-substitute} constructs a string from the specified
@var{item}s and returns that.
@end defun

@defun regexp-substitute/global port regexp target [item@dots{}]
Similar to @code{regexp-substitute}, but can be used to perform global
substitutions on @var{str}.  Instead of taking a match structure as an
argument, @code{regexp-substitute/global} takes two string arguments: a
@var{regexp} string describing a regular expression, and a @var{target}
string which should be matched against this regular expression.

Each @var{item} behaves as in @var{regexp-substitute}, with the
following exceptions:

@itemize @bullet
@item
A function may be supplied.  When this function is called, it will be
passed one argument: a match structure for a given regular expression
match.  It should return a string to be written out to @var{port}.

@item
The @samp{post} symbol causes @code{regexp-substitute/global} to recurse
on the unmatched portion of @var{str}.  This @emph{must} be supplied in
order to perform global search-and-replace on @var{str}; if it is not
present among the @var{item}s, then @code{regexp-substitute/global} will
return after processing a single match.
@end itemize
@end defun

@node Match Structures
@section Match Structures

@cindex match structures

A @dfn{match structure} is the object returned by @code{string-match} and
@code{regexp-exec}.  It describes which portion of a string, if any,
matched the given regular expression.  Match structures include: a
reference to the string that was checked for matches; the starting and
ending positions of the regexp match; and, if the regexp included any
parenthesized subexpressions, the starting and ending positions of each
submatch.

In each of the regexp match functions described below, the @code{match}
argument must be a match structure returned by a previous call to
@code{string-match} or @code{regexp-exec}.  Most of these functions
return some information about the original target string that was
matched against a regular expression; we will call that string
@var{target} for easy reference.

@defun regexp-match? obj
Return @code{#t} if @var{obj} is a match structure returned by a
previous call to @code{regexp-exec}, or @code{#f} otherwise.
@end defun

@defun match:substring match [n]
Return the portion of @var{target} matched by subexpression number
@var{n}.  Submatch 0 (the default) represents the entire regexp match.
If the regular expression as a whole matched, but the subexpression
number @var{n} did not match, return @code{#f}.
@end defun

@defun match:start match [n]
Return the starting position of submatch number @var{n}.
@end defun

@defun match:end match [n]
Return the ending position of submatch number @var{n}.
@end defun

@defun match:prefix match
Return the unmatched portion of @var{target} preceding the regexp match.
@end defun

@defun match:suffix match
Return the unmatched portion of @var{target} following the regexp match.
@end defun

@defun match:count match
Return the number of parenthesized subexpressions from @var{match}.
Note that the entire regular expression match itself counts as a
subexpression, and failed submatches are included in the count.
@end defun

@defun match:string match
Return the original @var{target} string.
@end defun

@node Backslash Escapes
@section Backslash Escapes

Sometimes you will want a regexp to match characters like @samp{*} or
@samp{$} exactly.  For example, to check whether a particular string
represents a menu entry from an Info node, it would be useful to match
it against a regexp like @samp{^* [^:]*::}.  However, this won't work;
because the asterisk is a metacharacter, it won't match the @samp{*} at
the beginning of the string.  In this case, we want to make the first
asterisk un-magic.

You can do this by preceding the metacharacter with a backslash
character @samp{\}.  (This is also called @dfn{quoting} the
metacharacter, and is known as a @dfn{backslash escape}.)  When Guile
sees a backslash in a regular expression, it considers the following
glyph to be an ordinary character, no matter what special meaning it
would ordinarily have.  Therefore, we can make the above example work by
changing the regexp to @samp{^\* [^:]*::}.  The @samp{\*} sequence tells
the regular expression engine to match only a single asterisk in the
target string.

Since the backslash is itself a metacharacter, you may force a regexp to
match a backslash in the target string by preceding the backslash with
itself.  For example, to find variable references in a @TeX{} program,
you might want to find occurrences of the string @samp{\let\} followed
by any number of alphabetic characters.  The regular expression
@samp{\\let\\[A-Za-z]*} would do this: the double backslashes in the
regexp each match a single backslash in the target string.

@defun regexp-quote str
Quote each special character found in @var{str} with a backslash, and
return the resulting string.
@end defun

@strong{Very important:} Using backslash escapes in Guile source code
(as in Emacs Lisp or C) can be tricky, because the backslash character
has special meaning for the Guile reader.  For example, if Guile
encounters the character sequence @samp{\n} in the middle of a string
while processing Scheme code, it replaces those characters with a
newline character.  Similarly, the character sequence @samp{\t} is
replaced by a horizontal tab.  Several of these @dfn{escape sequences}
are processed by the Guile reader before your code is executed.
Unrecognized escape sequences are ignored: if the characters @samp{\*}
appear in a string, they will be translated to the single character
@samp{*}.

This translation is obviously undesirable for regular expressions, since
we want to be able to include backslashes in a string in order to
escape regexp metacharacters.  Therefore, to make sure that a backslash
is preserved in a string in your Guile program, you must use @emph{two}
consecutive backslashes:

@lisp
(define Info-menu-entry-pattern (make-regexp "^\\* [^:]*"))
@end lisp

The string in this example is preprocessed by the Guile reader before
any code is executed.  The resulting argument to @code{make-regexp} is
the string @samp{^\* [^:]*}, which is what we really want.

This also means that in order to write a regular expression that matches
a single backslash character, the regular expression string in the
source code must include @emph{four} backslashes.  Each consecutive pair
of backslashes gets translated by the Guile reader to a single
backslash, and the resulting double-backslash is interpreted by the
regexp engine as matching a single backslash character.  Hence:

@lisp
(define tex-variable-pattern (make-regexp "\\\\let\\\\=[A-Za-z]*"))
@end lisp

The reason for the unwieldiness of this syntax is historical.  Both
regular expression pattern matchers and Unix string processing systems
have traditionally used backslashes with the special meanings
described above.  The POSIX regular expression specification and ANSI C
standard both require these semantics.  Attempting to abandon either
convention would cause other kinds of compatibility problems, possibly
more severe ones.  Therefore, without extending the Scheme reader to
support strings with different quoting conventions (an ungainly and
confusing extension when implemented in other languages), we must adhere
to this cumbersome escape syntax.

@node Rx Interface
@section Rx Interface

[FIXME: this is taken from Gary and Mark's quick summaries and should be
reviewed and expanded.  Rx is pretty stable, so could already be done!]

@cindex rx
@cindex finite automaton

Guile includes an interface to Tom Lord's Rx library (currently only to
POSIX regular expressions).  Use of the library requires a two step
process: compile a regular expression into an efficient structure, then
use the structure in any number of string comparisons.

For example, given the
regular expression @samp{abc.} (which matches any string containing
@samp{abc} followed by any single character):

@smalllisp
guile> @kbd{(define r (regcomp "abc."))}
guile> @kbd{r}
#<rgx abc.>
guile> @kbd{(regexec r "abc")}
#f
guile> @kbd{(regexec r "abcd")}
#((0 . 4))
guile>
@end smalllisp

The definitions of @code{regcomp} and @code{regexec} are as follows:

@deffn procedure regcomp pattern [flags]
Compile the regular expression pattern using POSIX rules.  Flags is
optional and should be specified using symbolic names:
@defvar REG_EXTENDED
use extended POSIX syntax
@end defvar
@defvar REG_ICASE
use case-insensitive matching
@end defvar
@defvar REG_NEWLINE
allow anchors to match after newline characters in the
string and prevents @code{.} or @code{[^...]} from matching newlines.
@end defvar

The @code{logior} procedure can be used to combine multiple flags.
The default is to use
POSIX basic syntax, which makes @code{+} and @code{?}  literals and @code{\+}
and @code{\?}
operators.  Backslashes in @var{pattern} must be escaped if specified in a
literal string e.g., @code{"\\(a\\)\\?"}.
@end deffn

@deffn procedure regexec regex string [match-pick] [flags]

Match @var{string} against the compiled POSIX regular expression 
@var{regex}.
@var{match-pick} and @var{flags} are optional.  Possible flags (which can be
combined using the logior procedure) are:

@defvar REG_NOTBOL
The beginning of line operator won't match the beginning of
@var{string} (presumably because it's not the beginning of a line)
@end defvar

@defvar REG_NOTEOL
Similar to REG_NOTBOL, but prevents the end of line operator
from matching the end of @var{string}.
@end defvar

If no match is possible, regexec returns #f.  Otherwise @var{match-pick}
determines the return value:

@code{#t} or unspecified: a newly-allocated vector is returned,
containing pairs with the indices of the matched part of @var{string} and any
substrings.

@code{""}: a list is returned: the first element contains a nested list
with the matched part of @var{string} surrounded by the the unmatched parts.
Remaining elements are matched substrings (if any).  All returned
substrings share memory with @var{string}.

@code{#f}: regexec returns #t if a match is made, otherwise #f.

vector: the supplied vector is returned, with the first element replaced
by a pair containing the indices of the matched portion of @var{string} and
further elements replaced by pairs containing the indices of matched
substrings (if any).

list: a list will be returned, with each member of the list
specified by a code in the corresponding position of the supplied list:

a number: the numbered matching substring (0 for the entire match).

@code{#\<}: the beginning of @var{string} to the beginning of the part matched
by regex.

@code{#\>}: the end of the matched part of @var{string} to the end of 
@var{string}.

@code{#\c}: the "final tag", which seems to be associated with the "cut
operator", which doesn't seem to be available through the posix
interface.

e.g., @code{(list #\< 0 1 #\>)}.  The returned substrings share memory with
@var{string}.
@end deffn

Here are some other procedures that might be used when using regular
expressions:

@deffn procedure compiled-regexp? obj
Test whether obj is a compiled regular expression.
@end deffn

@deffn procedure regexp->dfa regex [flags]
@end deffn

@deffn procedure dfa-fork dfa
@end deffn

@deffn procedure reset-dfa! dfa
@end deffn

@deffn procedure dfa-final-tag dfa
@end deffn

@deffn procedure dfa-continuable? dfa
@end deffn

@deffn procedure advance-dfa! dfa string
@end deffn

@page
@node SLIB
@chapter SLIB

SLIB is a portable Scheme library which can be obtained by ftp from
@url{ftp://prep.ai.mit.edu/pub/gnu/jacal}.

The SLIB package should be unpacked somewhere in Guile's load path.
The load path can be checked from inside the interpreter, e.g.,

@smalllisp
guile> %load-path
("/usr/local/share/guile/site" "/usr/local/share/guile/1.3a" "/usr/local/share/guile" ".")
@end smalllisp

so we may have @code{/usr/local/share/guile/site/slib/...}.

Before the the SLIB facilities can be used, the following Scheme
expression must be executed:

@smalllisp
(use-modules (ice-9 slib))
@end smalllisp

@code{require} can then be used as described in 
@ref{Top, , SLIB, slib, The SLIB Manual}, e.g.,

@smalllisp
(require 'format)
(format "~8,48D" 10)
@end smalllisp

@page
@node POSIX system calls and networking
@chapter POSIX system calls and networking

The low level Unix interfaces are currently available by default in the
Guile top level.  However in the future they will probably be placed in
a module and @code{use-modules} or something similar will be required to
make them available.

@menu
* conventions::
* ports vs. file descriptors::  
* file system::
* user database::
* time::
* processes::
* signals::
* terminals and pseudo-terminals::  
* pipes::                       
* networking::
* system identification (uname)::  
* locales (setlocale):: 
* expect::
@end menu

@node conventions
@section conventions

The low-level interfaces are designed to give Scheme programs access to
as much functionality as possible from the underlying Unix system.  They
can be used to implement higher level intefaces such as the Scheme shell
@ref{The Scheme shell (scsh)}.

Generally there is a single procedure for each corresponding Unix
facility.  There are some exceptions, such as procedures implemented for
speed and convenience in Scheme with no primitive Unix equivalent,
e.g., @code{copy-file}.

The interfaces are intended as far as possible to be portable across
different versions of Unix, so that Scheme programmers don't need to be
concerned with implementation differences.  In some cases procedures
which can't be implemented (or reimplemented) on particular systems may
become no-ops, or perform limited actions.  In other cases they may
throw errors.  It should be possible to use the feature system to
determine what functionality is available.

General naming conventions are as follows:

@itemize @bullet
@item
The Scheme name is often identical to the name of the underlying Unix
facility.
@item
Underscores in Unix names are converted to hyphens.
@item
Procedures which destructively modify Scheme data gain
exclaimation marks, e.g., @code{recv!}.
@item
Predicates (returning only @code{#t} or @code{#f}) have question marks
added, e.g., @code{access?}.
@item
Some names are changed to avoid conflict with dissimilar interfaces
defined by scsh, e.g., @code{primitive-fork}.
@item
Unix preprocessor names such as @code{EPERM} or @code{R_OK} are converted
to Scheme variables of the same name (underscores are not replaced
with hyphens).
@end itemize

Most of the procedures can be relied on to return a
well-specified value.  Unexpected conditions are handled by raising
exceptions.

There are a few procedures which return a special
value if they don't succeed, e.g., @code{getenv} returns @code{#f}
if it the requested string is not found in the environment.  These
cases will be noted in the documentation.

For ways to deal with exceptions, @ref{Exceptions}.

Errors which the C-library would report by returning a NULL
pointer or through some other means are reported by raising a
@code{system-error} exception.
The value of the Unix @code{errno} variable is available
in the data passed by the exception.  Accessing the
global errno value directly would be unreliable due to
continuations, interrupts or multiple threads.

@node ports vs. file descriptors
@section ports vs. file descriptors

Conventions largely follow those of scsh, @ref{The Scheme shell (scsh)}.

Guile ports are currently based on C stdio streams.  Ports can be
buffered or unbuffered.  Unbuffered ports can be specified by including
@code{0} in a port mode string.  Note that some system call interfaces
(e.g., @code{recv!}) will accept ports as arguments, but
will actually operate directly on the file descriptor underlying the
port.  Any port buffering is ignored, including the one character buffer
used to implement @code{peek-char} and @code{unread-char}.

File descriptors are generally not useful for Scheme programs; however
they can be needed when interfacing with foreign code and the Unix
environment.

A file descriptor can be extracted from a port and later converted
back to a port.  However a file descriptor
is just an integer, and the garbage collector doesn't recognise it
as a reference to the port.  If all other references to the port were
dropped, then it's likely that the garbage collector would free
the port, with the side-effect of closing the file descriptor
prematurely.

To assist the programmer in avoiding this problem,
each port has an associated "revealed count" which can be used to keep
track of how many times the underlying file descriptor has been stored
in other places.  The
idea is for the programmer to ensure that the revealed count will be
greater than zero if the file descriptor is needed elsewhere.

For the simple case where a file descriptor is "imported"
once to become a port, it does not matter if the file descriptor
is closed when the port is garbage collected.  There is
no need to maintain a revealed count.  Likewise when "exporting"
a file descriptor to the external environment, setting the revealed count
is not required if the port is kept open while the file descriptor
is in use.

To correspond with traditional Unix behaviour, the three file
descriptors (0, 1 and 2) are automatically imported when a program
starts up and assigned to the initial values of the current input,
output and error ports.  The revealed count for each is initially set to
one, so that dropping references to one of these ports will not result
in its garbage collection: it could be retrieved with fdopen or
fdes->ports.

@deffn procedure port-revealed port
Returns the revealed count for @var{port}.
@end deffn

@deffn procedure set-port-revealed! port count
Sets the revealed count for a port to a given value.  The return value
is unspecified.
@end deffn

@deffn procedure fileno port
Returns the integer file descriptor underlying @var{port} without
changing its revealed count.
@end deffn

@deffn procedure port->fdes port
Returns the integer file descriptor underlying @var{port}.  As a
side effect the revealed count of @var{port} is incremented.
@end deffn

@deffn procedure fdopen fdes modes
Returns a new port based on the file descriptor @var{fdes} with
modes given by the string @var{modes}.  The revealed count of the port
is initialized to zero.  The modes string is the same as that accepted
by @code{open-file}.
@end deffn

@findex fflush
@deffn procedure force-output [port]
Flush the specified output port, or the current output port if @var{port}
is omitted.  The return value is unspecified.
@end deffn

@deffn procedure flush-all-ports
Flush all open output ports.  The return value is unspecified.
@end deffn

@defun fdes->ports fdes
Returns a list of existing ports which have @var{fdes} as an
underlying file descriptor, without changing their revealed counts.
@end defun

@defun fdes->inport fdes
Returns an existing input port which has @var{fdes} as its underlying file
descriptor, if one exists, without changing its revealed count.
Otherwise, returns a new input port created with
fdopen and sets its revealed count to 1.
@end defun

@defun fdes->outport fdes
Returns an existing output port which has @var{fdes} as its underlying file
descriptor, if one exists, without changing its revealed count.
Otherwise, returns a new output port created with
fdopen and sets its revealed count to 1.
@end defun

@defun primitive-move->fdes port fdes
Moves the underlying file descriptor for @var{port} to the integer
value @var{fdes} without changing the revealed count of @var{port}.
Any other ports
already using this descriptor will be automatically
shifted to new descriptors and their revealed counts reset to zero.
The return value is zero if the file descriptor does not need to be
moved or one if it does.
@end defun

@deffn procedure move->fdes port fd
Moves the underlying file descriptor for @var{port} to the integer
value @var{fdes} and sets its revealed count to one.  Any other ports
already using this descriptor will be automatically
shifted to new descriptors and their revealed counts reset to zero.
The return value is unspecified.
@end deffn

@deffn procedure release-port-handle port
Decrements the revealed count for a port.
@end deffn

@deffn procedure pipe
Creates a pipe which can be used for communication.  The return value
is a pair in which the CAR contains an input port and the CDR an
output port.  Data written to the output port can be read from the
input port.  Note that both ports are buffered so it may be necessary
to flush the output port before data will actually be sent across the pipe.
Alternatively a new unbuffered output port can be created using
@code{duplicate-port} with an appropriate mode string.
@end deffn

@deffn procedure duplicate-port port modes
Returns a new port which is opened on a duplicate of the file
descriptor underlying @var{port}, with mode string @var{modes}
as for @code{open-file}.  The two ports
will share a file position and file status flags.

Unexpected behaviour can result if both ports are subsequently used
and the original and/or duplicate ports are buffered.
The mode string can include @code{0} to obtain an unbuffered duplicate
port.
@end deffn

@deffn procedure redirect-port old-port new-port
This procedure takes two ports and duplicates the underlying file
descriptor from @var{old-port} into @var{new-port}.  The
current file descriptor in @var{new-port} will be closed.
After the redirection the two ports will share a file position
and file status flags.

The return value is unspecified.

Unexpected behaviour can result if both ports are subsequently used
and the original and/or duplicate ports are buffered.
@end deffn

@deffn procedure port-mode port
Returns the port modes associated with the open port @var{port}.  These
will not necessarily be identical to the modes used when the port was
opened, since modes such as "append" which are used only during
port creation are not retained.
@end deffn

@deffn procedure close-all-ports-except port @dots{}
Close all open file ports used by the interpreter
except for those supplied as arguments.  This procedure
is intended to be used before an exec call to close file descriptors
which are not needed in the new process.
@end deffn

@deffn procedure freopen filename modes port
Reopen @var{port} on the specified @var{filename}
with mode string @var{modes} as for @code{open-file}.
@end deffn

@deffn procedure fcntl port command value
Apply @var{command} to @var{port}'s file descriptor, with
@var{value} as an argument.

Values for @var{command} are:

@table @code
@item F_DUPFD
Duplicate a file descriptor
@item F_GETFD
Get flags associated with the file descriptor.
@item F_SETFD
Set flags associated with the file descriptor to @var{value}.
@item F_GETFL
Get flags associated with the open file.
@item F_SETFL
Set flags associated with the open file to @var{value}
@item F_GETOWN
Get the process ID of a socket's owner, for @code{SIGIO} signals.
@item F_SETOWN
Set the process that owns a socket to @var{value}, for @code{SIGIO} signals.
@item FD_CLOEXEC
The value used to indicate the "close on exec" flag with @code{F_GETFL} or
@code{F_SETFL}.
@end table
@end deffn

@deffn procedure select reads writes excepts [secs] [usecs]
@var{reads}, @var{writes} and @var{excepts} can be lists or vectors: it
doesn't matter which, but the corresponding object returned will be
of the same type.
Each element is a port or file descriptor on which to wait for
readability, writeability
or exceptional conditions respectively.  @var{secs} and @var{usecs}
optionally specify a timeout: @var{secs} can be specified alone, as
either an integer or a real number, or both @var{secs} and @var{usecs}
can be specified as integers, in which case @var{usecs} is an additional
timeout expressed in microseconds.

Buffered input or output data is (currently, but this may change)
ignored: select uses the underlying file descriptor of a port
(@code{char-ready?} will check input buffers, output buffers are
problematic).

The return value is a list of subsets of the input lists or vectors for
which the requested condition has been met.

It is not quite compatible with scsh's select: scsh checks port buffers,
doesn't accept input lists or a microsecond timeout, returns multiple
values instead of a list and has an additional select! interface.
@end deffn

@node file system
@section file system

These procedures allow querying and setting file system attributes
(such as owner,
permissions, sizes and types of files); deleting, copying, renaming and
linking files; creating and removing directories and querying their
contents; syncing the file system and creating special files.

@deffn procedure access? path how
Returns @code{#t} if @var{path} corresponds to an existing
file and the current process
has the type of access specified by @var{how}, otherwise 
@code{#f}.
@var{how} should be specified
using the values of the variables listed below.  Multiple values can
be combined using a bitwise or, in which case @code{#t} will only
be returned if all accesses are granted.

Permissions are checked using the real id of the current process,
not the effective id, although it's the effective id which determines
whether the access would actually be granted.

@defvar R_OK
test for read permission.
@end defvar
@defvar W_OK
test for write permission.
@end defvar
@defvar X_OK
test for execute permission.
@end defvar
@defvar F_OK
test for existence of the file.
@end defvar
@end deffn

@findex fstat
@deffn procedure stat obj
Returns an object containing various information
about the file determined by @var{obj}.
@var{obj} can be a string containing a file name or a port or integer file
descriptor which is open on a file (in which case @code{fstat} is used
as the underlying system call).

The object returned by @code{stat} can be passed as a single parameter
to the following procedures, all of which return integers:

@table @code
@item stat:dev
The device containing the file.
@item stat:ino
The file serial number, which distinguishes this file from all other
files on the same device.
@item stat:mode
The mode of the file.  This includes file type information
and the file permission bits.  See @code{stat:type} and @code{stat:perms}
below.
@item stat:nlink
The number of hard links to the file.
@item stat:uid
The user ID of the file's owner.
@item stat:gid
The group ID of the file.
@item stat:rdev
Device ID; this entry is defined only for character or block
special files.
@item stat:size
The size of a regular file in bytes.
@item stat:atime
The last access time for the file.
@item stat:mtime
The last modification time for the file.
@item stat:ctime
The last modification time for the attributes of the file.
@item stat:blksize
The optimal block size for reading or writing the file, in bytes.
@item stat:blocks
The amount of disk space that the file occupies measured in units of
512 byte blocks.
@end table

In addition, the following procedures return the information
from stat:mode in a more convenient form:

@table @code
@item stat:type
A symbol representing the type of file.  Possible values are
regular, directory, symlink, block-special, char-special,
fifo, socket and unknown
@item stat:perms
An integer representing the access permission bits.
@end table
@end deffn

@deffn procedure lstat path
Similar to @code{stat}, but does not follow symbolic links, i.e.,
it will return information about a symbolic link itself, not the 
file it points to.  @var{path} must be a string.
@end deffn

@deffn procedure readlink path
Returns the value of the symbolic link named by
@var{path} (a string), i.e., the
file that the link points to.
@end deffn

@findex fchown
@findex lchown
@deffn procedure chown path owner group
Change the ownership and group of the file specified by @var{path} to
the integer userid values @var{owner} and @var{group}.  The return value
is unspecified.  If @var{path} is a symbolic link, either the
ownership of the link or the ownership of the referenced file will be
changed depending on the system (fchown and lchown are
unsupported at present).
@end deffn

@findex fchmod
@deffn procedure chmod obj mode
Changes the permissions of the file referred to by @var{obj}.
@var{obj} can be a string containing a file name or a port or integer file
descriptor which is open on a file (in which case @code{fchmod} is used
as the underlying system call).
@var{mode} specifies
the new permissions as a decimal number, e.g., @code{(chmod "foo" #o755)}.
The return value is unspecified.
@end deffn

@deffn procedure utime path [actime] [modtime]
@code{utime} sets the access and modification times for
the file named by @var{path}.  If @var{actime} or @var{modtime}
is not supplied, then the current time is used.
@var{actime} and @var{modtime}
must be integer time values as returned by the @code{current-time}
procedure.

E.g.,

@smalllisp
(utime "foo" (- (current-time) 3600))
@end smalllisp

will set the access time to one hour in the past and the modification
time to the current time.
@end deffn

@findex unlink
@deffn procedure delete-file path
Deletes (or "unlinks") the file specified by @var{path}.
@end deffn

@deffn procedure copy-file path-from path-to
Copy the file specified by @var{path-from} to @var{path-to}.
The return value is unspecified.
@end deffn

@deffn procedure rename-file path-from path-to
Renames the file specified by @var{path-from} to @var{path-to}.
The return value is unspecified.
@end deffn

@deffn procedure link path-from path-to
Creates a new name @var{path-to} in the file system for the file
named by @var{path-from}.  If @var{path-from} is a symbolic link, the
link may or may not be followed depending on the system.
@end deffn

@deffn procedure symlink path-from path-to
Create a symbolic link named @var{path-to} with the value (i.e., pointing to)
@var{path-from}.  The return value is unspecified.
@end deffn

@deffn procedure mkdir path [mode]
Create a new directory named by @var{path}.  If @var{mode} is omitted
then the permissions of the directory file are set using the current
umask.  Otherwise they are set to the decimal value specified with
@var{mode}.  The return value is unspecified.
@end deffn

@deffn procedure rmdir path
Remove the existing directory named by @var{path}.  The directory must
be empty for this to succeed.  The return value is unspecified.
@end deffn

@deffn procedure opendir path
Open the directory specified by @var{path} and return a directory
port.
@end deffn

@deffn procedure readdir port
Return (as a string) the next directory entry from the directory port
@var{port}.  If there is no remaining entry to be read then the
end of file object is returned.
@end deffn

@deffn procedure rewinddir port
Reset the directory port @var{port} so that the next call to
@code{readdir} will return the first directory entry.
@end deffn

@deffn procedure closedir port
Close the directory port @var{port}.
The return value is unspecified.
@end deffn

@deffn procedure sync
Flush the operating system disk buffers.
The return value is unspecified.
@end deffn

@deffn procedure mknod path type perms dev
Creates a new special file, such as a file corresponding to a device.
@var{path} specifies the name of the file.  @var{type} should
be one of the following symbols:
regular, directory, symlink, block-special, char-special,
fifo, or socket.  @var{perms} (an integer) specifies the file permissions.
@var{dev} (an integer) specifies which device the special file refers
to.  Its exact interpretation depends on the kind of special file
being created.

E.g.,
@example
(mknod "/dev/fd0" 'block-special #o660 (+ (* 2 256) 2))
@end example

The return value is unspecified.
@end deffn

@node user database
@section user database

The facilities in this section provide an interface to the user and
group database.
They should be used with care since they are not reentrant.

The following functions accept an object representing user information
and return a selected component:

@table @code
@item passwd:name
The name of the userid.
@item passwd:passwd
The encrypted passwd.
@item passwd:uid
The user id number.
@item passwd:gid
The group id number.
@item passwd:gecos
The full name.
@item passwd:dir
The home directory.
@item passwd:shell
The login shell.
@end table

@deffn procedure getpwuid uid
Look up an integer userid in the user database.
@end deffn

@deffn procedure getpwnam name
Look up a user name string in the user database.
@end deffn

@deffn procedure setpwent
Initializes a stream used by @code{getpwent} to read from the user database.
The next use of @code{getpwent} will return the first entry.  The
return value is unspecified.
@end deffn

@deffn procedure getpwent
Return the next entry in the user database, using the stream set by
@code{setpwent}.
@end deffn

@deffn procedure endpwent
Closes the stream used by @code{getpwent}.  The return value is unspecified.
@end deffn

@deffn procedure getpw [obj]
Look up an entry in the user database.  @var{obj} can be an integer,
a string, or omitted, giving the behaviour of getpwuid, getpwnam
or getpwent respectively.
@end deffn

The following functions accept an object representing group information
and return a selected component:

@table @code
@item group:name
The group name.
@item group:passwd
The encrypted group password.
@item group:gid
The group id number.
@item group:mem
A list of userids which have this group as a supplimentary group.
@end table

@deffn procedure getgrgid gid
Look up an integer groupid in the group database.
@end deffn

@deffn procedure getgrnam name
Look up a group name in the group database.
@end deffn

@deffn procedure setgrent
Initializes a stream used by @code{getgrent} to read from the group database.
The next use of @code{getgrent} will return the first entry.
The return value is unspecified.
@end deffn

@deffn procedure getgrent
Return the next entry in the group database, using the stream set by
@code{setgrent}.
@end deffn

@deffn procedure endgrent
Closes the stream used by @code{getgrent}.
The return value is unspecified.
@end deffn

@deffn procedure getgr [obj]
Look up an entry in the group database.  @var{obj} can be an integer,
a string, or omitted, giving the behaviour of getgrgid, getgrnam
or getgrent respectively.
@end deffn

@node time
@section time

@deffn procedure current-time
Returns the number of seconds since 1970-01-01 00:00:00 UTC, excluding
leap seconds.
@end deffn

@deffn procedure gettimeofday
Returns a pair containing the number of seconds and microseconds since
1970-01-01 00:00:00 UTC, excluding leap seconds.  Note: whether true
microsecond resolution is available depends on the operating system.
@end deffn

The following procedures either accept an object representing a broken down
time and return a selected component, or accept an object representing
a broken down time and a value and set the component to the value.
The numbers in parentheses give the usual range.

@table @code
@item tm:sec, set-tm:sec
Seconds (0-59).
@item tm:min, set-tm:min
Minutes (0-59).
@item tm:hour, set-tm:hour
Hours (0-23).
@item tm:mday, set-tm:mday
Day of the month (1-31).
@item tm:mon, set-tm:mon
Month (0-11).
@item tm:year, set-tm:year
Year (70-), the year minus 1900.
@item tm:wday, set-tm:wday
Day of the week (0-6) with Sunday represented as 0.
@item tm:yday, set-tm:yday
Day of the year (0-364, 365 in leap years).
@item tm:isdst, set-tm:isdst
Daylight saving indicator (0 for "no", greater than 0 for "yes", less than
0 for "unknown").
@item tm:gmtoff, set-tm:gmtoff
Time zone offset in seconds west of UTC (-46800 to 43200).
@item tm:zone, set-tm:zone
Time zone label (a string), not necessarily unique.
@end table

@deffn procedure localtime time [zone]
Returns an object representing the broken down components of @var{time},
an integer like the one returned by @code{current-time}.  The time zone
for the calculation is optionally specified by @var{zone} (a string),
otherwise the @code{TZ} environment variable or the system default is
used.
@end deffn

@deffn procedure gmtime time
Returns an object representing the broken down components of @var{time},
an integer like the one returned by @code{current-time}.  The values
are calculated for UTC.
@end deffn

@deffn procedure mktime bd-time [zone]
@var{bd-time} is an object representing broken down time and @code{zone}
is an optional time zone specifier (otherwise the TZ environment variable
or the system default is used).

Returns a pair: the CAR is a corresponding
integer time value like that returned
by @code{current-time}; the CDR is a broken down time object, similar to
as @var{bd-time} but with normalized values.
@end deffn

@deffn procedure tzset
Initialize the timezone from the TZ environment variable or the system
default.  Usually this is done automatically by other procedures which
use the time zone, but this procedure may need to be used if TZ
is changed.
@end deffn

@deffn procedure strftime template time
Formats a time specification @var{time} using @var{template}.  @var{time}
is an object with time components in the form returned by @code{localtime}
or @code{gmtime}.  @var{template} is a string which can include formatting
specifications introduced by a @code{%} character.  The formatting of
month and day names is dependent on the current locale.  The value returned
is the formatted string.
@xref{Formatting Date and Time, , , libc, The GNU C Library Reference Manual}.)
@end deffn

@deffn procedure strptime template string
Performs the reverse action to @code{strftime}, parsing @var{string}
according to the specification supplied in @var{template}.  The
interpretation of month and day names is dependent on the current
locale.  The
value returned is a pair.  The CAR has an object with time components 
in the form returned by @code{localtime} or @code{gmtime},
but the time zone components
are not usefully set.
The CDR reports the number of characters from @var{string} which
were used for the conversion.
@end deffn

@deffn procedure get-internal-real-time
Returns the number of time units since the interpreter was started.
@end deffn

@deffn procedure get-internal-run-time
Returns the number of time units of processor time used by the interpreter.
Both "system" and "user" time
are included but subprocesses are not.
@end deffn

@defvar internal-time-units-per-second
The number of time units per second reported by @code{get-internal-real-time}
and @code{get-internal-run-time}.
@end defvar

@node processes
@section processes

@findex cd
@deffn procedure chdir path
Change the current working directory to @var{path}.
The return value is unspecified.
@end deffn

@findex pwd
@deffn procedure getcwd
Returns the name of the current working directory.
@end deffn

@deffn procedure umask [mode]
If @var{mode} is omitted, retuns a decimal number representing the current
file creation mask.  Otherwise the file creation mask is set to
@var{mode} and the previous value is returned.

E.g., @code{(umask #o022)} sets the mask to octal 22, decimal 18.
@end deffn

@deffn procedure getpid
Returns an integer representing the current process ID.
@end deffn

@deffn procedure getgroups
Returns a vector of integers representing the current supplimentary group IDs.
@end deffn

@deffn procedure getppid
Returns an integer representing the process ID of the parent process.
@end deffn

@deffn procedure getuid
Returns an integer representing the current real user ID.
@end deffn

@deffn procedure getgid
Returns an integer representing the current real group ID.
@end deffn

@deffn procedure geteuid
Returns an integer representing the current effective user ID.
If the system does not support effective IDs, then the real ID
is returned.  @code{(feature? 'EIDs)} reports whether the system
supports effective IDs.
@end deffn

@deffn procedure getegid
Returns an integer representing the current effective group ID.
If the system does not support effective IDs, then the real ID
is returned.  @code{(feature? 'EIDs)} reports whether the system
supports effective IDs.
@end deffn

@deffn procedure setuid id
Sets both the real and effective user IDs to the integer @var{id}, provided
the process has appropriate privileges.
The return value is unspecified.
@end deffn

@deffn procedure setgid id
Sets both the real and effective group IDs to the integer @var{id}, provided
the process has appropriate privileges.
The return value is unspecified.
@end deffn

@deffn procedure seteuid id
Sets the effective user ID to the integer @var{id}, provided the process
has appropriate privileges.  If effective IDs are not supported, the
real ID is set instead -- @code{(feature? 'EIDs)} reports whether the
system supports effective IDs.
The return value is unspecified.
@end deffn

@deffn procedure setegid id
Sets the effective group ID to the integer @var{id}, provided the process
has appropriate privileges.  If effective IDs are not supported, the
real ID is set instead -- @code{(feature? 'EIDs)} reports whether the
system supports effective IDs.
The return value is unspecified.
@end deffn

@deffn procedure getpgrp
Returns an integer representing the current process group ID.
This is the POSIX definition, not BSD.
@end deffn

@deffn procedure setpgid pid pgid
Move the process @var{pid} into the process group @var{pgid}.  @var{pid} or
@var{pgid} must be integers: they can be zero to indicate the ID of the
current process.
Fails on systems that do not support job control.
The return value is unspecified.
@end deffn

@deffn procedure setsid
Creates a new session.  The current process becomes the session leader
and is put in a new process group.  The process will be detached
from its controlling terminal if it has one.
The return value is an integer representing the new process group ID.
@end deffn

@deffn procedure waitpid pid [options]
This procedure collects status information from a child process which
has terminated or (optionally) stopped.  Normally it will
suspend the calling process until this can be done.  If more than one
child process is eligible then one will be chosen by the operating system.

The value of @var{pid} determines the behaviour:

@table @r
@item @var{pid} greater than 0
Request status information from the specified child process.
@item @var{pid} equal to -1 or WAIT_ANY
Request status information for any child process.
@item @var{pid} equal to 0 or WAIT_MYPGRP
Request status information for any child process in the current process
group.
@item @var{pid} less than -1
Request status information for any child process whose process group ID
is -@var{PID}.
@end table

The @var{options} argument, if supplied, should be the bitwise OR of the
values of zero or more of the following variables:

@defvar WNOHANG
Return immediately even if there are no child processes to be collected.
@end defvar

@defvar WUNTRACED
Report status information for stopped processes as well as terminated
processes.
@end defvar

The return value is a pair containing:

@enumerate
@item
The process ID of the child process, or 0 if @code{WNOHANG} was
specified and no process was collected.
@item
The integer status value.
@end enumerate
@end deffn

The following three
functions can be used to decode the process status code returned
by @code{waitpid}.

@deffn procedure status:exit-val status
Returns the exit status value, as would be
set if a process ended normally through a
call to @code{exit} or @code{_exit}, if any, otherwise @code{#f}.
@end deffn

@deffn procedure status:term-sig status
Returns the signal number which terminated the
process, if any, otherwise @code{#f}.
@end deffn

@deffn procedure status:stop-sig status
Returns the signal number which stopped the
process, if any, otherwise @code{#f}.
@end deffn

@deffn procedure primitive-exit [status]
Terminate the current process without unwinding the Scheme stack.
This is would typically be useful after a fork.  The exit status
is @var{status} if supplied, otherwise zero.
@end deffn

@deffn procedure execl path [arg] ...
Executes the file named by @var{path} as a new process image.
The remaining arguments are supplied to the process; from a C program
they are accessable as the @code{argv} argument to @code{main}.
Conventionally the first @var{arg} is the same as @var{path}.
All arguments must be strings.  

If @var{arg} is missing, @var{path} is executed with a null
argument list, which may have system-dependent side-effects.

This procedure is currently implemented using the @code{execv} system
call, but we call it @code{execl} because of its Scheme calling interface.
@end deffn

@deffn procedure execlp filename [arg] ...
Similar to @code{execl}, except that if
@var{filename} does not contain a slash
it will be sought for in the
directories listed in the @code{PATH} environment variable.
@end deffn

@deffn procedure primitive-fork
Creates a new "child" process by duplicating the current "parent" process.
In the child the return value is 0.  In the parent the return value is
the integer process ID of the child.

This procedure has been renamed from @code{fork} to avoid a naming conflict
with the scsh fork.
@end deffn

@deffn procedure getenv name
Looks up the string @var{name} in the current environment.  The return
value is @code{#f} unless a string of the form @code{NAME=VALUE} is
found, in which case the string @code{VALUE} is
returned.
@end deffn

@deffn procedure putenv string
Modifies the environment of the current process, which is
also the default environment inherited by child processes.

If @var{string} is of the form @code{NAME=VALUE} then it will be written
directly into the environment, replacing any existing variable with
name matching @code{NAME}.  If @var{string} does not contain an equal
sign, then any existing variable with name matching @var{string} will
be removed.

The return value is unspecified.
@end deffn

@deffn procedure environ [env]
If @var{env} is omitted, returns the current environment as a list of strings.
Otherwise it sets the current environment, which is also the
default environment for child processes, to the supplied list of strings.
Each member of @var{env} should be of the form
@code{NAME=VALUE} and values of @code{NAME} should not be duplicated.
If @var{env} is supplied then the return value is unspecified.
@end deffn

@deffn procedure nice incr
Increment the priority of the current process by @var{incr}.  A higher
priority value means that the process runs less often.
The return value is unspecified.
@end deffn

@node signals
@section signals

Procedures to raise, handle and wait for signals.

@deffn procedure kill pid sig

Sends a signal to the specified process or group of processes.

@var{pid} specifies the processes to which the signal is sent:

@table @r
@item @var{pid} greater than 0
The process whose identifier is @var{pid}.
@item @var{pid} equal to 0
All processes in the current process group.
@item @var{pid} less than -1
The process group whose identifier is -@var{pid}
@item @var{pid} equal to -1
If the process is privileged, all processes except for some special
system processes.  Otherwise, all processes with the current effective
user ID.
@end table

@var{sig} should be specified using a variable corresponding to
the Unix symbolic name, e.g.,

@defvar SIGHUP
Hang-up signal.
@end defvar

@defvar SIGINT
Interrupt signal.
@end defvar
@end deffn

@deffn procedure raise sig

Sends a specified signal @var{sig} to the current process, where
@var{sig} is as described for the kill procedure.
@end deffn

@deffn procedure sigaction signum [action] [flags]

Install or report the signal hander for a specified signal.

@var{signum} is the signal number, which can be specified using the value
of variables such as @code{SIGINT}.

If @var{action} is omitted, @code{sigaction} returns a pair: the
CAR is the current
signal hander, which will be either an integer with the value @code{SIG_DFL}
(default action) or @code{SIG_IGN} (ignore), or the Scheme procedure which
handles the signal, or @code{#f} if a non-Scheme procedure handles the
signal.  The CDR contains the current @code{sigaction} flags for the handler.

If @var{action} is provided, it is installed as the new handler for
@var{signum}.
@var{action} can be a Scheme procedure taking one argument, or the value of
@code{SIG_DFL} (default action) or @code{SIG_IGN} (ignore), or @code{#f}
to restore
whatever signal handler was installed before @code{sigaction} was first used.
Flags can optionally be specified for the new handler (@code{SA_RESTART} is
always used if the system provides it, so need not be specified.)  The
return value is a pair with information about the old handler as
described above.

This interface does not provide access to the "signal blocking"
facility.  Maybe this is not needed, since the thread support may
provide solutions to the problem of consistent access to data
structures.
@end deffn

@deffn procedure restore-signals
Return all signal handlers to the values they had before any call to
@code{sigaction} was made.  The return value is unspecified.
@end deffn

@deffn procedure alarm secs
Set a timer to raise a @code{SIGALRM} signal after the specified
number of seconds (an integer).  It's advisable to install a signal
handler for
@code{SIGALRM} beforehand, since the default action is to terminate
the process.

The return value indicates the time remaining for the previous alarm,
if any.  The new value replaces the previous alarm.  If there was
no previous alarm, the return value is zero.
@end deffn

@deffn procedure pause
Pause the current process (thread?) until a signal arrives whose
action is to either terminate the current process or invoke a
handler procedure.  The return value is unspecified.
@end deffn

@deffn procedure sleep secs
Wait for the given number of seconds (an integer) or until a signal
arrives.  The return value is zero if the time elapses or the number
of seconds remaining otherwise.
@end deffn

@node terminals and pseudo-terminals
@section terminals and pseudo-terminals

@deffn procedure isatty? port
Returns @code{#t} if @var{port} is using a serial
non-file device, otherwise @code{#f}.
@end deffn

@deffn procedure ttyname port
Returns a string with the name of the serial terminal device underlying
@var{port}.
@end deffn

@deffn procedure ctermid
Returns a string containing the file name of the controlling terminal
for the current process.
@end deffn

@deffn procedure tcgetpgrp port
Returns the process group ID of the foreground
process group associated with the terminal open on the file descriptor
underlying @var{port}.

If there is no foreground process group, the return value is a
number greater than 1 that does not match the process group ID
of any existing process group.  This can happen if all of the
processes in the job that was formerly the foreground job have
terminated, and no other job has yet been moved into the
foreground.
@end deffn

@deffn procedure tcsetpgrp port pgid
Set the foreground process group ID for the terminal used by the file
descriptor underlying @var{port} to the integer @var{pgid}.
The calling process
must be a member of the same session as @var{pgid} and must have the same
controlling terminal.  The return value is unspecified.
@end deffn

@node pipes
@section pipes

These procedures provide an interface to the @code{popen} and 
@code{pclose} system routines.

@findex popen
@deffn procedure open-pipe command modes
Executes the shell command @var{command} (a string) in a subprocess.
A pipe to the process is created and returned.  @var{modes} specifies
whether an input or output pipe to the process is created: it should 
be the value of @code{OPEN_READ} or @code{OPEN_WRITE}.
@end deffn

@deffn procedure open-input-pipe command
Equivalent to @code{(open-pipe command OPEN_READ)}.
@end deffn

@deffn procedure open-output-pipe command
Equivalent to @code{(open-pipe command OPEN_WRITE)}.
@end deffn

@findex pclose
@deffn procedure close-pipe port
Closes the pipe created by @code{open-pipe}, then waits for the process
to terminate and returns its status value, as for the @code{system}
procedure.

@code{close-port} can also be used to close a pipe, but doesn't return
the status.
@end deffn

@node networking
@section networking

@menu
* Networking Databases::        
* Network sockets::             
@end menu

@node Networking Databases
@subsection Networking Databases

This section describes procedures which convert internet addresses
and query various network databases.  Care should be taken when using
the database routines since they are not reentrant.

@deffn procedure inet-aton address
Converts a string containing an Internet host address in the traditional
dotted decimal notation into an integer.

@smalllisp
(inet-aton "127.0.0.1") @result{} 2130706433

@end smalllisp
@end deffn

@deffn procedure inet-ntoa number
Converts an integer Internet host address into a string with the
traditional dotted decimal representation.

@smalllisp
(inet-ntoa 2130706433) @result{} "127.0.0.1"
@end smalllisp
@end deffn

@deffn procedure inet-netof address
Returns the network number part of the given integer Internet address.

@smalllisp
(inet-netof 2130706433) @result{} 127
@end smalllisp
@end deffn

@deffn procedure inet-lnaof address
Returns the local-address-with-network part of the given Internet
address.

@smalllisp
(inet-lnaof 2130706433) @result{} 1
@end smalllisp
@end deffn

@deffn procedure inet-makeaddr net lna
Makes an Internet host address by combining the network number @var{net}
with the local-address-within-network number @var{lna}.

@smalllisp
(inet-makeaddr 127 1) @result{} 2130706433
@end smalllisp
@end deffn

The following functions accept an object representing a host on a network
and return a selected component.

@table @code
@item hostent:name
The "official" host name.
@item hostent:aliases
A list of aliases for the host.
@item hostent:addrtype
The type of address, equal to the value of @code{AF_INET} for Internet
addresses.
@item hostent:length
The length of each address in bytes.
@item hostent:addr-list
The list of network addresses.
@end table

@deffn procedure gethostbyname name
Lookup @var{name} (a string) in the host database.
@end deffn

@deffn procedure gethostbyaddr address
Lookup @var{address} (an integer) in the host database.
@end deffn

@deffn procedure sethostent
Initializes a stream used by @code{gethostent} to read from the host database.
The next use of @code{gethostent} will return the first entry.  The
return value is unspecified.
@end deffn

@deffn procedure gethostent
Return the next entry from the host database.
@end deffn

@deffn procedure endhostent
Close the stream used by @code{gethostent}.  The return value is unspecified.
@end deffn

The following functions accept an object representing a network
and return a selected component.

@table @code
@item netent:name
The "official" network name.
@item netent:aliases
A list of aliases for the network.
@item netent:addrtype
The type of address, equal to the value of @code{AF_INET} for Internet
addresses.
@item netent:net
The network number.
@end table

@deffn procedure getnetbyname name
Lookup @var{name} (a string) in the network database.
@end deffn

@deffn procedure getnetbyaddr address
Lookup @var{address} (an integer) in the network database.
@end deffn

@deffn procedure setnetent
Initializes a stream used by @code{getnetent} to read from the network
database.
The next use of @code{getnetent} will return the first entry.  The
return value is unspecified.
@end deffn

@deffn procedure getnetent
Return the next entry from the network database.
@end deffn

@deffn procedure endnetent
Close the stream used by @code{getnetent}.  The return value is unspecified.
@end deffn

The following functions accept an object representing a protocol
and return a selected component.

@table @code
@item protoent:name
The "official" protocol name.
@item protoent:aliases
A list of aliases for the protocol.
@item protoent:proto
The protocol number.
@end table

@deffn procedure getprotobyname name
Lookup @var{name} (a string) in the protocol database.
@end deffn

@deffn procedure getprotobynumber number
Lookup a protocol number in the network database.
@end deffn

@deffn procedure setprotoent
Initializes a stream used by @code{getprotoent} to read from the protocol
database.
The next use of @code{getprotoent} will return the first entry.  The
return value is unspecified.
@end deffn

@deffn procedure getprotoent
Return the next entry from the protocol database.
@end deffn

@deffn procedure endprotoent
Close the stream used by @code{getprotoent}.  The return value is unspecified.
@end deffn

The following functions accept an object representing a network service
and return a selected component.

@table @code
@item servent:name
The "official" name of the network service.
@item servent:aliases
A list of aliases for the network service. 
@item servent:port
The Internet port used by the service.
@item servent:proto
The protocol used by the service.  A service may be listed multiple
times in the database with different protocols.
@end table

@deffn procedure getservbyname name protocol
Lookup an entry in the service database with @var{name} (a string) and
using @var{protocol} (a string).
@end deffn

@deffn procedure getservbyport port protocol
Lookup an entry in the service database using @var{port} (a number) and
@var{protocol} (a string).
@end deffn

@deffn procedure setservent
Initializes a stream used by @code{getservent} to read from the services
database.
The next use of @code{getservent} will return the first entry.  The
return value is unspecified.
@end deffn

@deffn procedure getservent
Return the next entry from the services database.
@end deffn

@deffn procedure endservent
Close the stream used by @code{getservent}.  The return value is unspecified.
@end deffn

@node Network sockets
@subsection Network sockets

Socket ports can be created using @code{socket} and @code{socketpair}. 
The ports are initially unbuffered, to
makes reading and writing to the same port more reliable.  Buffered
ports can be obtained with
@code{duplicate-port}, @xref{ports vs. file descriptors}.

These procedures convert Internet addresses
and port values between "host" order and "network" order as required.  The
arguments and return values should be in "host" order.

@deffn procedure socket family style protocol
Returns a new socket port of the type specified by @var{family}, @var{style}
and @var{protocol}.  All three parameters are integers.  Typical values
for @var{family} are the values of @code{AF_UNIX}
and @code{AF_INET}.  Typical values for @var{style} are
the values of @code{SOCK_STREAM}, @code{SOCK_DGRAM} and @code{SOCK_RAW}.

@var{protocol} can be obtained from a protocol name using
@code{getprotobyname}.  A value of
zero specifies the default protocol, which is usually right.

A single socket port cannot by used for communication until
it has been connected to another socket.
@end deffn

@deffn procedure socketpair family style protocol
Returns a pair of connected (but unnamed) socket ports of the type specified
by @var{family}, @var{style} and @var{protocol}.
Many systems support only
socket pairs of the @code{AF_UNIX} family.  Zero is likely to be
the only meaningful value for @var{protocol}.
@end deffn

@deffn procedure getsockopt socket level optname
Returns the value of a particular socket option for the socket
port @var{socket}.  @var{level} is an integer code for type of option
being requested, e.g., @code{SOL_SOCKET} for socket-level options.
@var{optname} is an
integer code for the option required and should be specified using one of
the symbols @code{SO_DEBUG}, @code{SO_REUSEADDR} etc.

The returned value is typically an integer but @code{SO_LINGER} returns a
pair of integers.
@end deffn

@deffn procedure setsockopt socket level optname value
Sets the value of a particular socket option for the socket
port @var{socket}.  @var{level} is an integer code for type of option
being set, e.g., @code{SOL_SOCKET} for socket-level options.
@var{optname} is an
integer code for the option to set and should be specified using one of
the symbols @code{SO_DEBUG}, @code{SO_REUSEADDR} etc.
@var{value} is the value to which the option should be set.  For
most options this must be an integer, but for @code{SO_LINGER} it must
be a pair.

The return value is unspecified.
@end deffn

@deffn procedure shutdown socket how
Sockets can be closed simply by using @code{close-port}. The
@code{shutdown} procedure allows reception or tranmission on a
connection to be shut down individually, according to the parameter
@var{how}:

@table @asis
@item 0
Stop receiving data for this socket.  If further data arrives,  reject it.
@item 1
Stop trying to transmit data from this socket.  Discard any
data waiting to be sent.  Stop looking for acknowledgement of
data already sent; don't retransmit it if it is lost.
@item 2
Stop both reception and transmission.
@end table

The return value is unspecified.
@end deffn

@deffn procedure connect socket family address [arg ...]
Initiates a connection from @var{socket} to the address
specified by @var{address} and possibly @var{arg @dots{}}.  The format
required for @var{address}
and @var{arg} @dots{} depends on the family of the socket.

For a socket of family @code{AF_UNIX},
only @code{address} is specified and must be a string with the
filename where the socket is to be created.

For a socket of family @code{AF_INET},
@code{address} must be an integer Internet host address and @var{arg} @dots{}
must be a single integer port number.

The return value is unspecified.
@end deffn

@deffn procedure bind socket family address arg ...
Assigns an address to the socket port @var{socket}.
Generally this only needs to be done for server sockets,
so they know where to look for incoming connections.  A socket
without an address will be assigned one automatically when it
starts communicating.

The format of @var{address} and @var{ARG} @dots{} depends on the family
of the socket.

For a socket of family @code{AF_UNIX}, only @var{address}
is specified and must 
be a string with the filename where the socket is to be created.

For a socket of family @code{AF_INET}, @var{address} must be an integer
Internet host address and @var{arg} @dots{} must be a single integer
port number.

The values of the following variables can also be used for @var{address}:

@defvar INADDR_ANY
Allow connections from any address.
@end defvar

@defvar INADDR_LOOPBACK
The address of the local host using the loopback device.
@end defvar

@defvar INADDR_BROADCAST
The broadcast address on the local network.
@end defvar

@defvar INADDR_NONE
No address.
@end defvar

The return value is unspecified.
@end deffn

@deffn procedure listen socket backlog
This procedure enables @var{socket} to accept connection
requests.  @var{backlog} is an integer specifying
the maximum length of the queue for pending connections.
If the queue fills, new clients will fail to connect until the
server calls @code{accept} to accept a connection from the queue.

The return value is unspecified.
@end deffn

@deffn procedure accept socket
Accepts a connection on a bound, listening socket @var{socket}.  If there
are no pending connections in the queue, it waits until
one is available unless the non-blocking option has been set on the
socket.

The return value is a
pair in which the CAR is a new socket port for the connection and
the CDR is an object with address information about the client which
initiated the connection.

If the address is not available then the CDR will be an empty vector.

@var{socket} does not become part of the
connection and will continue to accept new requests.
@end deffn

The following functions take a socket address object, as returned
by @code{accept} and other procedures, and return a selected component.

@table @code
@item sockaddr:fam
The socket family, typically equal to the value of @code{AF_UNIX} or
@code{AF_INET}.
@item sockaddr:path
If the socket family is @code{AF_UNIX}, returns the path of the
filename the socket is based on.
@item sockaddr:addr
If the socket family is @code{AF_INET}, returns the Internet host
address.
@item sockaddr:port
If the socket family is @code{AF_INET}, returns the Internet port
number.
@end table

@deffn procedure getsockname socket
Returns the address of @var{socket}, in the same form as the object
returned by @code{accept}.  On many systems the address of a socket
in the @code{AF_FILE} namespace cannot be read.
@end deffn

@deffn procedure getpeername socket
Returns the address of the socket that the socket @var{socket} is connected to,
in the same form as the object
returned by @code{accept}.  On many systems the address of a socket
in the @code{AF_FILE} namespace cannot be read.
@end deffn

@deffn procedure recv! socket buf [flags]
Receives data from the socket port @var{socket}.  @var{socket} must already
be bound to the address from which data is to be received.
@var{buf} is a string into which
the data will be written.  The size of @var{buf} limits the amount of
data which can be received: in the case of packet
protocols, if a packet larger than this limit is encountered then some data
will be irrevocably lost.

The optional @var{flags} argument is a value or
bitwise OR of MSG_OOB, MSG_PEEK, MSG_DONTROUTE etc.

The value returned is the number of bytes read from the socket.

Note that the data is read directly from the socket file descriptor:
any unread buffered port data is ignored.
@end deffn

@deffn procedure send socket message [flags]
Transmits the string @var{message} on the socket port @var{socket}. 
@var{socket} must already be bound to a destination address.  The
value returned is the number of bytes transmitted -- it's possible for
this to be less than the length of @var{message} if the socket is
set to be non-blocking.  The optional @var{flags} argument is a value or
bitwise OR of MSG_OOB, MSG_PEEK, MSG_DONTROUTE etc.

Note that the data is written directly to the socket file descriptor:
any unflushed buffered port data is ignored.
@end deffn

@deffn procedure recvfrom! socket buf [flags] [start] [end]
Returns data from the socket port @var{socket} and also information about
where the data was received from.  @var{socket} must already
be bound to the address from which data is to be received.
@code{buf}, is a string into which
the data will be written.  The size of @var{buf} limits the amount of
data which can be received: in the case of packet
protocols, if a packet larger than this limit is encountered then some data
will be irrevocably lost.

The optional @var{flags} argument is a value or
bitwise OR of MSG_OOB, MSG_PEEK, MSG_DONTROUTE etc.

The value returned is a pair: the CAR is the number of bytes read from
the socket and the CDR an address object in the same form as returned by
@code{accept}.

The @var{start} and @var{end} arguments specify a substring of @var{buf}
to which the data should be written.

Note that the data is read directly from the socket file descriptor:
any unread buffered port data is ignored.
@end deffn

@deffn procedure sendto socket message family address arg ... [flags]
Transmits the string @var{message} on the socket port @var{socket}.  The
destination address is specified using the @var{family}, @var{address} and
@var{arg} arguments, in a similar way to the @code{connect}
procedure.  The
value returned is the number of bytes transmitted -- it's possible for
this to be less than the length of @var{message} if the socket is
set to be non-blocking.  The optional @var{flags} argument is a value or
bitwise OR of MSG_OOB, MSG_PEEK, MSG_DONTROUTE etc.

Note that the data is written directly to the socket file descriptor:
any unflushed buffered port data is ignored.
@end deffn

@node system identification (uname)
@section system identification (uname)

@deffn procedure uname
Returns an object with some information about the computer system the
program is running on.
@end deffn

The following procedures accept an object as returned by @code{uname}
and return a selected component.

@table @code
@item utsname:sysname
The name of the operating system.
@item utsname:nodename
The network name of the computer.
@item utsname:release
The current release level of the operating system implementation.
@item utsname:version
The current version level within the release of the operating system.
@item utsname:machine
A description of the hardware.
@end table

@node locales (setlocale)
@section locales (setlocale)

@deffn procedure setlocale category [locale]
If @var{locale} is omitted, returns the current value of the specified
locale category 
as a system-dependent string.
@var{category} should be specified using the values @code{LC_COLLATE},
@code{LC_ALL} etc.

Otherwise the specified locale category is set to
the string @var{locale}
and the new value is returned as a system-dependent string.  If @var{locale}
is an empty string, the locale will be set using envirionment variables.
@end deffn

@node expect
@section expect

The macros in this section are made available with:

@smalllisp
(use-modules (ice-9 expect))
@end smalllisp

@code{expect} is a macro for selecting actions based on the output from
a port.  The name comes from a tool of similar functionality by Don Libes.
Actions can be taken when a particular string is matched, when a timeout
occurs, or when end-of-file is seen on the port.  The @code{expect} macro
is described below; @code{expect-strings} is a front-end to @code{expect}
based on regexec (see the regular expression documentation).

@defmac expect-strings clause @dots{}
By default, @code{expect-strings} will read from the current input port.
The first term in each clause consists of an expression evaluating to
a string pattern (regular expression).  As characters
are read one-by-one from the port, they are accumulated in a buffer string
which is matched against each of the patterns.  When a
pattern matches, the remaining expression(s) in
the clause are evaluated and the value of the last is returned.  For example:

@smalllisp
(with-input-from-file "/etc/passwd"
  (lambda ()
    (expect-strings
      ("^nobody" (display "Got a nobody user.\n")
                 (display "That's no problem.\n"))
      ("^daemon" (display "Got a daemon user.\n")))))
@end smalllisp

The regular expression is compiled with the @code{REG_NEWLINE} flag, so
that the ^ and $ anchors will match at any newline, not just at the start
and end of the string.

There are two other ways to write a clause:

The expression(s) to evaluate
can be omitted, in which case the result of the regular expression match
(converted to strings, as obtained from regexec with match-pick set to "")
will be returned if the pattern matches.

The symbol @code{=>} can be used to indicate that the expression is a
procedure which will accept the result of a successful regular expression
match.  E.g.,

@smalllisp
("^daemon" => write)
("^d\\(aemon\\)" => (lambda args (for-each write args)))
("^da\\(em\\)on" => (lambda (all sub)
                         (write all) (newline)
                         (write sub) (newline)))
@end smalllisp

The order of the substrings corresponds to the order in which the
opening brackets occur.

A number of variables can be used to control the behaviour
of @code{expect} (and @code{expect-strings}).
By default they are all bound at the top level to
the value @code{#f}, which produces the default behaviour.
They can be redefined at the
top level or locally bound in a form enclosing the expect expression.

@table @code
@item expect-port
A port to read characters from, instead of the current input port.
@item expect-timeout
@code{expect} will terminate after this number of
seconds, returning @code{#f} or the value returned by expect-timeout-proc.
@item expect-timeout-proc
A procedure called if timeout occurs.  The procedure takes a single argument:
the accumulated string.
@item expect-eof-proc
A procedure called if end-of-file is detected on the input port.  The
procedure takes a single argument: the accumulated string.
@item expect-char-proc
A procedure to be called every time a character is read from the
port.  The procedure takes a single argument: the character which was read.
@end table

Here's an example using all of the variables:

@smalllisp
(let ((expect-port (open-input-file "/etc/passwd"))
      (expect-timeout 1)
      (expect-timeout-proc
        (lambda (s) (display "Times up!\n")))
      (expect-eof-proc
        (lambda (s) (display "Reached the end of the file!\n")))
      (expect-char-proc display))
   (expect-strings
     ("^nobody"  (display "Got a nobody user\n"))))
@end smalllisp
@end defmac

@defmac expect clause @dots{}
@code{expect} is used in the same way as @code{expect-strings},
but tests are specified not as patterns, but as procedures.  The
procedures are called in turn after each character is read from the
port, with the value of the accumulated string as the argument.  The
test is successful if the procedure returns a non-false value.

If the @code{=>} syntax is used, then if the test succeeds it must return
a list containing the arguments to be provided to the corresponding
expression.

In the following example, a string will only be matched at the beginning
of the file:

@smalllisp
(let ((expect-port (open-input-file "/etc/passwd")))
  (expect
     ((lambda (s) (string=? s "fnord!"))
        (display "Got a nobody user!\n"))))
@end smalllisp

The control variables described for @code{expect-strings} can also
be used with @code{expect}.
@end defmac

@page
@node The Scheme shell (scsh)
@chapter The Scheme shell (scsh)

An incomplete port of the Scheme shell (scsh) 0.5.1 is available for
Guile.  The idea is to allow Scheme code using scsh interfaces to be run
inside the Guile interpreter.

For information about scsh on the Web see
@url{http://www-swiss.ai.mit.edu/scsh/scsh.html}.
The original scsh is available by ftp from
@url{ftp://swiss-ftp.ai.mit.edu:/pub/su}.

The scsh code is distributed as a separate module, guile-scsh,
which must be installed somewhere in Guile's load path before
it can be used.  This is similar to the installation
of slib (you may want to install that first, since it's needed before
scsh can run in Guile: see @ref{SLIB} for details).

This port of scsh does not currently use the Guile module system, but
can be initialized with:

@smalllisp
(load-from-path "scsh/init")
@end smalllisp

@page
@node Tcl/Tk Interface
@chapter Tcl/Tk Interface


@page
@node Module Internals
@chapter Module Internals

@menu
* First-class Variables::       
* First-class Modules::         
@end menu

@node First-class Variables
@section First-class Variables

@node First-class Modules
@section First-class Modules


@page
@node Internal Debugging Interface
@chapter Internal Debugging Interface

--- The name of this chapter needs to clearly distinguish it
    from the appendix describing the debugger UI.  The intro
    should have a pointer to the UI appendix.
