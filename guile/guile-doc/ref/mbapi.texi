@node Working With Multibyte Strings in C
@chapter Working With Multibyte Strings in C

Guile allows strings to contain characters drawn from a wide variety of
languages, including many Asian, Eastern European, and Middle Eastern
languages, in a uniform and unrestricted way.  The typical string
representation --- an array of @sc{ASCII} characters --- is not
sufficient, since Guile strings may contain characters not present in
@sc{ASCII}.

Instead, Guile uses a very large character set, and encodes each
character as a sequence of one or more bytes.  We call this a
@dfn{multibyte} encoding.  This encoding is used for all strings, symbol
names, error messages, and so on.

Since variable-width encodings are clumsier to work with than simple
fixed-width encodings, Guile provides a set of standard macros and
functions for manipulating multibyte text.  Furthermore, Guile makes
some promises about the encoding which you can use in writing your own
text processing code.

While we discuss properties of Guile's encoding, and provide functions
to operate on its character set, we do not actually specify either the
character set or encoding here.  This is because we expect both of them
to change in the future; currently, our encoding that used by Emacs
20.4, but we hope to change Guile (and Emacs as well) to use Unicode and
UTF-8, with some extensions.

@menu
* Multibyte String Terminology::  
* Promised Properties of Guile's Multibyte Encoding::  
* Functions for Operating on Multibyte Text::  
* Exchanging Text With The Outside World::  
* Multibyte Character Tables::  
* Multibyte Character Categories::  
* Why Guile Doesn't Use a Fixed-Width Encoding::  
@end menu


@node Multibyte String Terminology, Promised Properties of Guile's Multibyte Encoding, Working With Multibyte Strings in C, Working With Multibyte Strings in C
@section Multibyte String Terminology 

In the descriptions which follow, we make the following definitions:
@table @dfn

@item byte
A @dfn{byte} is a number between 0 and 255.  It has no inherent textual
interpretation.  So 65 is a byte, not a character.

@item character
A @dfn{character} is a unit of text.  It has no inherent numeric value.
@samp{A} and @samp{.} are characters, not bytes.  (This is not the C
language's definition of @dfn{character}; in this chapter, we will
always use the phrase ``the C language's @code{char} type'' when that's
what we mean.)

@item character set
A @dfn{character set} is an invertible mapping between a given set of
characters and numbers.  @sc{ASCII} is a character set assigning
characters to the numbers 0 through 127.  It maps @samp{A} onto the
number 65, and @samp{.} onto 46.

Note that a character set maps characters onto numbers, @emph{not
necessarily} onto bytes.  For example, the Unicode character set maps
the Greek lower-case @samp{alpha} character onto the number 945, which
is not a byte.

@item encoding
An encoding maps numbers onto sequences of bytes.  For example, the
UTF-8 encoding, defined in the Unicode Standard, would map the number
945 onto the sequence of bytes @samp{206 177}.  When using the @sc{ASCII}
character set, every number assigned is also a byte, so there is an
obvious trivial encoding for @sc{ASCII} in bytes.

@end table

Thus, to turn a character into a sequence of bytes, you need a character
set to assign a number to that character, and then an encoding to turn
that number into a sequence of bytes.

Likewise, to interpret a sequence of bytes as a sequence of characters,
you use an encoding to extract a sequence of numbers from the bytes, and
then a character set to turn the numbers into characters.

Errors can occur while carrying out either of these processes.  For
example, under a particular encoding, a given string of bytes might not
correspond to any number.  For example, the byte sequence @samp{128 128}
is not a valid encoding of any number under UTF-8.

Having carefully defined our terminology, we now proceed to abuse it.

We will sometimes use the word @dfn{character} to refer to the number
assigned to a character by a character set, in contexts where the
character set is obvious.

Sometimes there is a close association between a particular encoding and
a particular character set.  Thus, we may sometimes refer to the
character set and encoding together as an @dfn{encoding}.


@node Promised Properties of Guile's Multibyte Encoding, Functions for Operating on Multibyte Text, Multibyte String Terminology, Working With Multibyte Strings in C
@section Promised Properties of Guile's Multibyte Encoding

Internally, Guile uses a single encoding for all text.  It is correct to
write code which assumes that a string or symbol name uses this
encoding; code which makes this assumption will be portable to all
future versions of Guile, as far as we know.

Guile's encoding has the following properties, which should make it
easier to write code which operates on it.

@b{Every @sc{ASCII} character is encoded as a single byte from 0 to 127, in
the obvious way.}  This means that a standard C string containing only
@sc{ASCII} characters is a valid Guile string (except for the terminator;
Guile strings store the length explicitly, so they can contain null
characters).

@b{The encodings of non-@sc{ASCII} characters use only bytes between 128
and 255.}  That is, when we turn a non-@sc{ASCII} character into a
series of bytes, none of those bytes can ever be mistaken for the
encoding of @sc{ASCII} character.  This means that you can search a
Guile string for an @sc{ASCII} character using the ordinary
@code{memchr} function.  By extension, you can search for an @sc{ASCII}
substring in a Guile string using the ordinary @code{strstr} functions.

@b{No character encoding is a subsequence of any other character
encoding.}  (This is just a stronger version of the previous promise.)
This means that you can search for occurrences of one Guile string
within another Guile string just as if they were raw byte strings.  You
can use the stock @code{memmem} function for such searches.

@b{You can always determine the full length of a character's encoding
from its first byte.}  Guile provides a table mapping initial bytes onto
character lengths.  Given the first rule, you can see that entries 0 to
127 of this table must all be 1.

@b{Given an arbitrary byte position in a Guile string, you can always
find the beginning and end of the character containing that byte without
scanning too far in either direction.}  This means that, if you are sure
a byte sequence is a valid encoding of a character sequence, you can
find character boundaries without keeping track of the beginning and
ending of the overall string.  This promise relies on the fact that, in
addition to storing the string's length explicitly, Guile always either
terminates the string's storage with a zero byte, or shares it with
another string which is terminated this way.

@node Functions for Operating on Multibyte Text, Exchanging Text With The Outside World, Promised Properties of Guile's Multibyte Encoding, Working With Multibyte Strings in C
@section Functions for Operating on Multibyte Text

Guile provides the following functions, variables, and types for working
with multibyte text.  Guile uses the C type @code{unsigned char *} to
refer to text encoded with Guile's encoding.

@menu
* Basic Multibyte Character Processing::  
* Guile Character Properties::  
@end menu

@node Basic Multibyte Character Processing, Guile Character Properties, Functions for Operating on Multibyte Text, Functions for Operating on Multibyte Text
@subsection Basic Multibyte Character Processing

@deftp {Libguile Type} scm_char_t
This is a signed integral type large enough to hold the number assigned
to any character in Guile's character set.  All character numbers are
positive.
@end deftp

@deftypefn {Libguile Function} scm_char_t scm_char_get (unsigned char *@var{p})
Return the character whose encoding starts at @var{p}, or -1 if @var{p}
does not point to a valid character encoding.

Note that @code{scm_char_get} may be implemented as a macro, and its
argument may be evaluated several times.
@end deftypefn

@deftypefn {Libguile Function} int scm_char_put (scm_char_t @var{c}, unsigned char *@var{p})
Place the encoded form of the Guile character @var{c} at @var{p}, and
return its length in bytes.
@end deftypefn

@deftypefn {Libguile Function} scm_char_t scm_char_walk (unsigned char **@var{pp})
Return the character whose encoding starts at @code{*@var{pp}}, and
advance @code{*@var{pp}} to the start of the next character.  Return -1
if @code{*@var{pp}} does not point to a valid character encoding.
@end deftypefn

@deftypefn {Libguile Function} int scm_char_len (scm_char_t @var{c})
Return the length of the encoding of the character @var{c}, in bytes.

Note that @code{scm_char_len} may be implemented as a macro, and it may
evaluate its argument several times.
@end deftypefn

@deftypefn {Libguile Function} int scm_char_leading_len (unsigned char @var{b})
If @var{b} is the first byte of a character's encoding, return the full
length of the character's encoding, in bytes.

Note that @code{scm_char_leading_len} may be implemented as a macro, and
it may evaluate its argument several times.
@end deftypefn

@deftypefn {Libguile Function} {unsigned char *} scm_char_floor (unsigned char *@var{p})
``Round'' @var{p} to the previous character boundary.  That is, if
@var{p} points to the middle of the encoding of a Guile character,
return a pointer to the first byte of the encoding.  If @var{p} points
to the start of the encoding of a Guile character, return @var{p}
unchanged.

Note that it is not friendly for Scheme functions to silently correct
invalid byte offsets.  Such offsets almost always indicate a programming
error, and Scheme functions should signal a
@code{text:invalid-byte-offset} error as soon as they detect an invalid
offset.  @xref{Multibyte Text Processing Errors}.
@end deftypefn

@deftypefn {libguile Function} {unsigned char *} scm_char_ceiling (unsigned char *@var{p})
``Round'' @var{p} to the next character boundary.  That is, if @var{p}
points to the middle of the encoding of a Guile character, return a
pointer to the first byte of the encoding of the next character.  If
@var{p} points to the start of the encoding of a Guile character, return
@var{p} unchanged.

Note that it is not friendly for Scheme functions to silently correct
invalid byte offsets.  Such offsets almost always indicate a programming
error, and Scheme functions should signal a
@code{text:invalid-byte-offset} error as soon as they detect an invalid
offset.  @xref{Multibyte Text Processing Errors}.
@end deftypefn

@deftypefn {Libguile Function} {unsigned char *} scm_char_prev (unsigned char *@var{p})
If @var{p} points to the middle of the encoding of a Guile character,
return a pointer to the first byte of the encoding.  If @var{p} points
to the start of the encoding of a Guile character, return the start of
the previous character's encoding.

This is like @code{scm_char_floor}, but the returned pointer will always
be before @var{p}.  If you use this function to drive an iteration, it
guarantees backward progress.
@end deftypefn

@deftypefn {Libguile Function} {unsigned char *} scm_char_next (unsigned char *@var{p})
If @var{p} points to the encoding of a Guile character, return a pointer
to the first byte of the encoding of the next character.

This is like @code{scm_char_ceiling}, but the returned pointer will always
be after @var{p}.  If you use this function to drive an iteration, it
guarantees forward progress.
@end deftypefn

@deftypefn {Libguile Function} int scm_char_count (unsigned char *@var{p}, int @var{n})
Return the number of Guile characters encoded by the @var{n} bytes at
@var{p}.  Return -1 if the sequence is not a concatenation of valid
character encodings.
@end deftypefn

@deftypefn {Libguile Function} unsigned char *scm_char_index (unsigned char *@var{base}, int @var{len}, int @var{i})
Assuming that the @var{len} bytes starting at @var{base} are a
concatenation of valid character encodings, return the address of the
start of the @var{i}'th character encoding in the sequence.

This function scans the sequence from the beginning to find the
@var{i}'th character, and will generally require time proportional to
the distance from @var{base} to the returned address.

If the sequence contains invalid character encodings before the
@var{i}'th character, treat each byte which is not part of a valid
character encoding as a single character, for purposes of the count.
@end deftypefn

It is common to process the characters in a string from left to right.
If you fetch each character using @code{scm_char_index}, the indexing
portion of your loop will run in time quadratic in the length of the
string.  To avoid quadratic behavior in such situations, you can use a
@code{scm_char_cache} structure and the @code{scm_char_cached_index}
function.

@deftp {Libguile Type} struct scm_char_cache
This structure holds information that allows a string indexing operation
to remember the result of a previous scan of the string.  It has the
following members:
@table @code

@item character
An index, in characters, into the string.

@item byte
The index, in bytes, of the start of that character.

@end table

In other words, @var{byte} is the byte offset of the @var{character}'th
character of the string.

Both elements of a @code{struct scm_char_cache} structure must be
initialized to zero before its first use, or if the string has changed.
@end deftp

@deftypefn {Libguile Function} unsigned char *scm_char_cached_index
(unsigned char *@var{base}, int @var{len}, int @var{i}, struct scm_char_cache *@var{cache})
This function is identical to @code{scm_char_index}, except that it may
consult and update *@var{cache} in order to avoid scanning the string
from the beginning.

Using @code{scm_char_cached_index}, you can scan a string from left to
right in time linear in the length of the string.
@end deftypefn


Guile also provides functions to convert between an encoded sequence of
characters, and an array of @code{scm_char_t} objects.

@deftypefn {Libguile Function} scm_char_t *scm_char_multibyte_to_fixed (unsigned char *@var{base}, int @var{len}, int *@var{result_len})
Convert the variable-width text in the @var{len} bytes at @var{base}
to an array of @code{scm_char_t} values.  Return a pointer to the array,
and set @code{*@var{result_len}} to the number of elements it contains.
The returned array is allocated with @code{malloc}, and it is the
caller's responsibility to free it.

[[When we specify the conversion functions, we will probably have an
argument that says how they should react to invalid or out-of-charset
sequences.  This function should take another argument of that type.]]
@end deftypefn

@deftypefn {Libguile Function} unsigned char
*scm_char_fixed_to_multibyte (scm_char_t *@var{fixed}, int @var{len}, int *@var{result_len})
Convert the array of @code{scm_char_t} values to a sequence of
variable-width character encodings.  Return a pointer to the array of
bytes, and set @code{*@var{result_len}} to its length, in bytes.  The
returned byte sequence is allocated with @code{malloc}; it is the
caller's responsibility to free it.
@end deftypefn


@node Guile Character Properties,  , Basic Multibyte Character Processing, Functions for Operating on Multibyte Text
@subsection Guile Character Properties

These functions give information about the nature of a given Guile
character.  [[This section is incomplete.]]

@deftypefn {Libguile Function} scm_char_isalnum   (scm_char_t @var{c})
Return non-zero iff @var{c} is an alphabetic or numeric character.
@end deftypefn

@deftypefn {Libguile Function} scm_char_isalpha   (scm_char_t @var{c})
Return non-zero iff @var{c} is an alphabetic character.
@end deftypefn

@deftypefn {Libguile Function} scm_char_iscntrl   (scm_char_t @var{c})
Return non-zero iff @var{c} is a control character.
@end deftypefn

@deftypefn {Libguile Function} scm_char_isdigit   (scm_char_t @var{c})
Return non-zero iff @var{c} is a digit.
@end deftypefn

@deftypefn {Libguile Function} scm_char_isgraph   (scm_char_t @var{c})
Return non-zero iff @var{c} is a visible character.
@end deftypefn

@deftypefn {Libguile Function} scm_char_islower   (scm_char_t @var{c})
Return non-zero iff @var{c} is 
@end deftypefn

@deftypefn {Libguile Function} scm_char_isprint   (scm_char_t @var{c})
Return non-zero iff @var{c} is 
@end deftypefn

@deftypefn {Libguile Function} scm_char_ispunct   (scm_char_t @var{c})
Return non-zero iff @var{c} is 
@end deftypefn

@deftypefn {Libguile Function} scm_char_isspace   (scm_char_t @var{c})
Return non-zero iff @var{c} is 
@end deftypefn

@deftypefn {Libguile Function} scm_char_isupper   (scm_char_t @var{c})
Return non-zero iff @var{c} is 
@end deftypefn

@deftypefn {Libguile Function} scm_char_isxdigit  (scm_char_t @var{c})
Return non-zero iff @var{c} is 
@end deftypefn

@deftypefn {Libguile Function} scm_char_istitle   (scm_char_t @var{c})
Return non-zero iff @var{c} is 
@end deftypefn

@deftypefn {Libguile Function} scm_char_isdefined (scm_char_t @var{c})
Return non-zero iff @var{c} is 
@end deftypefn


[[More things to imitate, from libunicode:
@example
/* More <ctype.h> functions.  These convert between the three cases.
   See the Unicode book to understand title case.  */
unicode_char_t unicode_toupper (unicode_char_t c);
unicode_char_t unicode_tolower (unicode_char_t c);
unicode_char_t unicode_totitle (unicode_char_t c);

/* If C is a digit (according to `unicode_isdigit'), then return its
   numeric value.  Otherwise return -1.  */
int unicode_digit_value (unicode_char_t c);

/* If C is a hex digit (according to `unicode_isxdigit'), then return
   its numeric value.  Otherwise return -1.  */
int unicode_xdigit_value (unicode_char_t c);
@end example
]]

@node Exchanging Text With The Outside World, Multibyte Character Tables, Functions for Operating on Multibyte Text, Working With Multibyte Strings in C
@section Exchanging Text With The Outside World

[[This will document conversion functions.  We'll probably imitate
iconv.]]
[[conversions between Guile text and wchar_t arrays?]]


@node Multibyte Character Tables, Multibyte Character Categories, Exchanging Text With The Outside World, Working With Multibyte Strings in C
@section Multibyte Character Tables

[[This will describe an ADT mapping characters onto Guile values.]]


@node Multibyte Character Categories, Why Guile Doesn't Use a Fixed-Width Encoding, Multibyte Character Tables, Working With Multibyte Strings in C
@section Multibyte Character Categories

[[This will describe an ADT representing subsets of the Guile character
set.]]


@node Multibyte Text Processing Errors
@section Multibyte Text Processing Errors

This section describes the error conditions which the functions in this
section might signal.

@deffn Condition text:invalid-byte-offset func message args object offset
By calling @var{func}, the program attempted to access a character at
byte offset @var{offset} in the Guile object @var{object}, but
@var{offset} is not the start of a character in @var{string}.

Typically, @var{object} is a string or symbol.  If the function signalling
the error cannot find the Guile object that contains the text it is
inspecting, it should use @code{#f} for @var{object}.
@end deffn

[[invalid encoding error]]

@node Why Guile Doesn't Use a Fixed-Width Encoding,  , Multibyte Character Categories, Working With Multibyte Strings in C
@section Why Guile Doesn't Use a Fixed-Width Encoding

Multibyte encodings are clumsier to work with than encodings which use a
fixed number of bytes for every character.  For example, we can extract
the @var{i}th character of a string in constant time, and we can always
substitute the @var{i}th character of a string with any other character
without reallocating or copying the string.

However, there are no fixed-width encodings which include the characters
we wish to include, and also fit in a reasonable amount of space.
Despite the Unicode standard's claims to the contrary, Unicode is not
really a fixed-width encoding.  Unicode uses surrogate pairs to
represent characters outside the 16-bit range; a surrogate pair must be
treated as a single character, but occupies two 16-bit spaces.
Three-byte encodings are impractical on most modern machines, because
values will not usually be aligned for efficient access.  Four-byte
encodings are too wasteful for a majority of Guile's users, who only
need ASCII and a few accented characters.

Finally, Guile's multibyte encoding is not so bad.  Unlike a two- or
four-byte encoding, it is efficient in space for American and European
users.  Furthermore, the properties described above mean that many
functions can be coded just as they would for a single-byte encoding.

