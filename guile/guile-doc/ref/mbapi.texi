\input texinfo
@setfilename mbapi.info
@settitle Multibyte API
@setchapternewpage off

@c Open issues:

@c What's the best way to report errors?  Should functions return a
@c magic value, according to C tradition, or should they signal a
@c Guile exception?


@node Working With Multibyte Strings in C
@chapter Working With Multibyte Strings in C

Guile allows strings to contain characters drawn from a wide variety of
languages, including many Asian, Eastern European, and Middle Eastern
languages, in a uniform and unrestricted way.  The string representation
normally used in C code --- an array of @sc{ASCII} characters --- is not
sufficient for Guile strings, since they may contain characters not
present in @sc{ASCII}.

Instead, Guile uses a very large character set, and encodes each
character as a sequence of one or more bytes.  We call this
variable-width encoding a @dfn{multibyte} encoding.  Guile uses it for
all strings, symbol names, error messages, and so on.

This encoding is mostly invisible to Scheme code.  Strings are still
indexed by character number, not by byte offset; @code{string-length}
still returns the length of a string in characters, not in bytes.
@code{string-ref} and @code{string-set!} are no longer constant-time
operations, but Guile uses various strategies to reduct the impact of
this change.

However, the encoding is visible via Guile's C API; this chapter
explains how to work with Guile multibyte text in C code.  Since
variable-width encodings are clumsier to work with than simple
fixed-width encodings, Guile provides a set of standard macros and
functions for manipulating multibyte text.  Furthermore, Guile makes
some promises about the encoding which you can use in writing your own
text processing code.

While we discuss properties of Guile's encoding, and provide functions
to operate on its character set, we do not actually specify either the
character set or encoding here.  This is because we expect both of them
to change in the future; currently, our encoding that used by Emacs
20.4, but we hope to change Guile (and Emacs as well) to use Unicode and
UTF-8, with some extensions.

@menu
* Multibyte String Terminology::  
* Promised Properties of the Guile Multibyte Encoding::  
* Functions for Operating on Multibyte Text::  
* Multibyte Text Processing Errors::  
* Why Guile Does Not Use a Fixed-Width Encoding::  
@end menu


@node Multibyte String Terminology, Promised Properties of the Guile Multibyte Encoding, Working With Multibyte Strings in C, Working With Multibyte Strings in C
@section Multibyte String Terminology 

In the descriptions which follow, we make the following definitions:
@table @dfn

@item byte
A @dfn{byte} is a number between 0 and 255.  It has no inherent textual
interpretation.  So 65 is a byte, not a character.

@item character
A @dfn{character} is a unit of text.  It has no inherent numeric value.
@samp{A} and @samp{.} are characters, not bytes.  (This is not the C
language's definition of @dfn{character}; in this chapter, we will
always use the phrase ``the C language's @code{char} type'' when that's
what we mean.)

@item character set
A @dfn{character set} is an invertible mapping between a given set of
characters and numbers.  @sc{ASCII} is a character set assigning
characters to the numbers 0 through 127.  It maps @samp{A} onto the
number 65, and @samp{.} onto 46.

Note that a character set maps characters onto numbers, @emph{not
necessarily} onto bytes.  For example, the Unicode character set maps
the Greek lower-case @samp{alpha} character onto the number 945, which
is not a byte.

@item encoding
An encoding maps numbers onto sequences of bytes.  For example, the
UTF-8 encoding, defined in the Unicode Standard, would map the number
945 onto the sequence of bytes @samp{206 177}.  When using the @sc{ASCII}
character set, every number assigned is also a byte, so there is an
obvious trivial encoding for @sc{ASCII} in bytes.

@end table

Thus, to turn a character into a sequence of bytes, you need a character
set to assign a number to that character, and then an encoding to turn
that number into a sequence of bytes.

Likewise, to interpret a sequence of bytes as a sequence of characters,
you use an encoding to extract a sequence of numbers from the bytes, and
then a character set to turn the numbers into characters.

Errors can occur while carrying out either of these processes.  For
example, under a particular encoding, a given string of bytes might not
correspond to any number.  For example, the byte sequence @samp{128 128}
is not a valid encoding of any number under UTF-8.

Having carefully defined our terminology, we will now abuse it.

We will sometimes use the word @dfn{character} to refer to the number
assigned to a character by a character set, in contexts where the
character set is obvious.

Sometimes there is a close association between a particular encoding and
a particular character set.  Thus, we may sometimes refer to the
character set and encoding together as an @dfn{encoding}.


@node Promised Properties of the Guile Multibyte Encoding, Functions for Operating on Multibyte Text, Multibyte String Terminology, Working With Multibyte Strings in C
@section Promised Properties of Guiles Multibyte Encoding

Internally, Guile uses a single encoding for all text.  It is correct to
write code which assumes that a string or symbol name uses this
encoding; code which makes this assumption will be portable to all
future versions of Guile, as far as we know.

Guile's encoding has the following properties, which should make it
easier to write code which operates on it.

@b{Every @sc{ASCII} character is encoded as a single byte from 0 to 127, in
the obvious way.}  This means that a standard C string containing only
@sc{ASCII} characters is a valid Guile string (except for the terminator;
Guile strings store the length explicitly, so they can contain null
characters).

@b{The encodings of non-@sc{ASCII} characters use only bytes between 128
and 255.}  That is, when we turn a non-@sc{ASCII} character into a
series of bytes, none of those bytes can ever be mistaken for the
encoding of @sc{ASCII} character.  This means that you can search a
Guile string for an @sc{ASCII} character using the ordinary
@code{memchr} function.  By extension, you can search for an @sc{ASCII}
substring in a Guile string using the ordinary @code{strstr} functions.

@b{No character encoding is a subsequence of any other character
encoding.}  (This is just a stronger version of the previous promise.)
This means that you can search for occurrences of one Guile string
within another Guile string just as if they were raw byte strings.  You
can use the stock @code{memmem} function for such searches.

@b{You can always determine the full length of a character's encoding
from its first byte.}  Guile provides a table mapping initial bytes onto
character lengths.  Given the first rule, you can see that entries 0 to
127 of this table must all be 1.

@b{Given an arbitrary byte position in a Guile string, you can always
find the beginning and end of the character containing that byte without
scanning too far in either direction.}  This means that, if you are sure
a byte sequence is a valid encoding of a character sequence, you can
find character boundaries without keeping track of the beginning and
ending of the overall string.  This promise relies on the fact that, in
addition to storing the string's length explicitly, Guile always either
terminates the string's storage with a zero byte, or shares it with
another string which is terminated this way.


@node Functions for Operating on Multibyte Text, Multibyte Text Processing Errors, Promised Properties of the Guile Multibyte Encoding, Working With Multibyte Strings in C
@section Functions for Operating on Multibyte Text

Guile provides the following functions, variables, and types for working
with multibyte text.  Guile uses the C type @code{unsigned char *} to
refer to text encoded with Guile's encoding.

@menu
* Basic Multibyte Character Processing::  
* Finding Character Encoding Boundaries::  
* Multibyte String Functions::  
* Exchanging Guile Text With the Outside World in C::  
@end menu


@node Basic Multibyte Character Processing, Finding Character Encoding Boundaries, Functions for Operating on Multibyte Text, Functions for Operating on Multibyte Text
@subsection Basic Multibyte Character Processing

@deftp {Libguile Type} scm_mb_char_t
This is a signed integral type large enough to hold any character in
Guile's character set.  All character numbers are positive.
@end deftp

@deftypefn {Libguile Function} scm_mb_char_t scm_mb_get (const unsigned char *@var{p})
Return the character whose encoding starts at @var{p}, or -1 if @var{p}
does not point to a valid character encoding.

Note that @code{scm_mb_get} may be implemented as a macro, and its
argument may be evaluated several times.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_put (scm_mb_char_t @var{c}, unsigned char *@var{p})
Place the encoded form of the Guile character @var{c} at @var{p}, and
return its length in bytes.  If @var{c} is not the number of a Guile
character, return 0.
@end deftypefn

@deftypevr {Libguile Constant} int scm_mb_max_len
The maximum length of any character's encoding, in bytes.  You may
assume this is relatively small --- less than a dozen or so.
@end deftypevr


@deftypefn {Libguile Function} int scm_mb_len (scm_mb_char_t @var{c})
Return the length of the encoding of the character @var{c}, in bytes.

Note that @code{scm_mb_len} may be implemented as a macro, and it may
evaluate its argument several times.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_len_leading (unsigned char @var{b})
If @var{b} is the first byte of a character's encoding, return the full
length of the character's encoding, in bytes.

Note that @code{scm_mb_len_leading} may be implemented as a macro, and
it may evaluate its argument several times.
@end deftypefn


@node Finding Character Encoding Boundaries, Multibyte String Functions, Basic Multibyte Character Processing, Functions for Operating on Multibyte Text
@subsection Finding Character Encoding Boundaries

These are functions for finding the boundaries between characters in
multibyte text.

@deftypefn {Libguile Function} int scm_mb_boundary_p (const unsigned char *@var{p})
Return non-zero iff @var{p} points to the start of a character in
multibyte text.
@end deftypefn

@deftypefn {Libguile Function} {unsigned char *} scm_mb_floor (unsigned char *@var{p})
``Round'' @var{p} to the previous character boundary.  That is, if
@var{p} points to the middle of the encoding of a Guile character,
return a pointer to the first byte of the encoding.  If @var{p} points
to the start of the encoding of a Guile character, return @var{p}
unchanged.
@end deftypefn

@deftypefn {libguile Function} {unsigned char *} scm_mb_ceiling (unsigned char *@var{p})
``Round'' @var{p} to the next character boundary.  That is, if @var{p}
points to the middle of the encoding of a Guile character, return a
pointer to the first byte of the encoding of the next character.  If
@var{p} points to the start of the encoding of a Guile character, return
@var{p} unchanged.
@end deftypefn

Note that it is not friendly for functions to silently correct byte
offsets that point into the middle of a character's encoding.  Such
offsets almost always indicate a programming error, and they should be
reported as early as possible.  So, when you write code which operates
on multibyte text, you do not use functions like these to ``clean up''
byte offsets; instead, your code should signal a
@code{text:not-char-boundary} error as soon as it detects an invalid
offset.  @xref{Multibyte Text Processing Errors}.


@node Multibyte String Functions, Exchanging Guile Text With the Outside World in C, Finding Character Encoding Boundaries, Functions for Operating on Multibyte Text
@subsection Multibyte String Functions

These functions allow you to operate on multibyte strings: sequences of
character encodings.

@deftypefn {Libguile Function} int scm_mb_count (const unsigned char *@var{p}, int @var{len})
Return the number of Guile characters encoded by the @var{len} bytes at
@var{p}.  Return -1 if the sequence contains any invalid character
encodings, or if the last character encoding is incomplete.
@end deftypefn

@deftypefn {Libguile Function} scm_mb_char_t scm_mb_walk (const unsigned char **@var{pp})
Return the character whose encoding starts at @code{*@var{pp}}, and
advance @code{*@var{pp}} to the start of the next character.  Return -1
if @code{*@var{pp}} does not point to a valid character encoding.
@end deftypefn

@deftypefn {Libguile Function} {unsigned char *} scm_mb_prev (unsigned char *@var{p})
If @var{p} points to the middle of the encoding of a Guile character,
return a pointer to the first byte of the encoding.  If @var{p} points
to the start of the encoding of a Guile character, return the start of
the previous character's encoding.

This is like @code{scm_mb_floor}, but the returned pointer will always
be before @var{p}.  If you use this function to drive an iteration, it
guarantees backward progress.
@end deftypefn

@deftypefn {Libguile Function} {unsigned char *} scm_mb_next (unsigned char *@var{p})
If @var{p} points to the encoding of a Guile character, return a pointer
to the first byte of the encoding of the next character.

This is like @code{scm_mb_ceiling}, but the returned pointer will always
be after @var{p}.  If you use this function to drive an iteration, it
guarantees forward progress.
@end deftypefn

@deftypefn {Libguile Function} unsigned char *scm_mb_index (const unsigned char *@var{p}, int @var{len}, int @var{i})
Assuming that the @var{len} bytes starting at @var{p} are a
concatenation of valid character encodings, return a pointer to the
start of the @var{i}'th character encoding in the sequence.

This function scans the sequence from the beginning to find the
@var{i}'th character, and will generally require time proportional to
the distance from @var{p} to the returned address.

If the sequence contains invalid character encodings before the
@var{i}'th character, treat each byte which is not part of a valid
character encoding as a single character, for purposes of the count.
@end deftypefn

It is common to process the characters in a string from left to right.
However, if you fetch each character using @code{scm_mb_index}, each
call will scan the text from the beginning, so your loop will require
time proportional to at least the square of the length of the text.  To
avoid this poor performance, you can use a @code{scm_mb_cache}
structure and the @code{scm_mb_index_cached} function.

@deftp {Libguile Type} {struct scm_mb_cache}
This structure holds information that allows a string indexing operation
to remember the result of a previous scan of the string.  It has the
following members:
@table @code

@item character
An index, in characters, into the string.

@item byte
The index, in bytes, of the start of that character.

@end table

In other words, @var{byte} is the byte offset of the @var{character}'th
character of the string.

Both elements of a @code{struct scm_mb_cache} structure should be
initialized to zero before its first use, and whenever the string's text
changes.
@end deftp

@deftypefn {Libguile Function} unsigned char *scm_mb_index_cached (const unsigned char *@var{p}, int @var{len}, int @var{i}, struct scm_mb_cache *@var{cache})
This function is identical to @code{scm_mb_index}, except that it may
consult and update *@var{cache} in order to avoid scanning the string
from the beginning.

Using @code{scm_mb_index_cached}, you can scan a string from left to
right in time proportional to the length of the string.
@end deftypefn

Guile also provides functions to convert between an encoded sequence of
characters, and an array of @code{scm_mb_char_t} objects.

@deftypefn {Libguile Function} scm_mb_char_t *scm_mb_multibyte_to_fixed (const unsigned char *@var{p}, int @var{len}, int *@var{result_len})
Convert the variable-width text in the @var{len} bytes at @var{p}
to an array of @code{scm_mb_char_t} values.  Return a pointer to the array,
and set @code{*@var{result_len}} to the number of elements it contains.
The returned array is allocated with @code{malloc}, and it is the
caller's responsibility to free it.

If the text is not a sequence of valid character encodings, this
function will signal a @code{text:bad-encoding} error.
@end deftypefn

@deftypefn {Libguile Function} unsigned char
*scm_mb_fixed_to_multibyte (scm_mb_char_t *@var{fixed}, int @var{len}, int *@var{result_len})
Convert the array of @code{scm_mb_char_t} values to a sequence of
variable-width character encodings.  Return a pointer to the array of
bytes, and set @code{*@var{result_len}} to its length, in bytes.  The
returned byte sequence is allocated with @code{malloc}; it is the
caller's responsibility to free it.

If the text is not a sequence of valid character encodings, this
function will signal a @code{text:bad-encoding} error.
@end deftypefn


@node Exchanging Guile Text With the Outside World in C,  , Multibyte String Functions, Functions for Operating on Multibyte Text
@subsection Exchanging Guile Text With the Outside World in C

Guile provides functions for converting between Guile's internal text
representation and encodings popular in the outside world.  These
functions are closely modeled after the @code{iconv} functions available
on some systems.

To convert text between two encodings, you should first call
@code{scm_mb_iconv_open} to indicate the source and destination
encodings; this function returns a context object which records the
conversion to perform, and carries any necessary state for the
conversion process.

Then, you should call @code{scm_mb_iconv} to actually convert the text.
This function expects input and output buffers, and a pointer to the
context you got from @var{scm_mb_iconv_open}.  You don't need to pass
all your input to @code{scm_mb_iconv} at once; you can invoke it on
successive blocks of input (as you read it from a file, say), and it
will convert as much as it can each time, indicating when you should
grow your output buffer.

@deftp {Libguile Type} {struct scm_mb_iconv}
This is the type for context objects, which represent the current state
of an ongoing text conversion.  A @code{struct scm_mb_iconv} records the
source and destination encodings, and keeps track of any information
needed to handle stateful encodings.
@end deftp

@deftypefn {Libguile Function} {struct scm_mb_iconv *} scm_mb_iconv_open (const char *@var{tocode}, const char *@var{fromcode})
Return a pointer to a new @code{struct scm_mb_iconv} context object,
ready to convert from the encoding named @var{fromcode} to the encoding
named @var{tocode}.  For state-dependent encodings, the context object
is in some appropriate initial state, ready for use with the
@code{scm_mb_iconv} function.

If either @var{tocode} or @var{fromcode} is not the name of a known
encoding, this function will signal the @code{text:unknown-encoding}
error, described below.  Guile supports at least these encodings:

@table @samp 
@item guile
This is always Guile's current internal multibyte encoding.  The actual
encoding this name represents may change over time, but you will need to
use this when converting data between external sources and Guile
objects.
@item ASCII
US-ASCII, in the standard one-character-per-byte encoding.
@item ISO-8859-1
@item Emacs-Mule
This is the variable-length encoding for multi-lingual text by GNU
Emacs, at least through version 20.4.  You probably should not use this
encoding, as it is designed only for Emacs's internal use.  However, we
provide it here because it's trivial to support, and some people
probably do have @samp{emacs-mule}-format files lying around.
@end itemize

Case is not significant in encoding names.

You can also define your own conversions; see @ref{Implementing Your Own
Text Conversions}.
@end deftypefn

@deftypefn {Libguile Function} size_t scm_mb_iconv (struct scm_mb_iconv
*@var{context}, const char **@var{inbuf}, size_t *@var{inbytesleft},
char **@var{outbuf}, size_t *@var{outbytesleft})
Convert a sequence of characters from one encoding to another.  The argument
@var{context} specifies the encodings to use for the input and output;
use @code{scm_mb_iconv_open} to create a @var{context} object for a
particular conversion.

Upon entry to the function, @code{*@var{inbuf}} should point to the
input buffer, and @code{*@var{inbytesleft}} should hold the number of
input bytes present in the buffer; @code{*@var{outbuf}} should point to
the output buffer, and @code{*@var{outbytesleft}} should hold the number
of bytes available to hold the conversion results in that buffer.

Upon exit from the function, @code{*@var{inbuf}} points to the first
unconsumed byte of input, and @code{*@var{inbytesleft}} holds the number
of unconsumed input bytes; @code{*@var{outbuf}} points to the byte after
the last output byte, and @code{*@var{outbyteleft}} holds the number of
bytes left unused in the output buffer.

Some encodings use byte sequences which do not correspond to any textual
character, but instead modify the meanings of subsequent bytes; such
encodings are called @dfn{stateful}, since the meaning of a given byte
depends on a potentially unbounded number of preceding bytes.  In a
stateful encoding, we call byte sequences which change the state of the
conversion but produce no text @dfn{shift sequences}.  When a
conversion's input encoding is stateful, then a call to
@code{scm_mb_iconv} might consume input but produce no output, since the
input sequence might contain only shift sequences.

For stateful encodings, @var{context} carries encoding state from one
call to @code{scm_mb_iconv} to the next.  Thus, successive calls to
@var{scm_mb_iconv} which use the same context object can convert a
stream of data one chunk at a time.  

If either @var{inbuf} or @code{*@var{inbuf}} is zero, then
@code{scm_mb_iconv} will reset @var{context} to its initial state for
both the input and output encodings.  If neither @var{outbuf} nor
@code{*@var{outbuf}} are zero, then @code{scm_mb_iconv} will store a
byte sequence to put the output string in its initial state.  If the
output buffer is not large enough to hold this byte sequence,
@var{scm_mb_iconv} will return @code{scm_mb_iconv_more_room}.  In this
case, the shift states of @var{context}'s input and output encodings are
unchanged.

The @code{scm_mb_iconv} function always consumes only complete
characters or shift sequences from the input buffer, and the output
buffer always contains a sequence of complete characters or shift
sequences.  Note that the conversion may not be able to consume all the
input bytes if the input contains an incomplete character encoding, or
if the output buffer is too small to contain the full conversion
results.  The conversion may not fill the output buffer if the converted
input text is not long enough, or if converting another complete
character from the input would overflow the output buffer.

If the input sequence contains an invalid character encoding, conversion
stops before the invalid input character, and @code{scm_mb_iconv}
returns the constant value @code{scm_mb_iconv_bad_encoding}.

If the input sequence contains characters which are not expressible in
the output encoding, @code{scm_mb_iconv} converts it in an
implementation-defined way.  It may simply delete the character.

If the output buffer does not contain enough room to hold the converted
form of the complete input text, @code{scm_mb_iconv} converts as much as
it can, changes the input and output pointers to reflect the amount of
text successfully converted, and then returns
@code{scm_mb_iconv_more_room}.

Normally, @code{scm_mb_iconv} returns the number of input characters it
could not convert perfectly to the ouput encoding.  However, it may
return one of the @code{scm_mb_iconv_} codes described below, to
indicate an error.  All of these codes are negative values.

This interface is meant to be compatible with the @code{iconv} function
available on some systems, and with the @code{unicode_iconv} function
provided by the GNOME Project's @file{libunicode} library.
@end deftypefn

Here are the status codes that might be returned by @code{scm_mb_iconv}.
They are all negative integers.
@table @code

@item scm_mb_iconv_more_room
The conversion needs more room in the output buffer.  Some characters
may have been consumed from the input buffer, and some characters may
have been placed in the available space in the output buffer.

@item scm_mb_iconv_bad_encoding
@code{scm_mb_iconv} encountered an invalid character encoding in the
input buffer.  Conversion stopped before the invalid character, so there
may be some characters consumed from the input buffer, and some
converted text in the output buffer.
@end table


@node Implementing Your Own Text Conversions
@subsection Implementing Your Own Text Conversions

This section describes the interface for adding your own encoding
conversions for use with @code{scm_mb_iconv}.

enum unicode_read_result {
  /* Read was okay, consumed at least one byte or produced at least one
     character.  */
  unicode_read_okay,

  /* Input is incomplete, nothing was consumed or produced.
     This could be okay, if you have more text to pass through, but it's
     an error if you've provided all the input text you've got.  */
  unicode_read_incomplete,

  /* Invalid sequence.  */
  unicode_read_error
};

enum unicode_write_result {
  /* Write was okay.  */
  unicode_write_okay,

  /* Write needs more room.  */
  unicode_write_more_room 
};

typedef struct unicode_encoding_t
{
  /* Name of encoding.  */
  const char *name;

  /* Initialize private data.  NULL means no init necessary.  Return 0
     on error.  */
  int (*init) (void **privp);

  /* Destroy private data.  NULL means no destroy necessary.  */
  void (*destroy) (void **privp);

  /* Put output buffer into initial shift state.  If NULL, this
     encoding doesn't use a shift state.  Returns error indicator like
     iconv(); see man page.  */
  int (*reset) (void *priv);

  /* Read some bytes and convert into an array of UCS4 characters.

     On entry, there are *INBYTESLEFT bytes of text at *INBUF to
     be converted, and *OUTCHARSLEFT characters available at *OUTBUF
     to hold the results.

     On exit, *INBYTESLEFT and *INBUF indicate the input bytes still not
     consumed.  *OUTCHARSLEFT and *OUTBUF indicate the output buffer
     space still not filled.  (By exclusion, these indicate which input
     bytes were consumed, and which output characters were produced.)

     Return one of the unicode_read_ values.  */
  enum unicode_read_result
    (*read) (void *priv,
             const char     **inbuf,  size_t *inbytesleft,
	     unicode_char_t **outbuf, size_t *outcharsleft);

  /* Convert an array of UCS4 characters to output bytes.

     On entry, there are *INCHARSLEFT UCS4 characters available at
     *INBUF, and *OUTBYTESLEFT bytes available to store output at
     *OUTBUF.

     On exit, *INCHARSLEFT and *INBUF indicate the number of unicode
     characters left unconverted (because there was insufficient room in
     the output buffer to hold their converted forms), and *OUTBYTESLEFT
     and *OUTBUF indicate the unused portion of the output buffer.

     Return one of the unicode_write_ values.  */
  enum unicode_write_result
    (*write) (void *priv,
              unicode_char_t **inbuf,  size_t *incharsleft,
              char           **outbuf, size_t *outbytesleft);

  /* Link.  */
  struct unicode_encoding_t *next;
} unicode_encoding_t;

@node Multibyte Text Processing Errors, Why Guile Does Not Use a Fixed-Width Encoding, Functions for Operating on Multibyte Text, Working With Multibyte Strings in C
@section Multibyte Text Processing Errors

This section describes error conditions which code can raise to indicate
problems encountered while processing multibyte text.

@deffn Condition text:not-char-boundary func message args object offset
By calling @var{func}, the program attempted to access a character at
byte offset @var{offset} in the Guile object @var{object}, but
@var{offset} is not the start of a character's encoding in @var{object}.

Typically, @var{object} is a string or symbol.  If the function signalling
the error cannot find the Guile object that contains the text it is
inspecting, it should use @code{#f} for @var{object}.
@end deffn

@deffn Condition text:bad-encoding
By calling @var{func}, the program attempted to interpret the text in
@var{object}, but @var{object} contains a byte sequence which is not a
valid encoding for any character.
@end deffn

@deffn Condition text:not-guile-char func message args number
By calling @var{func}, the program attempted to treat @var{number} as the
number of a character in the Guile character set, but @var{number} does
not correspond to any character in the Guile character set.
@end deffn


@node Why Guile Does Not Use a Fixed-Width Encoding,  , Multibyte Text Processing Errors, Working With Multibyte Strings in C
@section Why Guile Does Not Use a Fixed-Width Encoding

Multibyte encodings are clumsier to work with than encodings which use a
fixed number of bytes for every character.  For example, we can extract
the @var{i}th character of a string in constant time, and we can always
substitute the @var{i}th character of a string with any other character
without reallocating or copying the string.

However, there are no fixed-width encodings which include the characters
we wish to include, and also fit in a reasonable amount of space.
Despite the Unicode standard's claims to the contrary, Unicode is not
really a fixed-width encoding.  Unicode uses surrogate pairs to
represent characters outside the 16-bit range; a surrogate pair must be
treated as a single character, but occupies two 16-bit spaces.  As of
this writing, there are already plans to assign characters to the
surrogate character codes.  Three-byte encodings are impractical on most
modern machines, because values will not usually be aligned for
efficient access.  Four-byte encodings are too wasteful for a majority
of Guile's users, who only need ASCII and a few accented characters.

Finally, Guile's multibyte encoding is not so bad.  Unlike a two- or
four-byte encoding, it is efficient in space for American and European
users.  Furthermore, the properties described above mean that many
functions can be coded just as they would for a single-byte encoding.

@bye
