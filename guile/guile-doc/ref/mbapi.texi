\input texinfo
@setfilename mbapi.info
@settitle Multibyte API
@setchapternewpage off

@node Working With Multibyte Strings in C
@chapter Working With Multibyte Strings in C

Guile allows strings to contain characters drawn from a wide variety of
languages, including many Asian, Eastern European, and Middle Eastern
languages, in a uniform and unrestricted way.  The string representation
normally used in C code --- an array of @sc{ASCII} characters --- is not
sufficient for Guile strings, since they may contain characters not
present in @sc{ASCII}.

Instead, Guile uses a very large character set, and encodes each
character as a sequence of one or more bytes.  We call this
variable-width encoding a @dfn{multibyte} encoding.  Guile uses it for
all strings, symbol names, error messages, and so on.

Since variable-width encodings are clumsier to work with than simple
fixed-width encodings, Guile provides a set of standard macros and
functions for manipulating multibyte text.  Furthermore, Guile makes
some promises about the encoding which you can use in writing your own
text processing code.

While we discuss properties of Guile's encoding, and provide functions
to operate on its character set, we do not actually specify either the
character set or encoding here.  This is because we expect both of them
to change in the future; currently, our encoding that used by Emacs
20.4, but we hope to change Guile (and Emacs as well) to use Unicode and
UTF-8, with some extensions.

@menu
* Multibyte String Terminology::  
* Promised Properties of the Guile Multibyte Encoding::  
* Functions for Operating on Multibyte Text::  
* Multibyte Text Processing Errors::  
* Why Guile Does Not Use a Fixed-Width Encoding::  
@end menu


@node Multibyte String Terminology, Promised Properties of the Guile Multibyte Encoding, Working With Multibyte Strings in C, Working With Multibyte Strings in C
@section Multibyte String Terminology 

In the descriptions which follow, we make the following definitions:
@table @dfn

@item byte
A @dfn{byte} is a number between 0 and 255.  It has no inherent textual
interpretation.  So 65 is a byte, not a character.

@item character
A @dfn{character} is a unit of text.  It has no inherent numeric value.
@samp{A} and @samp{.} are characters, not bytes.  (This is not the C
language's definition of @dfn{character}; in this chapter, we will
always use the phrase ``the C language's @code{char} type'' when that's
what we mean.)

@item character set
A @dfn{character set} is an invertible mapping between a given set of
characters and numbers.  @sc{ASCII} is a character set assigning
characters to the numbers 0 through 127.  It maps @samp{A} onto the
number 65, and @samp{.} onto 46.

Note that a character set maps characters onto numbers, @emph{not
necessarily} onto bytes.  For example, the Unicode character set maps
the Greek lower-case @samp{alpha} character onto the number 945, which
is not a byte.

@item encoding
An encoding maps numbers onto sequences of bytes.  For example, the
UTF-8 encoding, defined in the Unicode Standard, would map the number
945 onto the sequence of bytes @samp{206 177}.  When using the @sc{ASCII}
character set, every number assigned is also a byte, so there is an
obvious trivial encoding for @sc{ASCII} in bytes.

@end table

Thus, to turn a character into a sequence of bytes, you need a character
set to assign a number to that character, and then an encoding to turn
that number into a sequence of bytes.

Likewise, to interpret a sequence of bytes as a sequence of characters,
you use an encoding to extract a sequence of numbers from the bytes, and
then a character set to turn the numbers into characters.

Errors can occur while carrying out either of these processes.  For
example, under a particular encoding, a given string of bytes might not
correspond to any number.  For example, the byte sequence @samp{128 128}
is not a valid encoding of any number under UTF-8.

Having carefully defined our terminology, we now proceed to abuse it.

We will sometimes use the word @dfn{character} to refer to the number
assigned to a character by a character set, in contexts where the
character set is obvious.

Sometimes there is a close association between a particular encoding and
a particular character set.  Thus, we may sometimes refer to the
character set and encoding together as an @dfn{encoding}.


@node Promised Properties of the Guile Multibyte Encoding, Functions for Operating on Multibyte Text, Multibyte String Terminology, Working With Multibyte Strings in C
@section Promised Properties of Guiles Multibyte Encoding

Internally, Guile uses a single encoding for all text.  It is correct to
write code which assumes that a string or symbol name uses this
encoding; code which makes this assumption will be portable to all
future versions of Guile, as far as we know.

Guile's encoding has the following properties, which should make it
easier to write code which operates on it.

@b{Every @sc{ASCII} character is encoded as a single byte from 0 to 127, in
the obvious way.}  This means that a standard C string containing only
@sc{ASCII} characters is a valid Guile string (except for the terminator;
Guile strings store the length explicitly, so they can contain null
characters).

@b{The encodings of non-@sc{ASCII} characters use only bytes between 128
and 255.}  That is, when we turn a non-@sc{ASCII} character into a
series of bytes, none of those bytes can ever be mistaken for the
encoding of @sc{ASCII} character.  This means that you can search a
Guile string for an @sc{ASCII} character using the ordinary
@code{memchr} function.  By extension, you can search for an @sc{ASCII}
substring in a Guile string using the ordinary @code{strstr} functions.

@b{No character encoding is a subsequence of any other character
encoding.}  (This is just a stronger version of the previous promise.)
This means that you can search for occurrences of one Guile string
within another Guile string just as if they were raw byte strings.  You
can use the stock @code{memmem} function for such searches.

@b{You can always determine the full length of a character's encoding
from its first byte.}  Guile provides a table mapping initial bytes onto
character lengths.  Given the first rule, you can see that entries 0 to
127 of this table must all be 1.

@b{Given an arbitrary byte position in a Guile string, you can always
find the beginning and end of the character containing that byte without
scanning too far in either direction.}  This means that, if you are sure
a byte sequence is a valid encoding of a character sequence, you can
find character boundaries without keeping track of the beginning and
ending of the overall string.  This promise relies on the fact that, in
addition to storing the string's length explicitly, Guile always either
terminates the string's storage with a zero byte, or shares it with
another string which is terminated this way.

@node Functions for Operating on Multibyte Text, Multibyte Text Processing Errors, Promised Properties of the Guile Multibyte Encoding, Working With Multibyte Strings in C
@section Functions for Operating on Multibyte Text

Guile provides the following functions, variables, and types for working
with multibyte text.  Guile uses the C type @code{unsigned char *} to
refer to text encoded with Guile's encoding.

@menu
* Basic Multibyte Character Processing::  
* Finding Character Encoding Boundaries::  
* Multibyte String Functions::  
* Guile Character Properties::  
* Exchanging Text With The Outside World::  
* Multibyte Character Tables::  
* Multibyte Character Categories::  
@end menu

@node Basic Multibyte Character Processing, Finding Character Encoding Boundaries, Functions for Operating on Multibyte Text, Functions for Operating on Multibyte Text
@subsection Basic Multibyte Character Processing

@deftp {Libguile Type} scm_mb_char_t
This is a signed integral type large enough to hold any character in
Guile's character set.  All character numbers are positive.
@end deftp

@deftypefn {Libguile Function} scm_mb_char_t scm_mb_get (unsigned char *@var{p})
Return the character whose encoding starts at @var{p}, or -1 if @var{p}
does not point to a valid character encoding.

Note that @code{scm_mb_get} may be implemented as a macro, and its
argument may be evaluated several times.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_put (scm_mb_char_t @var{c}, unsigned char *@var{p})
Place the encoded form of the Guile character @var{c} at @var{p}, and
return its length in bytes.
@end deftypefn

@deftypevr {Libguile Constant} int scm_mb_max_len
The maximum length of any character's encoding, in bytes.  You may
assume this is relatively small --- less than a dozen or so.
@end deftypevr


@deftypefn {Libguile Function} int scm_mb_len (scm_mb_char_t @var{c})
Return the length of the encoding of the character @var{c}, in bytes.

Note that @code{scm_mb_len} may be implemented as a macro, and it may
evaluate its argument several times.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_len_leading (unsigned char @var{b})
If @var{b} is the first byte of a character's encoding, return the full
length of the character's encoding, in bytes.

Note that @code{scm_mb_len_leading} may be implemented as a macro, and
it may evaluate its argument several times.
@end deftypefn


@node Finding Character Encoding Boundaries, Multibyte String Functions, Basic Multibyte Character Processing, Functions for Operating on Multibyte Text
@subsection Finding Character Encoding Boundaries

These are functions for finding the boundaries between characters in
multibyte text.

@deftypefn {Libguile Function} int scm_mb_boundary_p (unsigned char *@var{p})
Return non-zero iff @var{p} points to the start of a character in
multibyte text.
@end deftypefn

@deftypefn {Libguile Function} {unsigned char *} scm_mb_floor (unsigned char *@var{p})
``Round'' @var{p} to the previous character boundary.  That is, if
@var{p} points to the middle of the encoding of a Guile character,
return a pointer to the first byte of the encoding.  If @var{p} points
to the start of the encoding of a Guile character, return @var{p}
unchanged.
@end deftypefn

@deftypefn {libguile Function} {unsigned char *} scm_mb_ceiling (unsigned char *@var{p})
``Round'' @var{p} to the next character boundary.  That is, if @var{p}
points to the middle of the encoding of a Guile character, return a
pointer to the first byte of the encoding of the next character.  If
@var{p} points to the start of the encoding of a Guile character, return
@var{p} unchanged.
@end deftypefn

Note that it is not friendly for functions to silently correct byte
offsets that point into the middle of a character's encoding.  Such
offsets almost always indicate a programming error, and they should be
reported as early as possible.  So, when you write code which operates
on multibyte text, you do not use functions like these to ``clean up''
byte offsets; instead, your code should signal a
@code{text:not-char-boundary} error as soon as it detects an invalid
offset.  @xref{Multibyte Text Processing Errors}.


@node Multibyte String Functions, Guile Character Properties, Finding Character Encoding Boundaries, Functions for Operating on Multibyte Text
@subsection Multibyte String Functions

These functions allow you to operate on multibyte strings: sequences of
character encodings.

@deftypefn {Libguile Function} int scm_mb_count (unsigned char *@var{p}, int @var{len})
Return the number of Guile characters encoded by the @var{len} bytes at
@var{p}.  Return -1 if the sequence contains any invalid character
encodings, or if the last character encoding is incomplete.
@end deftypefn

@deftypefn {Libguile Function} scm_mb_char_t scm_mb_walk (unsigned char **@var{pp})
Return the character whose encoding starts at @code{*@var{pp}}, and
advance @code{*@var{pp}} to the start of the next character.  Return -1
if @code{*@var{pp}} does not point to a valid character encoding.
@end deftypefn

@deftypefn {Libguile Function} {unsigned char *} scm_mb_prev (unsigned char *@var{p})
If @var{p} points to the middle of the encoding of a Guile character,
return a pointer to the first byte of the encoding.  If @var{p} points
to the start of the encoding of a Guile character, return the start of
the previous character's encoding.

This is like @code{scm_mb_floor}, but the returned pointer will always
be before @var{p}.  If you use this function to drive an iteration, it
guarantees backward progress.
@end deftypefn

@deftypefn {Libguile Function} {unsigned char *} scm_mb_next (unsigned char *@var{p})
If @var{p} points to the encoding of a Guile character, return a pointer
to the first byte of the encoding of the next character.

This is like @code{scm_mb_ceiling}, but the returned pointer will always
be after @var{p}.  If you use this function to drive an iteration, it
guarantees forward progress.
@end deftypefn

@deftypefn {Libguile Function} unsigned char *scm_mb_index (unsigned char *@var{p}, int @var{len}, int @var{i})
Assuming that the @var{len} bytes starting at @var{p} are a
concatenation of valid character encodings, return a pointer to the
start of the @var{i}'th character encoding in the sequence.

This function scans the sequence from the beginning to find the
@var{i}'th character, and will generally require time proportional to
the distance from @var{p} to the returned address.

If the sequence contains invalid character encodings before the
@var{i}'th character, treat each byte which is not part of a valid
character encoding as a single character, for purposes of the count.
@end deftypefn

It is common to process the characters in a string from left to right.
However, if you fetch each character using @code{scm_mb_index}, each
call will scan the text from the beginning, so your loop will require
time proportional to at least the square of the length of the text.  To
avoid this poor performance, you can use a @code{scm_mb_cache}
structure and the @code{scm_mb_index_cached} function.

@deftp {Libguile Type} struct scm_mb_cache
This structure holds information that allows a string indexing operation
to remember the result of a previous scan of the string.  It has the
following members:
@table @code

@item character
An index, in characters, into the string.

@item byte
The index, in bytes, of the start of that character.

@end table

In other words, @var{byte} is the byte offset of the @var{character}'th
character of the string.

Both elements of a @code{struct scm_mb_cache} structure should be
initialized to zero before its first use, and whenever the string's text
changes.
@end deftp

@deftypefn {Libguile Function} unsigned char *scm_mb_index_cached (unsigned char *@var{p}, int @var{len}, int @var{i}, struct scm_mb_cache *@var{cache})
This function is identical to @code{scm_mb_index}, except that it may
consult and update *@var{cache} in order to avoid scanning the string
from the beginning.

Using @code{scm_mb_index_cached}, you can scan a string from left to
right in time proportional to the length of the string.
@end deftypefn

Guile also provides functions to convert between an encoded sequence of
characters, and an array of @code{scm_mb_char_t} objects.

@deftypefn {Libguile Function} scm_mb_char_t *scm_mb_multibyte_to_fixed (unsigned char *@var{p}, int @var{len}, int *@var{result_len})
Convert the variable-width text in the @var{len} bytes at @var{p}
to an array of @code{scm_mb_char_t} values.  Return a pointer to the array,
and set @code{*@var{result_len}} to the number of elements it contains.
The returned array is allocated with @code{malloc}, and it is the
caller's responsibility to free it.

[[When we specify the conversion functions, we will probably have an
argument that says how they should react to invalid or out-of-charset
sequences.  This function should take another argument of that type.]]
@end deftypefn

@deftypefn {Libguile Function} unsigned char
*scm_mb_fixed_to_multibyte (scm_mb_char_t *@var{fixed}, int @var{len}, int *@var{result_len})
Convert the array of @code{scm_mb_char_t} values to a sequence of
variable-width character encodings.  Return a pointer to the array of
bytes, and set @code{*@var{result_len}} to its length, in bytes.  The
returned byte sequence is allocated with @code{malloc}; it is the
caller's responsibility to free it.
@end deftypefn


@node Guile Character Properties, Exchanging Text With The Outside World, Multibyte String Functions, Functions for Operating on Multibyte Text
@subsection Guile Character Properties

These functions give information about the nature of a given Guile
character.  These are defined for any @code{scm_mb_char_t} value.

@deftypefn {Libguile Function} int scm_mb_isalnum (scm_mb_char_t @var{c})
Return non-zero iff @var{c} is an alphabetic or numeric character.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_is_alpha (scm_mb_char_t @var{c})
Return non-zero iff @var{c} is an alphabetic character.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_iscntrl (scm_mb_char_t @var{c})
Return non-zero iff @var{c} is a control character.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_isdigit (scm_mb_char_t @var{c})
Return non-zero iff @var{c} is a digit.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_isgraph (scm_mb_char_t @var{c})
Return non-zero iff @var{c} is a visible character.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_isupper (scm_mb_char_t @var{c})
Return non-zero iff @var{c} is an upper-case character.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_islower (scm_mb_char_t @var{c})
Return non-zero iff @var{c} is a lower-case character.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_istitle (scm_mb_char_t @var{c})
Return non-zero iff @var{c} is a title-case character.  See the Unicode
standard for an explanation of title case.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_isprint (scm_mb_char_t @var{c})
Return non-zero iff @var{c} is a printable character.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_ispunct (scm_mb_char_t @var{c})
Return non-zero iff @var{c} is a punctuation character.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_isspace (scm_mb_char_t @var{c})
Return non-zero iff @var{c} is a whitespace character.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_isxdigit (scm_mb_char_t @var{c})
Return non-zero iff @var{c} is a hexidecimal digit.
@end deftypefn

@deftypefn {Libguile Function} int scm_mb_isdefined (scm_mb_char_t @var{c})
Return non-zero iff @var{c} is a valid character.
@end deftypefn

@deftypefn {Libguile Function} scm_mb_char_t scm_mb_char_toupper (scm_mb_char_t @var{c})
@deftypefnx {Libguile Function} scm_mb_char_t scm_mb_char_tolower (scm_mb_char_t @var{c})
@deftypefnx {Libguile Function} scm_mb_char_t scm_mb_char_totitle (scm_mb_char_t @var{c})
Convert @var{c} to upper, lower, or title case.  If @var{c} has no
equivalent in the requested case, or is already in that case, return it
unchanged.
@end deftypefn

@deftypefn {Libguile Function} in scm_mb_digit_value (scm_mb_char_t @var{c})
If @var{c} is a hexidecimal digit (according to
@code{scm_mb_isxdigit}), then return its numeric value.  Otherwise
return -1.
@end deftypefn

@deftypefn {Libguile Function} in scm_mb_digit_value (scm_mb_char_t @var{c})
If @var{c} is a digit (according to @code{scm_mb_isdigit}), then
return its numeric value.  Otherwise return -1.
@end deftypefn


@node Exchanging Text With The Outside World, Multibyte Character Tables, Guile Character Properties, Functions for Operating on Multibyte Text
@subsection Exchanging Text With The Outside World

[[This will document conversion functions.  We'll probably imitate
iconv.]]
[[conversions between Guile text and wchar_t arrays?]]


@node Multibyte Character Tables, Multibyte Character Categories, Exchanging Text With The Outside World, Functions for Operating on Multibyte Text
@subsection Multibyte Character Tables

A @dfn{character table} is a table mapping characters onto Guile
objects.  Guile provides functions for creating character tables,
setting entries in character tables, and looking up characters in
character tables.

[[incomplete]]

@node Multibyte Character Categories,  , Multibyte Character Tables, Functions for Operating on Multibyte Text
@subsection Multibyte Character Categories

[[This will describe an ADT representing subsets of the Guile character
set.]]


@node Multibyte Text Processing Errors, Why Guile Does Not Use a Fixed-Width Encoding, Functions for Operating on Multibyte Text, Working With Multibyte Strings in C
@section Multibyte Text Processing Errors

This section describes error conditions which code can raise to indicate
problems encountered while processing multibyte text.

@deffn Condition text:not-char-boundary func message args object offset
By calling @var{func}, the program attempted to access a character at
byte offset @var{offset} in the Guile object @var{object}, but
@var{offset} is not the start of a character's encoding in @var{object}.

Typically, @var{object} is a string or symbol.  If the function signalling
the error cannot find the Guile object that contains the text it is
inspecting, it should use @code{#f} for @var{object}.
@end deffn

@deffn Condition text:bad-encoding func message args object offset
By calling @var{func}, the program attempted to interpret the text in
@var{object}, but @var{object} contains a byte sequence which is not a
valid encoding for any character.
@end deffn


@node Why Guile Does Not Use a Fixed-Width Encoding,  , Multibyte Text Processing Errors, Working With Multibyte Strings in C
@section Why Guile Does Not Use a Fixed-Width Encoding

Multibyte encodings are clumsier to work with than encodings which use a
fixed number of bytes for every character.  For example, we can extract
the @var{i}th character of a string in constant time, and we can always
substitute the @var{i}th character of a string with any other character
without reallocating or copying the string.

However, there are no fixed-width encodings which include the characters
we wish to include, and also fit in a reasonable amount of space.
Despite the Unicode standard's claims to the contrary, Unicode is not
really a fixed-width encoding.  Unicode uses surrogate pairs to
represent characters outside the 16-bit range; a surrogate pair must be
treated as a single character, but occupies two 16-bit spaces.  As of
this writing, there are already plans to assign characters to the
surrogate character codes.  Three-byte encodings are impractical on most
modern machines, because values will not usually be aligned for
efficient access.  Four-byte encodings are too wasteful for a majority
of Guile's users, who only need ASCII and a few accented characters.

Finally, Guile's multibyte encoding is not so bad.  Unlike a two- or
four-byte encoding, it is efficient in space for American and European
users.  Furthermore, the properties described above mean that many
functions can be coded just as they would for a single-byte encoding.

@bye
