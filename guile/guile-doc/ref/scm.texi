@page
@node Linking Guile with your code
@chapter Linking Guile with your code
	--- Mark's "Tools to automate adding libraries" is not a
            well-defined concept.  I think this is closer to what we
            want to cover for now.

@node Scheme data representation
@chapter Scheme data representation


@page
@node Relationship between Scheme and C functions
@chapter Relationship between Scheme and C functions

        --- this is where we explain that all the functions marked as
	    "Primitive Functions" are also accessible from C, and how
	    to derive the C interface given the Scheme interface, when
	    we don't spell it out.
    ... I think there's other stuff needed here ...


@page
@node I/O internals
@chapter I/O internals

@node libguile error handling
@chapter libguile error handling

@example
Error handling is based on catch and throw.  Errors are always thrown with
a key and four arguments:

key: a symbol which indicates the type of error.  The symbols used
by libguile are listed below.

subr: the name of the procedure from which the error is thrown, or #f.

message: a string (possibly language and system dependent) describing the
error.  The tokens %s and %S can be embedded within the message: they
will be replaced with members of the args list when the message is
printed.  %s indicates an argument printed using "display", while %S
indicates an argument printed using "write".  message can also be #f,
to allow it to be derived from the key by the error handler (may be
useful if the key is to be thrown from both C and Scheme).

args: a list of arguments to be used to expand %s and %S tokens in message.
Can also be #f if no arguments are required.

rest: a list of any additional objects required. e.g., when the key is
'system-error, this contains the C errno value.  Can also be #f if no
additional objects are required.

In addition to catch and throw, the following Scheme facilities are
available:

(scm-error key subr message args rest): throw an error, with arguments
as described above.

(error msg arg ...)  Throw an error using the key 'misc-error.  The error
message is created by displaying msg and writing the args.

The following are the error keys defined by libguile and the situations
in which they are used:

error-signal: thrown after receiving an unhandled fatal signal such as
SIGSEV, SIGBUS, SIGFPE etc.  The "rest" argument in the throw contains
the coded signal number (at present this is not the same as the usual
Unix signal number).

system-error: thrown after the operating system indicates an error
condition.  The "rest" argument in the throw contains the errno value.

numerical-overflow: numerical overflow.

out-of-range: the arguments to a procedure do not fall within the
accepted domain.

wrong-type-arg: an argument to a procedure has the wrong thpe.

wrong-number-of-args: a procedure was called with the wrong number of
arguments.

memory-allocation-error: memory allocation error.

stack-overflow: stack overflow error.

regex-error: errors generated by the regular expression library.

misc-error: other errors.

C support
=========

SCM scm_error (SCM key, char *subr, char *message, SCM args, SCM rest)

Throws an error, after converting the char * arguments to Scheme strings.
subr is the Scheme name of the procedure, NULL is converted to #f.
Likewise a NULL message is converted to #f.

The following procedures invoke scm_error with various error keys and
arguments.  The first three call scm_error with the system-error key
and automatically supply errno in the "rest" argument:  scm_syserror
generates messages using strerror,  scm_sysmissing is used when
facilities are not available.  Care should be taken that the errno
value is not reset (e.g., due to an interrupt.)

void scm_syserror (char *subr);
void scm_syserror_msg (char *subr, char *message, SCM args);
void scm_sysmissing (char *subr);

void scm_num_overflow (char *subr);
void scm_out_of_range (char *subr, SCM bad_value);
void scm_wrong_num_args (SCM proc);
void scm_wrong_type_arg (char *subr, int pos, SCM bad_value);
void scm_memory_error (char *subr);
static void scm_regex_error (char *subr, int code); (only used in rgx.c).

void (*scm_error_callback) (SCM key, char *subr, char *message,
			    SCM args, SCM rest));

When a pointer to a C procedure is assigned to this variable, the procedure
will be called whenever scm_error is invoked.  It can be used by C
code to retain control after a Scheme error occurs.
@end example

@page
@node snarfing
@chapter snarfing
