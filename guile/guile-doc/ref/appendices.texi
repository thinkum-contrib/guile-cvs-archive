@node Obtaining and Installing Guile
@appendix Obtaining and Installing Guile

Guile can be obtained from the main GNU archive site
@url{ftp://prep.ai.mit.edu/pub/gnu} or any of its mirrors.  The file
will be named guile-version.tar.gz.  The current version is
@value{VERSION}, so the file you should grab is:

@url{ftp://prep.ai.mit.edu/pub/gnu/guile-@value{VERSION}.tar.gz}

To unbundle Guile use the instruction
@example
zcat guile-@value{VERSION}.tar.gz | tar xvf -
@end example
which will create a directory called @file{guile-@value{VERSION}} with
all the sources.  You can look at the file @file{INSTALL} for detailed
instructions on how to build and install Guile, but you should be able
to just do
@example
cd guile-@value{VERSION}
./configure
make install
@end example

This will install the Guile executable @file{guile}, the Guile library
@file{libguile.a} and various associated header files and support
libraries. It will also install the Guile tutorial and reference manual.

@c [[include instructions for getting R4RS]]

Since in this manual we frequently refer to the Scheme ``standard'',
also known as R4RS, or the ``Revised(4) Report on the Algorithmic
Language Scheme'', so we have included the report in the Guile
distribution (@pxref{Top, Revised(4) Report on the Algorithmic Language
Scheme, , r4rs}).  This will also be installed in your info directory.

@page
@node Reporting Bugs
@appendix Reporting Bugs

Any problems with the installation should be reported to
@email{bug-guile@@gnu.ai.mit.edu}

[[how about an explanation of what makes a good bug report?]]
[[don't complain to us about problems with contributed modules?]]

@page
@node debugger user interface
@appendix debugger user interface
 
@c      --- The title and introduction of this appendix need to
@c          distinguish this clearly from the chapter on the internal
@c          debugging interface.
 
When debugging a program, programmers often find it helpful to examine
the program's internal status while it runs: the values of internal
variables, the choices made in @code{if} and @code{cond} statements, and
so forth.  Guile Scheme provides a debugging interface that programmers
can use to single-step through Scheme functions and examine symbol
bindings.  This is different from the @ref{Internal Debugging
Interface}, which permits programmers to debug the Guile interpreter
itself.  Most programmers will be more interested in debugging their own
Scheme programs than the interpreter which evaluates them.
 
[FIXME: should we include examples of traditional debuggers
and explain why they can't be used to debug interpreted Scheme or Lisp?]
 
@menu
* Single-Step::         Execute a program or function one step at a time.
* Trace::               Print a report each time a given function is called.
* Backtrace::           See a list of the statements that caused an error.
@end menu
 
@node Single-Step
@appendixsec Single-Step
 
@node Trace
@appendixsec Trace

When a function is @dfn{traced}, it means that every call to that
function is reported to the user during a program run.  This can help a
programmer determine whether a function is being called at the wrong
time or with the wrong set of arguments.

@defun trace function
Enable debug tracing on @code{function}.  While a program is being run, Guile
will print a brief report at each call to a traced function,
advising the user which function was called and the arguments that were
passed to it.
@end defun

@defun untrace function
Disable debug tracing for @code{function}.
@end defun

Example:

@lisp
(define (rev ls)
  (if (null? ls)
      '()
      (append (rev (cdr ls))
              (cons (car ls) '())))) @result{} rev

(trace rev) @result{} (rev)

(rev '(a b c d e))
@result{} [rev (a b c d e)]
   |  [rev (b c d e)]
   |  |  [rev (c d e)]
   |  |  |  [rev (d e)]
   |  |  |  |  [rev (e)]
   |  |  |  |  |  [rev ()]
   |  |  |  |  |  ()
   |  |  |  |  (e)
   |  |  |  (e d)
   |  |  (e d c)
   |  (e d c b)
   (e d c b a)
   (e d c b a)
@end lisp
 
Note the way Guile indents the output, illustrating the depth of
execution at each function call.  This can be used to demonstrate, for
example, that Guile implements self-tail-recursion properly:
 
@lisp
(define (rev ls sl)
  (if (null? ls)
      sl
      (rev (cdr ls)
           (cons (car ls) sl)))) @result{} rev
 
(trace rev) @result{} (rev)
 
(rev '(a b c d e) '())
@result{} [rev (a b c d e) ()]
   [rev (b c d e) (a)]
   [rev (c d e) (b a)]
   [rev (d e) (c b a)]
   [rev (e) (d c b a)]
   [rev () (e d c b a)]
   (e d c b a)
   (e d c b a)
@end lisp
 
Since the tail call is effectively optimized to a @code{goto} statement,
there is no need for Guile to create a new stack frame for each
iteration.  Using @code{trace} here helps us see why this is so.
 
@node Backtrace
@appendixsec Backtrace

@page
@node Indices
@unnumbered Indices
	--- At the top of the function/variable index, remind people
            to look for functions under their Scheme names as well as
            their C names.

@node Concept Index
@unnumbered Concept Index
@printindex cp


@node Procedure Index
@unnumbered Procedure Index
This is an alphabetical list of all the procedures and macros in Guile.
@printindex fn


@node Variable Index
@unnumbered Variable Index
This is an alphabetical list of all the important variables and
constants in Guile.
@printindex vr


@c Spell out this node fully, because it is the last real node
@c in the top-level menu.  Leaving off the pointers here causes
@c spurious makeinfo errors.
@node Type Index
@unnumbered Type Index
This is an alphabetical list of all the important data types defined in
the Guile Programmers Manual.
@printindex tp

