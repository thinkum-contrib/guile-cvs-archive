This is guile-lightning
------------------------

Guile-lightning makes the JIT compiler GNU Lightning available to
Guile.


Assembler syntax from Scheme: (this is mostly boring except for labels
and arguments)

- Register names

  r0, r1, r2, v0, v1, v2, ret, sp

- Immediates

  integers

- Labels

  Symbols correspond to places in the assembled code, like

  (  :
    (bltr_i foo r0 r1)
     :
   foo
    (addi_i r0 r0 4))

  Strings refer to libguile primitive functions, like "sum", which
  tries to find "scm_sum" and uses its address.

- Binary ALU operations

  "add" is the same as "add.i"

  (add r0 r1 s3) is "addi" when s3 is an integer, "addr" when it is a
                 register name.

  etc

- Unary ALU operations

  (neg r0 r1)
  etc

- Compare instructions

  (lt r0 r1 r2)
  etc

- Transfer instructions

  (mov r0 r1)
  etc

- Network extensions

  (hton r0 r1)
  etc

- Load operations

  (ld r0 r1)
  (ldx r0 r1 r2)
  etc

- Store operations

  (st r0 r1)
  (stx r0 r1 r2)
  etc

- Stack management

  (push r0)
  etc

- Argument management

  (prepare n)
  (pusharg r0)

  (prolog n)
  (leaf n)
  (arg name)      assigns `name' to the argument declared by this pseudo-op
  (getarg r0 name)  refers to argument `name'

- Branch instructions

  (blt label r0 r1)

- Jump and return operations

  (call label)
  (finish label)
  (jmp label)
  (jmp r0)
  (ret)
  (retval r0)
