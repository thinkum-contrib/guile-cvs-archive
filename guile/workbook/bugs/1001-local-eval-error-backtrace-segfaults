summary: local-eval error bactrace segfaults
reported: M Johnson <johns776@pilot.msu.edu>, 2002-02-12
affects: HEAD

M Johnson sez:
> I'm assuming that when (backtrace) seg-faults that that is a bug, no matter how screwed up my cod may be.
>
>
> To recreate, put the following into a file, say segf.scm
>
> (define (assignments commandls)
>   (let	((env (the-environment )))
>   (for-each
>    (lambda (triplet)
>      (let ((x (car triplet))
> 	   (y (cadr triplet))
> 	   (z (caddr triplet)))
>        (local-eval `(define ,x (option-ref options ,y ,z)) env)))
>
>    '((a b c)(d e f)))))
>
>
>
> this is what happens with a guile from a cvs snapshot (20020209):
>
> [mi@localhost scheme]$ guile1.5
> guile> (load "segf.scm")
> guile>  (assignments (command-line))
> <unnamed port>: In expression (define a (option-ref options b ...)):
> <unnamed port>: Bad define placement
> ABORT: (misc-error)
>
> Type "(backtrace)" to get more information or "(debug)" to enter the debugger.
> guile> (backtrace )
>
> Backtrace:
> In current input:
>    2: 0* [assignments ("guile1.5")]
> In segf.scm:
>    2: 1  (let ((env #)) (for-each (lambda # #) (quote #)))
>    3: 2  Segmentation fault
>
> now with guile 1.4:
> [mi@localhost scheme]$ guile
> guile>  (load "segf.scm")
> guile>  (assignments (command-line))
> ERROR: In expression (define a (option-ref options b ...)):
> ERROR: Bad define placement
> ABORT: (misc-error)
>
> Type "(backtrace)" to get more information or "(debug)" to enter the debugger.
> guile> (backtrace)
>
> Backtrace:
> 0* [assignments ("guile")]
> 1  (let ((env #)) (for-each (lambda # #) (quote #)))
> 2  Segmentation fault

ttn sez:
> it appears the environment at segf time has both `a' and `commandls' as
> names, but no value for `a':
>
> (gdb) gp env
> $5 = 0x80651c8 "(((a commandls) (\"/usr/local/bin/guile\")) #<eval-closure 40245828>)"
>
> because the bad-define-placement error is correct -- using `local-eval'
> requires application and thus the head-of-scope requirement for internal
> defines cannot be met -- my question then becomes: why is `a' in the
> environment at all?

M Johnson later sez:
> Here is a simplified version of segf.scm:
>
>
> (define (fnc args)
>   (local-eval  '(define a b) (the-environment)))
>
>
> Note that backtrace now works, but there's still a problem:
>
>
> guile> guile> (fnc '(hello))
> standard input:2:17: In expression (define a b):
> standard input:2:17: Bad define placement
> ABORT: (misc-error)
>
> Type "(backtrace)" to get more information or "(debug)" to enter the debugger.
> guile> (debug)
> This is the Guile debugger; type "help" for help.
> There are 3 frames on the stack.
>
> Frame 2:    (define a b)
> debug> eval (the-environment)
> ;value: (((a a args) (hello)) #<compiled-closure #<primitive-procedure eval-closure>>)
> debug> ba
> 0* [fnc (hello)]
> 1  [local-eval # #]
> 2* (define a b)
> debug> eval (the-environment)
>
> Process scheme segmentation fault
>
>
>
> Note also that here we're getting 2 "a"s in the environment. (sometimes i got three, perhaps with slightly different code)

mvo sez:
> If we can fix the bug that is great, but if it's too hairy, we can
> just remove local-eval.  Local-eval is weird critter...

ttn sez:
> second posted test case is sadistic; ignoring for now.
