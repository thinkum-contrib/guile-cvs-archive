The Problem
===========

Certain applications embedding Guile (Scwm, Guppi) have found it
necessary to include hacked versions of scm_call_with_dynamic_root.

They want to run user callbacks, but don't want the callback to be
able to longjmp (via exceptions or continuations) randomly in and out,
since the C code hasn't been written to dynamically wind/unwind local
state.  This is likely to be a common problem for users of Guile as an
extension language.

libguile/root.c:scm_call_with_dynamic_root seems to almost do this,
but it has the apparently undesirable behaviour of unwinding the
dynamic state when the protected procedure is called.  In addition
the implementation looks a bit heavy for use in every callback.

scm_call_with_dynamic_root was implemented to support threading, so
the needs of libguile itself should be considered.  Other
considerations are how any new interface interacts with error handling
and reporting; whether a new interface is convenient to use from C;
whether a new interface should also be available to Scheme code.

Example
=======

We have a procdure that executes a procedure supplied by a user.
It's essential that the code before and after the user-proc is
executed in the right order: maybe it's C code that opens and
closes files or allocates/frees memory:

(define break-me (lambda (user-proc)
		   (display "executing user ...\n")
		   (user-proc)
		   (display "... done\n")))

Now the user types:

(define cont #f)
(break-me (lambda ()
	    (call-with-current-continuation (lambda (c)
					      (set! cont c)))))

giving:

"executing user ...
... done"

but then:

(cont #f) gives:

"... done"

Discussion
==========

There are two ways that longjmp may be invoked from a Scheme callback:
raising an exception or invoking a continuation.  Exceptions can be
caught using scm_internal_catch, but a primitive "continuation
barrier" is lacking. However such a barrier can be easily created
using dynamic-wind, assuming that an error can be signalled within the
before- thunk:

(define with-continuation-barrier
  (lambda (thunk)
    (let ((entered #f))
      (dynamic-wind
	  (lambda ()
	    (if entered
		(error "Attempt to break continuation barrier")
		(set! entered #t)))
	  thunk
	  (lambda () #f)))))

The example above can now be fixed:

(define break-me (lambda (user-proc)
		   (display "executing user ...\n")
		   (with-continuation-barrier user-proc)
		   (display "... done\n")))

The interesting problem is the interaction between exceptions and
continations.  While exceptions that occur in user code should be
caught so that the cleanup code can be executed, the cleanup code
should not be called for the exception raised by
with-continuation-barrier itself.  Thus the exception handler needs to
go inside the continuation barrier.  This also avoids any assumption
that exceptions can pass through the continuation barrier, i.e.,
current Guile behaviour where exceptions are indendent of
continuations.

A problem with this is that an outer exception handler would catch
both exceptions from the user code and exceptions generated by the
continuation barrier: i.e., possibly more than once for a given
invocation.  The current call-with-dynamic-root implementation avoids
this by refusing to invoke mismatching continuations in the first
place, by examining a sequence number in the dynamic root.  However
it's not clear that presence of the dynamic root implementation is
something that can be relied on in the long term.

(define (break-me user-proc)
  (catch #t
	 (lambda ()
	   (display "executing user ...\n")
	   (with-continuation-barrier user-proc)
	   (display "... done\n"))
	 (lambda args
	   (display "outer catch!\n")
	   (write args))))

guile> (define cont #f)
(break-me (lambda ()
	    (call-with-current-continuation (lambda (c)
					      (set! cont c)))))

guile> executing user ...
... done
guile> (cont #f)
Segmentation fault

Hmmm, it's even worse than I thought.

For ease of use, we would like to have a single facility to set up
both continuation and exception handlers.  Such an interface should
take at least a) the callback to be protected b) and exception handler
and associated handler data to be passed to scm_internal_catch.

How should the callback procedure be passed to the interface and
invoked?  Should it be like scm_internal_catch where it's passed as a
C procedure (scm_t_catch_body) which is applied to user data (void *)?
For a procedure designed to be used from C, this is the most
convenient, since constructing closures in C is difficult.  It also
gives symmetry with scm_internal_catch.

On the other hand, the body procedure is expected to be a Scheme
closure in most cases.  This suggests implementing two C procedures,
the first taking four arguments:

scm_t_catch_body body, void *body_data,
scm_t_catch_handler handler, void *handler_data

and the second taking three arguments:
SCM body, scm_t_catch_handler handler, void *handler_data

If there is also to be a Scheme interface, then it would be implemented
with a third variant:
SCM body, SCM handler

The second and third variants would be implemented by calling the
first, similar to the old scm_call_with_dynamic_root and its wrappers.

The return value from all variants should be the result of calling
the body, unless an exception occurred in which case it's the result
of calling the handler.  So the return type is SCM, as for
scm_internal_catch.

To do
=====

libguile usage and threads, error handling and reporting, convenience
of use, Scheme-level interface.
