The Problem
===========

Certain applications embedding Guile (Scwm, Guppi) have found it
necessary to include hacked versions of scm_call_with_dynamic_root.

They want to run user callbacks, but don't want the callback to be
able to longjmp (via exceptions or continuations) randomly in and out,
since the C code hasn't been written to dynamically wind/unwind local
state.  This is likely to be a common problem for users of Guile as an
extension language.

libguile/root.c:scm_call_with_dynamic_root seems to almost do this,
but it has the apparently undesirable behaviour of unwinding the
dynamic state when the protected procedure is called.  In addition
the implementation looks a bit heavy for use in every callback.

scm_call_with_dynamic_root was implemented to support threading, so
the needs of libguile itself should be considered.  Other
considerations are how any new interface interacts with error handling
and reporting; whether a new interface is convenient to use from C;
whether a new interface should also be available to Scheme code.

Another thing to consider is whether the implementation of this feature
is always going to be tied to the dynamic-root concept, or whether
it could be implemented in some other way.

Finally, there is the consideration of whether all this is just more
trouble than it's worth: perhaps the applications that want this
feature should either a) protect their code properly against Scheme
flow-control b) forbid use of call/cc in callbacks c) forbid accessing
the top-level environment in callbacks.

Example
=======

We have some code that executes a procedure supplied by a user.
It's essential that the code before and after the user-proc is
executed in the right order: maybe it's C code that opens and
closes files or allocates/frees memory:

(define break-me (lambda (user-proc)
		   (display "executing user ...\n")
		   (user-proc)
		   (display "... done\n")))

Now the user types:

(define cont #f)
(break-me (lambda ()
	    (call-with-current-continuation (lambda (c)
					      (set! cont c)))))

giving:

"executing user ...
... done"

but then:

(cont #f) gives:

"... done"

i.e., the user has jumped back into the callback via a continuation.

Alternatively, the user can jump out of the callback:

(define cont #f)
(call-with-current-continuation (lambda (c) (set! cont c)))
(break-me (lambda ()
	    (cont)))

Discussion
==========

There are two ways that longjmp may be invoked from a Scheme callback:
raising an exception or invoking a continuation.  Exceptions can be
caught using scm_internal_catch, but a primitive "continuation
barrier" is lacking. A reentry barrier can be easily created
using dynamic-wind, assuming that an error can be signalled within the
before- thunk:

(define with-reentry-barrier
  (lambda (thunk)
    (let ((entered #f))
      (dynamic-wind
	  (lambda ()
	    (if entered
		(error "Attempt to break reentry barrier")
		(set! entered #t)))
	  thunk
	  (lambda () #f)))))

The jump-back-in example above may now be fixed:

(define break-me (lambda (user-proc)
		   (display "executing user ...\n")
		   (with-reentry-barrier user-proc)
		   (display "... done\n")))

However the jump-out example is resistent to this technique.  In any
case the interaction of dynamic-wind and continuations and exceptions
is likely to cause strange and unstable behaviour:

guile> (define (break-me user-proc)
  (catch #t
	 (lambda ()
	   (display "executing user ...\n")
	   (with-reentry-barrier user-proc)
	   (display "... done\n"))
	 (lambda args
	   (display "outer catch!\n")
	   (write args))))

guile> (define cont #f)
(break-me (lambda ()
	    (call-with-current-continuation (lambda (c)
					      (set! cont c)))))

guile> executing user ...
... done
guile> (cont #f)
Segmentation fault

The existing dynamic-root method avoids such difficulties by
preventing the execution of continuations that would cross the
continuation barrier, instead of trying to clean things up after the
continuation has been executed.

For ease of use, we would like to have a single facility to set up
both continuation and exception handlers.  Such an interface should
take at least a) the callback to be protected b) and exception handler
and associated handler data to be passed to scm_internal_catch.

How should the callback procedure be passed to the interface and
invoked?  Should it be like scm_internal_catch where it's passed as a
C procedure (scm_t_catch_body) which is applied to user data (void *)?
For a procedure designed to be used from C, this is the most
convenient, since constructing closures in C is difficult.  It also
gives symmetry with scm_internal_catch.

On the other hand, the body procedure is expected to be a Scheme
closure in most cases.  This suggests implementing two C procedures,
the first taking four arguments:

scm_t_catch_body body, void *body_data,
scm_t_catch_handler handler, void *handler_data

and the second taking three arguments:
SCM body, scm_t_catch_handler handler, void *handler_data

If there is also to be a Scheme interface, then it would be implemented
with a third variant:
SCM body, SCM handler

The second and third variants would be implemented by calling the
first, similar to the old scm_call_with_dynamic_root and its wrappers.

The return value from all variants should be the result of calling
the body, unless an exception occurred in which case it's the result
of calling the handler.  So the return type is SCM, as for
scm_internal_catch.

To do
=====

libguile usage and threads, error handling and reporting, convenience
of use, Scheme-level interface.

References
==========

Thread on guile mailing list discussing dynamic roots, March 2000
    -- http://sources.redhat.com/ml/guile/2000-03/msg00461.html
Jim Blandy suggested looking at a few articles, but these appear to
propose more fundamental changes to the concept of call/cc.
