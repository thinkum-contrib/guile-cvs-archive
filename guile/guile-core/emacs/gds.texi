\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename gds.info
@settitle GDS --- Support for Guile Development in Emacs

@include version.texi

@dircategory The Algorithmic Language Scheme
@direntry
* GDS: (gds).        Docs for GDS.
@end direntry

@setchapternewpage off
@c Choices for setchapternewpage are {on,off,odd}.
@paragraphindent 2
@c %**end of header

@smallbook

@iftex
@finalout
@c DL: lose the egregious vertical whitespace, esp. around examples
@c but paras in @defun-like things don't have parindent
@parskip 4pt plus 1pt
@end iftex

@titlepage
@title GDS --- Guile Support in Emacs
@subtitle For use with Guile 1.7.x and later
@subtitle Last updated @value{UPDATED}

@author Neil Jerram
@author @email{neil@@ossau.uklinux.net}

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2003 Neil Jerram

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the author.
@end titlepage

@contents

@ifinfo
@node Top
@top GDS --- Support for Guile Development in Emacs
@end ifinfo

@ifinfo
This file documents the features provided by GDS.

Copyright (C) 2003 Neil Jerram

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the author.
@end ifinfo

@menu
* Preface::
* Introduction::
* Interaction Models::
@end menu


@page
@node Preface
@unnumbered Preface

One of my motivations in documenting aspects of GDS now, while it is
still under development, is to allow others to help me finish the work!
If you find the following text interesting and would like to help me
with this, please contact me at @email{neil@@ossau.uklinux.net}.


@page
@node Introduction
@chapter Introduction

GDS is a collection of features designed to help programmers writing
Guile Scheme programs in Emacs.

@table @asis
@item Easy access to Guile's help system
GDS provides keystrokes analogous to @kbd{C-h f} and @kbd{C-h v} for
Elisp functions and variables, to popup information from Guile's
@code{help} and @code{apropos} commands in an Emacs Help buffer in
another window.

@item Dynamic symbol completion
GDS provides a keystroke like Elisp's @kbd{M-@key{TAB}} that does
completion of the Guile symbol before point.  The possible completions
are computed by querying the associated running Guile process and so
always include all the symbols that are known to Guile.

@item Evaluating code from Emacs
GDS provides keystrokes like @kbd{C-x C-e} for Elisp that make it easy
to evaluate (or reevaluate) Guile code from within an Emacs buffer.  The
results of the evaluation are popped up in an Emacs buffer in another
window.

@item Setting and managing breakpoints
GDS makes @kbd{C-x @key{SPC}} set a breakpoint in Guile source code in
much the same way as it does for C code with GDB.  GDS can also display
a list of active breakpoints, and makes it easy for the programmer to
enable or disable them, change what happens when the breakpoint is hit,
and so on.

@item Interactive debugging
When a Guile program enters the debugger, because of hitting a
breakpoint or an error, GDS shows the Guile stack and corresponding
source code in Emacs windows, and provides keystrokes for single
stepping, stack frame selection, evaluation in the selected stack frame,
and so on.

@item Source code browsing
When a Guile program is running, GDS can display a browser that shows
all its loaded modules, and the bindings in each module.  The browser
can be used as an easy way of navigating to the corresponding Emacs
source buffer.

@item Controlling a Guile program
Besides breakpoints, GDS provides some other kinds of control over a
Guile program, including the ability to break into a running program
without having set an appropriate breakpoint in advance.
@end table

GDS was designed with specific models in mind of how it would be most
effective for a programmer working on a Guile program to interact with
Guile and with Emacs, and to get the most out of your use of GDS it is
important to understand those models.  Therefore the first of the
following sections explains those models.  The sections after that
document each of the above feature areas in full.


@page
@node Interaction Models
@chapter Interaction Models

GDS is designed for two main ways of working with Guile and Emacs:
writing a Guile script or module, and interaction with an existing Guile
program.

@menu
* New Writing::                 Writing a new script or module.
* Existing Program::            Interaction with an existing program.
* Model Similarities::          How the two models are related.
* GDS and Threads::             GDS's use of multiple threads.
@end menu


@node New Writing
@section Writing a Guile Script or Module

The picture here is that you are editing a Guile source code file
(usually Scheme, but hopefully other languages in the future) in a
buffer in Emacs.  As you write, you may like to get help or completions
for the symbol under the cursor, and you may want to evaluate fragments
of code from the program you are writing, to check that they behave as
you intend.  If a code fragment doesn't behave as intended, you may like
to set a breakpoint or two and then evaluate the fragment again, using
the debugger (through GDS) to explore the problem.

These features require a running Guile process, so GDS automatically
starts up a suitable instance of Guile as needed.  This is hidden from
the user, though, so you never `see' the autocreated Guile process
directly; you just see its effects through completions, help and
evaluation result windows.


@node Existing Program
@section Interaction with an Existing Guile Program

The other picture is working with --- that is, debugging, exploring or
extending --- an existing, running Guile program.  In this case, because
the program is not started by GDS, the program must be modified to set
up a connection to the GDS interface in Emacs: this is easily done by
adding a @code{(gds-connect @dots{})} expression to the program's code.

You can then use GDS in all the same ways as in the first picture, for
example to set breakpoints in code that you expect the program to hit
and then explore what happens, or to evaluate new code in the program
context.


@node Model Similarities
@section How the Two Models are Related

The two models just described are actually quite related.  The
autocreated Guile process that is created on demand for the first model
can be seen as a simple application.  Once that process has started
up, GDS's interaction with it is the same as with a preexisting Guile
program started independently of GDS.

Specifically, the autocreated Guile process runs Guile with basically
the following script.

@lisp
(gds-connect @dots{})
(select (list (current-input-port)) '() '())
@end lisp

@noindent
The @code{gds-connect} expression is the same as required in a program
under the second model, and the @code{select} expression serves just to
keep the program from exiting.


@node GDS and Threads
@section GDS and Threads

GDS requires a Guile that can run multiple threads.@footnote{In
developing GDS, I've been using the pthreads currently in Guile CVS@.
GDS should also work with a cooperative threads implementation, if and
when that is available again for Guile.}

@code{gds-connect} creates a new thread in the application that calls
it.  This thread is used to send information about the application to
the GDS front end in Emacs, and to listen for instructions to the
application, for example to set a breakpoint or get help for a symbol,
from the GDS front end user.

GDS creates further new threads in the application when asked to
evaluate code from Emacs.  In many cases only one evaluation thread is
required, and all code sent from Emacs is evaluated in that thread.  The
idea behind this is that the effect of a sequence of evaluations from
Emacs should be as similar as possible to the effect of the same
sequence when run as a Guile script or loaded as a Guile module.

Further evaluation threads are needed if the first thread is held up,
because the code that it is evaluating either stops in the debugger, or
keeps running for a long time.  For example, a common sequence of useful
steps when investigating some code would be to

@enumerate
@item
set a breakpoint in the code under investigation

@item
evaluate an expression that uses that code

@item
depending on what you see in the debugger, set further breakpoints.
@end enumerate

@noindent
The setting of further breakpoints in step 3 requires a new evaluation,
which cannot be done in the original evaluation thread because that
thread is stopped in the debugger, waiting for instruction from the GDS
user to tell it to continue.

Overall, then, the set of threads in an application connected to GDS is
as follows.

@itemize @bullet
@item
The application's main thread (created when the application first starts
running).

@item
Any subsidiary threads created by the application code.

@item
The GDS communication thread created by @code{gds-connect}.

@item
Any number of GDS evaluation threads whose evaluation is still in
progress, or stopped in the debugger.@footnote{Currently the Guile
debugger and the GDS user interface do not support more than one thread
being stopped in the debugger at the same time.  If a thread tries to
enter the debugger while another thread is already in the debugger, a
non-debuggable error is signaled.}

@item
A GDS evaluation thread that is not in use, and so available for
evaluating new code from Emacs.
@end itemize


@bye
