This is goops.info, produced by makeinfo version 4.0 from goops.texi.

INFO-DIR-SECTION Scheme Programming
START-INFO-DIR-ENTRY
* goops: (goops).          The GOOPS reference manual.
END-INFO-DIR-ENTRY

This file documents GOOPS, an object oriented extension for Guile.

Copyright (C) 1999 Free Software Foundation

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.


File: goops.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

* Menu:

[When the manual is completed, this will be a flat index in the style of
 the Emacs manual.  More nodes will turn up under parts I-III.]

Part I: Preliminaries

* Introduction::
* Getting Started::

Part II: Reference Manual

* Reference Manual::

Part III: GOOPS Meta Object Protocol

* MOP specification::

The GOOPS tutorial

* Tutorial::

* Index::
* Concept Index::
* Function and Variable Index::


File: goops.info,  Node: Introduction,  Next: Getting Started,  Prev: Top,  Up: Top

Introduction
============

GOOPS is the object oriented extention to Guile. Its implementation is
derived from STk-3.99.3 by Erick Gallesio and version 1.3 of Gregor
Kickzales `Tiny-Clos'.  It is very close in spirit to CLOS, the Common
Lisp Object System (`CLtL2') but is adapted for the Scheme language.
While GOOPS is not compatible with any of these systems, GOOPS contains
a compatibility module which allows for execution of STKlos programs.

Briefly stated, the GOOPS extension gives the user a full object
oriented system with multiple inheritance and generic functions with
multi-method dispatch.  Furthermore, the implementation relies on a true
meta object protocol, in the spirit of the one defined for CLOS
(`Gregor Kiczales: A Metaobject Protocol').


File: goops.info,  Node: Getting Started,  Next: Reference Manual,  Prev: Introduction,  Up: Top

Getting Started
===============

* Menu:

* Running GOOPS::

Examples of some basic GOOPS functionality.

* Methods::
* User-defined types::
* Asking for the type of an object::

See further in the GOOPS tutorial available in this distribution in
info (goops.info) and texinfo format.


File: goops.info,  Node: Running GOOPS,  Next: Methods,  Prev: Getting Started,  Up: Getting Started

Running GOOPS
-------------

  1. Type

          guile-oops

     You should now be at the Guile prompt ("guile> ").

  2. Type

          (use-modules (oop goops))

     to load GOOPS.  (If your system supports dynamic loading, you
     should be able to do this not only from `guile-oops' but from an
     arbitrary Guile interpreter.)

We're now ready to try some basic GOOPS functionality.


File: goops.info,  Node: Methods,  Next: User-defined types,  Prev: Running GOOPS,  Up: Getting Started

Methods
-------

     (define-method + ((x <string>) (y <string>))
       (string-append x y))
     
     (+ 1 2) --> 3
     (+ "abc" "de") --> "abcde"


File: goops.info,  Node: User-defined types,  Next: Asking for the type of an object,  Prev: Methods,  Up: Getting Started

User-defined types
------------------

     (define-class <2D-vector> ()
       (x #:init-value 0 #:accessor x-component #:init-keyword #:x)
       (y #:init-value 0 #:accessor y-component #:init-keyword #:y))
     
     (use-modules (ice-9 format))
     
     (define-method write ((obj <2D-vector>) port)
       (display (format #f "<~S, ~S>" (x-component obj) (y-component obj))
                port))
     
     (define v (make <2D-vector> #:x 3 #:y 4))
     
     v --> <3, 4>
     
     (define-method + ((x <2D-vector>) (y <2D-vector>))
       (make <2D-vector>
             #:x (+ (x-component x) (x-component y))
             #:y (+ (y-component x) (y-component y))))
     
     (+ v v) --> <6, 8>


File: goops.info,  Node: Asking for the type of an object,  Prev: User-defined types,  Up: Getting Started

Types
-----

     (class-of v) --> #<<class> <2D-vector> 40241ac0>
     <2D-vector>  --> #<<class> <2D-vector> 40241ac0>
     (class-of 1) --> #<<class> <integer> 401b2a98>
     <integer>    --> #<<class> <integer> 401b2a98>
     
     (is-a? v <2D-vector>) --> #t


File: goops.info,  Node: Reference Manual,  Next: MOP specification,  Prev: Getting Started,  Up: Top

Reference Manual
****************

[TO BE WRITTEN]


File: goops.info,  Node: MOP specification,  Next: Tutorial,  Prev: Reference Manual,  Up: Top

MOP specification
*****************

[TO BE WRITTEN]


File: goops.info,  Node: Tutorial,  Next: Index,  Prev: MOP specification,  Up: Top

Tutorial
********

This is chapter was originally written by Erick Gallesio as an appendix
for the STk reference manual, and subsequently adapted to GOOPS.

* Menu:

* Copyright::
* Intro::
* Class definition and instantiation::
* Inheritance::
* Generic functions::


File: goops.info,  Node: Copyright,  Next: Intro,  Prev: Tutorial,  Up: Tutorial

Copyright
=========

Original attribution:

STk Reference manual (Appendix: An Introdution to STklos)

Copyright (C) 1993,1994,1995 Erick Gallesio - I3S-CNRS/ESSI
<eg@unice.fr>

Permission to use, copy, and/or distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that both the above copyright notice and this permission
notice appear in all copies and derived works.  Fees for distribution
or use of this software or derived works may only be charged with
express written permission of the copyright holder.  This software is
provided "as is" without express or implied warranty.

Author: Erick Gallesio [eg@unice.fr]    Creation date: 22-May-1994 22:13
Last file update: 22-Apr-1998 11:04

Adapted for use in Guile with the authors permission


File: goops.info,  Node: Intro,  Next: Class definition and instantiation,  Prev: Copyright,  Up: Tutorial

Introduction
============

GOOPS is the object oriented extention to Guile. Its implementation is
derived from STk-3.99.3 by Erick Gallesio and version 1.3 of the Gregor
Kickzales `Tiny-Clos'.  It is very close to CLOS, the Common Lisp
Object System (`CLtL2') but is adapted for the Scheme language.

Briefly stated, the GOOPS extension gives the user a full object
oriented system with multiple inheritance and generic functions with
multi-method dispatch.  Furthermore, the implementation relies on a true
meta object protocol, in the spirit of the one defined for CLOS
(`Gregor Kiczales: A Metaobject Protocol').

The purpose of this tutorial is to introduce briefly the GOOPS package
and in no case will it replace the GOOPS reference manual (which needs
to be urgently written now ...).

Note that the operations described in this tutorial resides in modules
that may need to be imported before being available.  The main module is
imported by evaluating:

     (use-modules (oop goops))


File: goops.info,  Node: Class definition and instantiation,  Next: Inheritance,  Prev: Intro,  Up: Tutorial

Class definition and instantiation
==================================

* Menu:

* Class definition::


File: goops.info,  Node: Class definition,  Prev: Class definition and instantiation,  Up: Class definition and instantiation

Class definition
----------------

A new class is defined with the `define-class'(1) macro. The syntax of
`define-class' is close to CLOS `defclass':

     (define-class CLASS (SUPERCLASS ...)
        SLOT-DESCRIPTION ...
        CLASS-OPTION ...)

Class options will not be discussed in this tutorial.  The list of
SUPERCLASSes specifies which classes to inherit properties from CLASS
(see *Note Inheritance:: for more details).  A SLOT-DESCRIPTION gives
the name of a slot and, eventually, some "properties" of this slot
(such as its initial value, the function which permit to access its
value, ...). Slot descriptions will be discussed in *Note Slot
description::.

As an example, let us define a type for representation of complex
numbers in terms of real numbers. This can be done with the following
class definition:

     (define-class  <complex> (<number>)
        r i)

This binds the variable `<complex>'(2) to a new class whose instances
contain two slots. These slots are called `r' an `i' and we suppose here
that they contain respectively the real part and the imaginary part of a
complex number. Note that this class inherits from `<number>' which is
a pre-defined class.  (`<number>' is the direct super class of the
pre-defined class `<complex>' which, in turn, is the super class of
`<real>' which is the super of `<integer>'.)(3).

---------- Footnotes ----------

(1) Don't forget to import the `(oop goops)' module

(2) `<complex>' is in fact a builtin class in GOOPS.  Because of this,
GOOPS will create a new class.  The old class will still serve as the
type for Guile's native complex numbers.

(3) With the new definition of `<complex>', a `<real>' is not a
`<complex>' since `<real>' inherits from ` <number>' rather than
`<complex>'. In practice, inheritance could be modified _a posteriori_,
if needed. However, this necessitates some knowledge of the meta object
protocol and it will not be shown in this document


File: goops.info,  Node: Inheritance,  Next: Generic functions,  Prev: Class definition and instantiation,  Up: Tutorial

Inheritance
===========

* Menu:

* Class hierarchy and inheritance of slots::
* Instance creation and slot access::
* Slot description::
* Class precedence list::


File: goops.info,  Node: Class hierarchy and inheritance of slots,  Next: Instance creation and slot access,  Prev: Inheritance,  Up: Inheritance

Class hierarchy and inheritance of slots
----------------------------------------

Inheritance is specified upon class definition. As said in the
introduction, GOOPS supports multiple inheritance.  Here are some class
definitions:

     (define-class A () a)
     (define-class B () b)
     (define-class C () c)
     (define-class D (A B) d a)
     (define-class E (A C) e c)
     (define-class F (D E) f)

`A', `B', `C' have a null list of super classes. In this case, the
system will replace it by the list which only contains `<object>', the
root of all the classes defined by `define-class'. `D', `E', `F' use
multiple inheritance: each class inherits from two previously defined
classes.  Those class definitions define a hierarchy which is shown in
Figure 1.  In this figure, the class `<top>' is also shown; this class
is the super class of all Scheme objects. In particular, `<top>' is the
super class of all standard Scheme types.

               <top>
               / \\\_____________________
              /   \\___________          \
             /     \           \          \
         <object>  <pair>  <procedure>  <number>
         /  |  \                           |
        /   |   \                          |
       A    B    C                      <complex>
       |\__/__   |                         |
        \ /   \ /                          |
         D     E                         <real>
          \   /                            |
            F                              |
                                        <integer>

                         _Fig 1: A class hierarchy_


The set of slots of a given class is calculated by taking the union of
the slots of all its super class. For instance, each instance of the
class D, defined before will have three slots (`a', `b' and `d'). The
slots of a class can be obtained by the `class-slots' primitive.  For
instance,

     (class-slots A) => ((a))
     (class-slots E) => ((a) (e) (c))
     (class-slots F) => ((e) (c) (b) (d) (a) (f))

_Note: _ The order of slots is not significant.


File: goops.info,  Node: Instance creation and slot access,  Next: Slot description,  Prev: Class hierarchy and inheritance of slots,  Up: Inheritance

Instance creation and slot access
---------------------------------

Creation of an instance of a previously defined class can be done with
the `make' procedure. This procedure takes one mandatory parameter
which is the class of the instance which must be created and a list of
optional arguments. Optional arguments are generally used to initialize
some slots of the newly created instance. For instance, the following
form

     (define c (make <complex>))

will create a new `<complex>' object and will bind it to the `c' Scheme
variable.

Accessing the slots of the new complex number can be done with the
`slot-ref' and the `slot-set!'  primitives. `Slot-set!' primitive
permits to set the value of an object slot and `slot-ref' permits to
get its value.

     (slot-set! c 'r 10)
     (slot-set! c 'i 3)
     (slot-ref c 'r) => 10
     (slot-ref c 'i) => 3

Using the `describe' function is a simple way to see all the slots of
an object at one time: this function prints all the slots of an object
on the standard output.

First load the module `(oop goops describe)':

     `(use-modules (oop goops describe))'

The expression

     (describe c)

will now print the following information on the standard output:

     #<<complex> 401d8638> is an instance of class <complex>
     Slots are:
          r = 10
          i = 3


File: goops.info,  Node: Slot description,  Next: Class precedence list,  Prev: Instance creation and slot access,  Up: Inheritance

Slot description
----------------

When specifying a slot, a set of options can be given to the system.
Each option is specified with a keyword. The list of authorised
keywords is given below:

   * `#:init-value' permits to supply a default value for the slot. This
     default value is obtained by evaluating the form given after the
     `#:init-form' in the global environment, at class definition time.

   * `#:init-thunk' permits to supply a thunk that will provide a
     default value for the slot. The value is obtained by evaluating the
     thunk a instance creation time.

   * `#:init-keyword' permits to specify the keyword for initializing a
     slot. The init-keyword may be provided during instance creation
     (i.e. in the `make' optional parameter list). Specifying such a
     keyword during instance initialization will supersede the default
     slot initialization possibly given with `#:init-form'.

   * `#:getter' permits to supply the name for the slot getter. The
     name binding is done in the environment of the `define-class'
     macro.

   * `#:setter' permits to supply the name for the slot setter. The
     name binding is done in the environment of the `define-class'
     macro.

   * `#:accessor' permits to supply the name for the slot accessor. The
     name binding is done in the global environment. An accessor
     permits to get and set the value of a slot. Setting the value of a
     slot is done with the extended version of `set!'.

   * `#:allocation' permits to specify how storage for the slot is
     allocated. Three kinds of allocation are provided.  They are
     described below:

        - `#:instance' indicates that each instance gets its own
          storage for the slot. This is the default.

        - `#:class' indicates that there is one storage location used
          by all the direct and indirect instances of the class. This
          permits to define a kind of global variable which can be
          accessed only by (in)direct instances of the class which
          defines this slot.

        - `#:each-subclass' indicates that there is one storage
          location used by all the direct instances of the class. In
          other words, if two classes are not siblings in the class
          hierarchy, they will not see the same value.

        - `#:virtual' indicates that no storage will be allocated for
          this slot.  It is up to the user to define a getter and a
          setter function for this slot. Those functions must be
          defined with the `#:slot-ref' and `#:slot-set!' options. See
          the example below.

To illustrate slot description, we shall redefine the `<complex>' class
seen before. A definition could be:

     (define-class <complex> (<number>)
        (r #:init-value 0 #:getter get-r #:setter set-r! #:init-keyword #:r)
        (i #:init-value 0 #:getter get-i #:setter set-i! #:init-keyword #:i))

With this definition, the `r' and `i' slot are set to 0 by default.
Value of a slot can also be specified by calling `make' with the `#:r'
and `#:i' keywords. Furthermore, the generic functions `get-r' and
`set-r!' (resp. `get-i' and `set-i!') are automatically defined by the
system to read and write the `r' (resp. `i') slot.

     (define c1 (make <complex> #:r 1 #:i 2))
     (get-r c1) => 1
     (set-r! c1 12)
     (get-r c1) => 12
     (define c2 (make <complex> #:r 2))
     (get-r c2) => 2
     (get-i c2) => 0

Accessors provide an uniform access for reading and writing an object
slot.  Writing a slot is done with an extended form of `set!' which is
close to the Common Lisp `setf' macro. So, another definition of the
previous `<complex>' class, using the `#:accessor' option, could be:

     (define-class <complex> (<number>)
        (r #:init-value 0 #:accessor real-part #:init-keyword #:r)
        (i #:init-value 0 #:accessor imag-part #:init-keyword #:i))

Using this class definition, reading the real part of the `c' complex
can be done with:
     (real-part c)
and setting it to the value contained in the `new-value' variable can
be done using the extended form of `set!'.
     (set! (real-part c) new-value)

Suppose now that we have to manipulate complex numbers with rectangular
coordinates as well as with polar coordinates. One solution could be to
have a definition of complex numbers which uses one particular
representation and some conversion functions to pass from one
representation to the other.  A better solution uses virtual slots. A
complete definition of the `<complex>' class using virtual slots is
given in Figure 2.

          (define-class <complex> (<number>)
             ;; True slots use rectangular coordinates
             (r #:init-value 0 #:accessor real-part #:init-keyword #:r)
             (i #:init-value 0 #:accessor imag-part #:init-keyword #:i)
             ;; Virtual slots access do the conversion
             (m #:accessor magnitude #:init-keyword #:magn
                #:allocation #:virtual
                #:slot-ref (lambda (o)
                            (let ((r (slot-ref o 'r)) (i (slot-ref o 'i)))
                              (sqrt (+ (* r r) (* i i)))))
                #:slot-set! (lambda (o m)
                              (let ((a (slot-ref o 'a)))
                                (slot-set! o 'r (* m (cos a)))
                                (slot-set! o 'i (* m (sin a))))))
             (a #:accessor angle #:init-keyword #:angle
                #:allocation #:virtual
                #:slot-ref (lambda (o)
                            (atan (slot-ref o 'i) (slot-ref o 'r)))
                #:slot-set! (lambda(o a)
                             (let ((m (slot-ref o 'm)))
                                (slot-set! o 'r (* m (cos a)))
                                (slot-set! o 'i (* m (sin a)))))))

     _Fig 2: A `<complex>' number class definition using virtual slots_





This class definition implements two real slots (`r' and `i'). Values
of the `m' and `a' virtual slots are calculated from real slot values.
Reading a virtual slot leads to the application of the function defined
in the `#:slot-ref' option. Writing such a slot leads to the
application of the function defined in the `#:slot-set!' option.  For
instance, the following expression

     (slot-set! c 'a 3)

permits to set the angle of the `c' complex number. This expression
conducts, in fact, to the evaluation of the following expression

     ((lambda o m)
         (let ((m (slot-ref o 'm)))
            (slot-set! o 'r (* m (cos a)))
            (slot-set! o 'i (* m (sin a))))
       c 3)

A more complete example is given below:

          (define c (make <complex> #:r 12 #:i 20))
          (real-part c) => 12
          (angle c) => 1.03037682652431
          (slot-set! c 'i 10)
          (set! (real-part c) 1)
          (describe c) =>
                    #<<complex> 401e9b58> is an instance of class <complex>
                    Slots are:
                         r = 1
                         i = 10
                         m = 10.0498756211209
                         a = 1.47112767430373

Since initialization keywords have been defined for the four slots, we
can now define the `make-rectangular' and `make-polar' standard Scheme
primitives.

     (define make-rectangular
        (lambda (x y) (make <complex> #:r x #:i y)))
     
     (define make-polar
        (lambda (x y) (make <complex> #:magn x #:angle y)))


File: goops.info,  Node: Class precedence list,  Prev: Slot description,  Up: Inheritance

Class precedence list
---------------------

A class may have more than one superclass.  (1) With single inheritance
(one superclass), it is easy to order the super classes from most to
least specific. This is the rule:

     Rule 1: Each class is more specific than its superclasses.

With multiple inheritance, ordering is harder. Suppose we have

     (define-class X ()
        (x #:init-value 1))
     
     (define-class Y ()
        (x #:init-value 2))
     
     (define-class Z (X Y)
        (...))

In this case, the `Z' class is more specific than the `X' or `Y' class
for instances of `Z'. However, the `#:init-value' specified in `X' and
`Y' leads to a problem: which one overrides the other?  The rule in
GOOPS, as in CLOS, is that the superclasses listed earlier are more
specific than those listed later.  So:

     Rule 2: For a given class, superclasses listed earlier are more
             specific than those listed later.

These rules are used to compute a linear order for a class and all its
superclasses, from most specific to least specific.  This order is
called the "class precedence list" of the class. Given these two rules,
we can claim that the initial form for the `x' slot of previous example
is 1 since the class `X' is placed before `Y' in class precedence list
of `Z'.

These two rules are not always enough to determine a unique order,
however, but they give an idea of how things work.  Taking the `F'
class shown in Figure 1, the GOOPS calculated class precedence list is

     (f d e a b c <object> <top>)

whereas it would be the following list with a CLOS-like algorithm:

     (f d e a c b <object> <top>)

However, it is usually considered a bad idea for programmers to rely on
exactly what the order is.  If the order for some superclasses is
important, it can be expressed directly in the class definition.

The precedence list of a class can be obtained by the function
`class-precedence-list'. This function returns a ordered list whose
first element is the most specific class. For instance,

     (class-precedence-list B) => (#<<class> B 401b97c8>
                                          #<<class> <object> 401e4a10>
                                          #<<class> <top> 4026a9d8>)

However, this result is not too much readable; using the function
`class-name' yields a clearer result:

     (map class-name (class-precedence-list B)) => (B <object> <top>)

---------- Footnotes ----------

(1) This section is an adaptation of Jeff Dalton's (J.Dalton@ed.ac.uk)
`Brief introduction to CLOS'


File: goops.info,  Node: Generic functions,  Prev: Inheritance,  Up: Tutorial

Generic functions
=================

* Menu:

* Generic functions and methods::
* Next-method::
* Example::


File: goops.info,  Node: Generic functions and methods,  Next: Next-method,  Prev: Generic functions,  Up: Generic functions

Generic functions and methods
-----------------------------

Neither GOOPS nor CLOS use the message mechanism for methods as most
Object Oriented language do. Instead, they use the notion of "generic
functions".  A generic function can be seen as a methods "tanker". When
the evaluator requested the application of a generic function, all the
methods of this generic function will be grabbed and the most specific
among them will be applied. We say that a method M is _more specific_
than a method M' if the class of its parameters are more specific than
the M' ones.  To be more precise, when a generic funtion must be
"called" the system will:

  1. search among all the generic function those which are applicable

  2. sort the list of applicable methods in the "most specific" order

  3. call the most specific method of this list (i.e. the first method
     of the sorted methods list).

The definition of a generic function is done with the `define-generic'
macro. Definition of a new method is done with the `define-method'
macro.  Note that `define-method' automatically defines the generic
function if it has not been defined before. Consequently, most of the
time, the `define-generic' needs not be used.  Consider the following
definitions:

     (define-generic G)
     (define-method  G ((a <integer>) b) 'integer)
     (define-method  G ((a <real>) b) 'real)
     (define-method  G (a b) 'top)

The `define-generic' call defines G as a generic function. Note that
the signature of the generic function is not given upon definition,
contrarily to CLOS. This will permit methods with different signatures
for a given generic function, as we shall see later. The three next
lines define methods for the G generic function. Each method uses a
sequence of "parameter specializers" that specify when the given method
is applicable. A specializer permits to indicate the class a parameter
must belong to (directly or indirectly) to be applicable. If no
specializer is given, the system defaults it to `<top>'. Thus, the
first method definition is equivalent to

     (define-method G ((a <integer>) (b <top>)) 'integer)

Now, let us look at some possible calls to generic function G:

     (G 2 3)    => integer
     (G 2 #t)   => integer
     (G 1.2 'a) => real
     (G #t #f)  => top
     (G 1 2 3)  => error (since no method exists for 3 parameters)

The preceding methods use only one specializer per parameter list. Of
course, each parameter can use a specializer. In this case, the
parameter list is scanned from left to right to determine the
applicability of a method. Suppose we declare now

     (define-method G ((a <integer>) (b <number>))  'integer-number)
     (define-method G ((a <integer>) (b <real>))    'integer-real)
     (define-method G ((a <integer>) (b <integer>)) 'integer-integer)
     (define-method G (a (b <number>))              'top-number)

In this case,

     (G 1 2)   => integer-integer
     (G 1 1.0) => integer-real
     (G 1 #t)  => integer
     (G 'a 1)  => top-number


File: goops.info,  Node: Next-method,  Next: Example,  Prev: Generic functions and methods,  Up: Generic functions

Next-method
-----------

When a generic function is called, the list of applicable methods is
built. As mentioned before, the most specific method of this list is
applied (see *Note Generic functions and methods::). This method may
call the next method in the list of applicable methods. This is done by
using the special form `next-method'. Consider the following definitions

     (define-method Test ((a <integer>)) (cons 'integer (next-method)))
     (define-method Test ((a <number>))  (cons 'number  (next-method)))
     (define-method Test (a)             (list 'top))

With those definitions,

     (Test 1)   => (integer number top)
     (Test 1.0) => (number top)
     (Test #t)  => (top)


File: goops.info,  Node: Example,  Prev: Next-method,  Up: Generic functions

Example
-------

In this section we shall continue to define operations on the
`<complex>' class defined in Figure 2. Suppose that we want to use it
to implement complex numbers completely. For instance a definition for
the addition of two complexes could be

     (define-method new-+ ((a <complex>) (b <complex>))
       (make-rectangular (+ (real-part a) (real-part b))
                         (+ (imag-part a) (imag-part b))))

To be sure that the `+' used in the method `new-+' is the standard
addition we can do:

     (define-generic new-+)
     
     (let ((+ +))
       (define-method new-+ ((a <complex>) (b <complex>))
         (make-rectangular (+ (real-part a) (real-part b))
                           (+ (imag-part a) (imag-part b)))))

The `define-generic' ensures here that `new-+' will be defined in the
global environment. Once this is done, we can add methods to the
generic function `new-+' which make a closure on the `+' symbol.  A
complete writing of the `new-+' methods is shown in Figure 3.

          (define-generic new-+)
          
          (let ((+ +))
          
            (define-method new-+ ((a <real>) (b <real>)) (+ a b))
          
            (define-method new-+ ((a <real>) (b <complex>))
              (make-rectangular (+ a (real-part b)) (imag-part b)))
          
            (define-method new-+ ((a <complex>) (b <real>))
              (make-rectangular (+ (real-part a) b) (imag-part a)))
          
            (define-method new-+ ((a <complex>) (b <complex>))
              (make-rectangular (+ (real-part a) (real-part b))
                                (+ (imag-part a) (imag-part b))))
          
            (define-method new-+ ((a <number>))  a)
          
            (define-method new-+ () 0)
          
            (define-method new-+ args  (new-+ (car args)
                                              (apply new-+ (cdr args)))))
          
          (set! + new-+)

          _Fig 3: Extending `+' for dealing with complex numbers_





We use here the fact that generic function are not obliged to have the
same number of parameters, contrarily to CLOS.  The four first methods
implement the dyadic addition. The fifth method says that the addition
of a single element is this element itself. The sixth method says that
using the addition with no parameter always return 0. The last method
takes an arbitrary number of parameters(1).  This method acts as a kind
of `reduce': it calls the dyadic addition on the _car_ of the list and
on the result of applying it on its rest.  To finish, the `set!'
permits to redefine the `+' symbol to our extended addition.




To terminate our implementation (integration?) of  complex numbers, we
can redefine standard Scheme predicates in the following manner:

     (define-method complex? (c <complex>) #t)
     (define-method complex? (c)           #f)
     
     (define-method number? (n <number>) #t)
     (define-method number? (n)          #f)
     ...
     ...

Standard primitives in which complex numbers are involved could also be
redefined in the same manner.

---------- Footnotes ----------

(1) The third parameter of a `define-method' is a parameter list which
follow the conventions used for lambda expressions. In particular it
can use the dot notation or a symbol to denote an arbitrary number of
parameters


File: goops.info,  Node: Index,  Next: Concept Index,  Prev: Tutorial,  Up: Top

Index
*****


File: goops.info,  Node: Concept Index,  Next: Function and Variable Index,  Prev: Index,  Up: Top

Concept Index
=============

* Menu:

* accessor:                              Slot description.
* class:                                 Class definition.
* default slot value:                    Slot description.
* generic function:                      Generic functions and methods.
* getter:                                Slot description.
* instance:                              Instance creation and slot access.
* keyword:                               Slot description.
* loading:                               Intro.
* main module:                           Intro.
* parameter specializers:                Generic functions and methods.
* preparing:                             Intro.
* setter:                                Slot description.
* slot:                                  Class definition.
* top level environment:                 Slot description.


File: goops.info,  Node: Function and Variable Index,  Prev: Concept Index,  Up: Top

Function and Variable Index
===========================

* Menu:

* #:accessor:                            Slot description.
* #:allocation:                          Slot description.
* #:class:                               Slot description.
* #:each-subclass:                       Slot description.
* #:getter:                              Slot description.
* #:init-keyword:                        Slot description.
* #:init-thunk:                          Slot description.
* #:init-value:                          Slot description.
* #:instance:                            Slot description.
* #:setter:                              Slot description.
* #:slot-ref:                            Slot description.
* #:slot-set!:                           Slot description.
* #:virtual:                             Slot description.
* (oop goops):                           Intro.
* default slot value:                    Slot description.
* define-class:                          Class definition.
* define-generic:                        Generic functions and methods.
* define-method:                         Generic functions and methods.
* make:                                  Instance creation and slot access.
* set!:                                  Slot description.
* slot-ref:                              Instance creation and slot access.
* slot-set!:                             Instance creation and slot access.



Tag Table:
Node: Top479
Node: Introduction971
Node: Getting Started1823
Node: Running GOOPS2209
Node: Methods2709
Node: User-defined types2969
Node: Asking for the type of an object3803
Node: Reference Manual4179
Node: MOP specification4336
Node: Tutorial4488
Node: Copyright4843
Node: Intro5726
Node: Class definition and instantiation6830
Node: Class definition7044
Ref: Class definition-Footnote-18558
Ref: Class definition-Footnote-28611
Ref: Class definition-Footnote-38794
Node: Inheritance9119
Node: Class hierarchy and inheritance of slots9408
Node: Instance creation and slot access11630
Node: Slot description13116
Node: Class precedence list20690
Ref: Class precedence list-Footnote-123232
Node: Generic functions23333
Node: Generic functions and methods23523
Node: Next-method26669
Node: Example27487
Ref: Example-Footnote-130684
Node: Index30906
Node: Concept Index31002
Node: Function and Variable Index31979

End Tag Table
