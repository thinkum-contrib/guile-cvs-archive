This is goops.info, produced by makeinfo version 3.12k from goops.texi.

INFO-DIR-SECTION Scheme Programming
START-INFO-DIR-ENTRY
* goops: (goops).        The GOOPS reference manual.
END-INFO-DIR-ENTRY

   This file documents goops, an Object Oriented extension for Guile.

   Copyright 1998 Erick Gallesio

   Permission is granted to ...


File: goops.info,  Node: Top,  Next: Tutorial,  Prev: (dir),  Up: (dir)

   This document describes ...

   This document applies to version ...  of the program named ...

* Menu:

* Tutorial::
* Reference Manual::
* MOP specification::
* Index::
* Concept Index::
* Function and Variable Index::


File: goops.info,  Node: Tutorial,  Next: Reference Manual,  Prev: Top,  Up: Top

Tutorial
********

   This is chapter was originally written by Erick Gallesio as an
appendix for the STk reference manual, and subsequently adapted to
GOOPS.

* Menu:

* Introduction::
* Class definition and instantiation::
* Inheritance::
* Generic functions::


File: goops.info,  Node: Introduction,  Next: Class definition and instantiation,  Prev: Tutorial,  Up: Tutorial

Introduction
============

   GOOPS is the object oriented layer of Guile. Its implementation is
derived from version 1.3 of the Gregor Kickzales Tiny Clos package
`Tiny-Clos'.  However, it has been extended with ideas from CLOS, the
Common Lisp Object System (`CLtL2') and Dylan or SOS.

   Briefly stated, the GOOPS extension gives the user a full object
oriented system with meta-classes, multiple inheritance, generic
functions and multi-methods.  Furthermore, the whole implementation
relies on a true meta object protocol, in the spirit of the one defined
for CLOS (`Gregor Kiczales: A Metaobject Protocol').

   The purpose of this tutorial is to introduce briefly the GOOPS
package and in no case will it replace the GOOPS reference manual
(which needs to be urgently written now ...).

   Note that the operations described in this tutorial resides in
modules that may need to be imported before being available.  The main
module is imported by evaluating:
     (use-modules (oop goops))


File: goops.info,  Node: Class definition and instantiation,  Next: Inheritance,  Prev: Introduction,  Up: Tutorial

Class definition and instantiation
==================================

* Menu:

* Class definition::


File: goops.info,  Node: Class definition,  Prev: Class definition and instantiation,  Up: Class definition and instantiation

Class definition
----------------

   A new class is defined with the `define-class'(1) macro. The syntax
of `define-class' is close to CLOS `defclass':
     (define-class CLASS (SUPERCLASS SUPERCLASS...)
        SLOT-DESCRIPTION SLOT-DESCRIPTION...
        METACLASS-OPTION)

   The METACLASS-OPTION will not be discussed in this tutorial.  The
SUPERCLASSes list specifies the super classes of CLASS (see *Note
Inheritance:: for more details).  A SLOT-DESCRIPTION gives the name of
a slot and, eventually, some "properties" of this slot (such as its
initial value, the function which permit to access its value, ...).
Slot descriptions will be discussed in *Note Slot description::.

   As an example, consider now that we have to define a complex number.
This can be done with the following class definition:
     (define-class  <complex> (<number>)
        r i)

   This binds the symbol `<complex>' to a new class whose instances
contain two slots. These slots are called `r' an `i' and we suppose
here that they contain respectively the real part and the imaginary
part of a complex number. Note that this class inherits from `<number>'
which is a pre-defined class (`<number>' is the super class of the
`<real>' and `<integer>' pre-defined classes)(2).

   ---------- Footnotes ----------

   (1) Don't forget to import the `(oop goops)' module

   (2) With this definition, a `<real>' is not a `<complex>' since
`<real>' inherits from ` <number>' rather than `<complex>'. In
practice, inheritance could be modified _a posteriori_, if needed.
However, this necessitates some knowledge of the meta object protocol
and it will not be shown in this document


File: goops.info,  Node: Inheritance,  Next: Generic functions,  Prev: Class definition and instantiation,  Up: Tutorial

Inheritance
===========

* Menu:

* Class hierarchy and inheritance of slots::
* Instance creation and slot access::
* Slot description::
* Class precedence list::


File: goops.info,  Node: Class hierarchy and inheritance of slots,  Next: Instance creation and slot access,  Prev: Inheritance,  Up: Inheritance

Class hierarchy and inheritance of slots
----------------------------------------

   Inheritance is specified upon class definition. As said in the
introduction, GOOPS supports multiple inheritance.  Here are some class
definitions:
     (define-class A () a)
     (define-class B () b)
     (define-class C () c)
     (define-class D (A B) d a)
     (define-class E (A C) e c)
     (define-class F (D E) f)

   `A', `B', `C' have a null list of super classes. In this case, the
system will replace it by the list which only contains `<object>', the
root of all the classes defined by `define-class'. `D', `E', `F' use
multiple inheritance: each class inherits from two previously defined
classes.  Those class definitions define a hierarchy which is shown in
Figure 1.  In this figure, the class `<top>' is also shown; this class
is the super class of all Scheme objects. In particular, `<top>' is the
super class of all standard Scheme types.
     <class hierarchy example>

                         _Fig 1: A class hierarchy_


   The set of slots of a given class is calculated by "unioning" the
slots of all its super class. For instance, each instance of the class
D, defined before will have three slots (`a', `b' and `d'). The slots
of a class can be obtained by the `class-slots' primitive.  For
instance,
     (class-slots A) => ((a))
     (class-slots E) => ((a) (e) (c))
     (class-slots F) => ((e) (c) (b) (d) (a) (f))

   _Note: _ The order of slots is not significant.


File: goops.info,  Node: Instance creation and slot access,  Next: Slot description,  Prev: Class hierarchy and inheritance of slots,  Up: Inheritance

Instance creation and slot access
---------------------------------

   Creation of an instance of a previously defined class can be done
with the `make' procedure. This procedure takes one mandatory parameter
which is the class of the instance which must be created and a list of
optional arguments. Optional arguments are generally used to initialize
some slots of the newly created instance. For instance, the following
form
     (define c (make <complex>))
   will create a new `<complex>' object and will bind it to the `c'
Scheme variable.

   Accessing the slots of the new complex number can be done with the
`slot-ref' and the `slot-set!'  primitives. `Slot-set!' primitive
permits to set the value of an object slot and `slot-ref' permits to
get its value.
     (slot-set! c 'r 10)
     (slot-set! c 'i 3)
     (slot-ref c 'r) => 10
     (slot-ref c 'i) => 3
   Using the `describe'(1) function is a simple way to see all the
slots of an object at one time: this function prints all the slots of an
object on the standard output. For instance, the expression
     (describe c)
   will print the following informations on the standard output:
     #<<complex> 401d8638> is an instance of class <complex>
     Slots are:
          r = 10
          i = 3

   ---------- Footnotes ----------

   (1) You need to evaluate `(use-modules (oop goops describe))' in
order to import the describe function. Note also that the describe
module depends on slib, which you must have installed.


File: goops.info,  Node: Slot description,  Next: Class precedence list,  Prev: Instance creation and slot access,  Up: Inheritance

Slot description
----------------

   When specifying a slot, a set of options can be given to the system.
Each option is specified with a keyword. The list of authorised
keywords is given below:
   * `#:init-value' permits to supply a default value for the slot. This
     default value is obtained by evaluating the form given after the
     `#:initform' in the global environment, at class definition time.

   * `#:init-thunk' permits to supply a thunk that will provide a
     default value for the slot. The value is obtained by evaluating the
     thunk a instance creation time.

   * `#:init-keyword' permits to specify the keyword for initializing a
     slot. The init-keyword may be provided during instance creation
     (i.e. in the `make' optional parameter list). Specifying such a
     keyword during instance initialization will supersede the default
     slot initialization possibly given with `#:initform'.

   * `#:getter' permits to supply the name for the slot getter. The
     name binding is done in the global environment.

   * `#:setter' permits to supply the name for the slot setter. The
     name binding is done in the global environment.

   * `#:accessor' permits to supply the name for the slot accessor. The
     name binding is done in the global environment. An accessor
     permits to get and set the value of a slot. Setting the value of a
     slot is done with the extended version of `set!'.

   * `#:allocation' permits to specify how storage for the slot is
     allocated. Three kinds of allocation are provided.  They are
     described below:
        - `#:instance' indicates that each instance gets its own
          storage for the slot. This is the default.

        - `#:class' indicates that there is one storage location used
          by all the direct and indirect instances of the class. This
          permits to define a kind of global variable which can be
          accessed only by (in)direct instances of the class which
          defines this slot.

        - `#:each-subclass' indicates that there is one storage
          location used by all the direct instances of the class. In
          other words, if two classes are not siblings in the class
          hierarchy, they will not see the same value.

        - `#:virtual' indicates that no storage will be allocated for
          this slot.  It is up to the user to define a getter and a
          setter function for this slot. Those functions must be
          defined with the `#:slot-ref' and `#:slot-set!' options. See
          the example below.

   To illustrate slot description, we shall redefine the `<complex>'
class seen before. A definition could be:
     (define-class <complex> (<number>)
        (r #:init-value 0 #:getter get-r #:setter set-r! #:init-keyword #:r)
        (i #:init-value 0 #:getter get-i #:setter set-i! #:init-keyword #:i))
   With this definition, the `r' and `i' slot are set to 0 by default.
Value of a slot can also be specified by calling `make' with the `#:r'
and `#:i' keywords. Furthermore, the generic functions `get-r' and
`set-r!' (resp. `get-i' and `set-i!') are automatically defined by the
system to read and write the `r' (resp. `i') slot.
     (define c1 (make <complex> #:r 1 #:i 2))
     (get-r c1) => 1
     (set-r! c1 12)
     (get-r c1) => 12
     (define c2 (make <complex> #:r 2))
     (get-r c2) => 2
     (get-i c2) => 0

   Accessors provide an uniform access for reading and writing an object
slot.  Writing a slot is done with an extended form of `set!' which is
close to the Common Lisp `setf' macro. So, another definition of the
previous `<complex>' class, using the `#:accessor' option, could be:
     (define-class <complex> (<number>)
        (r #:init-value 0 #:accessor real-part #:init-keyword #:r)
        (i #:init-value 0 #:accessor imag-part #:init-keyword #:i))

   Using this class definition, reading the real part of the `c'
complex can be done with:
     (real-part c)
   and setting it to the value contained in the `new-value' variable
can be done using the extended form of `set!'.
     (set! (real-part c) new-value)

   Suppose now that we have to manipulate complex numbers with
rectangular coordinates as well as with polar coordinates. One solution
could be to have a definition of complex numbers which uses one
particular representation and some conversion functions to pass from one
representation to the other.  A better solution uses virtual slots. A
complete definition of the `<complex>' class using virtual slots is
given in Figure 2.
          (define-class <complex> (<number>)
             ;; True slots use rectangular coordinates
             (r #:init-value 0 #:accessor real-part #:init-keyword #:r)
             (i #:init-value 0 #:accessor imag-part #:init-keyword #:i)
             ;; Virtual slots access do the conversion
             (m #:accessor magnitude #:init-keyword #:magn
                #:allocation #:virtual
                #:slot-ref (lambda (o)
                            (let ((r (slot-ref o 'r)) (i (slot-ref o 'i)))
                              (sqrt (+ (* r r) (* i i)))))
                #:slot-set! (lambda (o m)
                              (let ((a (slot-ref o 'a)))
                                (slot-set! o 'r (* m (cos a)))
                                (slot-set! o 'i (* m (sin a))))))
             (a #:accessor angle #:init-keyword #:angle
                #:allocation #:virtual
                #:slot-ref (lambda (o)
                            (atan (slot-ref o 'i) (slot-ref o 'r)))
                #:slot-set! (lambda(o a)
                             (let ((m (slot-ref o 'm)))
                                (slot-set! o 'r (* m (cos a)))
                                (slot-set! o 'i (* m (sin a)))))))

     _Fig 2: A `<complex>' number class definition using virtual slots_





   This class definition implements two real slots (`r' and `i').
Values of the `m' and `a' virtual slots are calculated from real slot
values. Reading a virtual slot leads to the application of the function
defined in the `#:slot-ref' option. Writing such a slot leads to the
application of the function defined in the `#:slot-set!' option.  For
instance, the following expression
     (slot-set! c 'a 3)
   permits to set the angle of the `c' complex number. This expression
conducts, in fact, to the evaluation of the following expression
     ((lambda o m)
         (let ((m (slot-ref o 'm)))
            (slot-set! o 'r (* m (cos a)))
            (slot-set! o 'i (* m (sin a))))
       c 3)
   A more complete example is given below:
          (define c (make <complex> #:r 12 #:i 20))
          (real-part c) => 12
          (angle c) => 1.03037682652431
          (slot-set! c 'i 10)
          (set! (real-part c) 1)
          (describe c) =>
                    #<<complex> 401e9b58> is an instance of class <complex>
                    Slots are:
                         r = 1
                         i = 10
                         m = 10.0498756211209
                         a = 1.47112767430373

   Since initialization keywords have been defined for the four slots,
we can now define the `make-rectangular' and `make-polar' standard
Scheme primitives.
     (define make-rectangular
        (lambda (x y) (make <complex> #:r x #:i y)))
     
     (define make-polar
        (lambda (x y) (make <complex> #:magn x #:angle y)))


File: goops.info,  Node: Class precedence list,  Prev: Slot description,  Up: Inheritance

Class precedence list
---------------------

   A class may have more than one superclass.  (1) With single
inheritance (one superclass), it is easy to order the super classes
from most to least specific. This is the rule:

     Rule 1: Each class is more specific than its superclasses.

   With multiple inheritance, ordering is harder. Suppose we have
     (define-class X ()
        (x #:init-value 1))
     
     (define-class Y ()
        (x #:init-value 2))
     
     (define-class Z (X Y)
        (...))

   In this case, the `Z' class is more specific than the `X' or `Y'
class for instances of `Z'. However, the `#:init-value' specified in
`X' and `Y' leads to a problem: which one overrides the other?  The
rule in GOOPS, as in CLOS, is that the superclasses listed earlier are
more specific than those listed later.  So:
     Rule 2: For a given class, superclasses listed earlier are more
             specific than those listed later.

   These rules are used to compute a linear order for a class and all
its superclasses, from most specific to least specific.  This order is
called the "class precedence list" of the class. Given these two rules,
we can claim that the initial form for the `x' slot of previous example
is 1 since the class `X' is placed before `Y' in class precedence list
of `Z'.

   This two rules are not always enough to determine a unique order,
however, but they give an idea of how things work. The GOOPS algorithm
for calculating the precedence list is a little simpler than the CLOS
one described in `Gregor Kiczales: A Metaobject Protocol' for breaking
ties. Consequently the calculated class precedence list could be
different. Taking the `F' class shown in Figure 1, the GOOPS calculated
class precedence list is
     (f d e a b c <object> <top>)
   whereas it would be the following list with a CLOS-like algorithm:
     (f d e a c b <object> <top>)

   However, it is usually considered a bad idea for programmers to rely
on exactly what the order is.  If the order for some superclasses is
important, it can be expressed directly in the class definition.

   The precedence list of a class can be obtained by the function
`class-precedence-list'. This function returns a ordered list whose
first element is the most specific class. For instance,
     (class-precedence-list B) => (#<<class> B 401b97c8>
                                          #<<class> <object> 401e4a10>
                                          #<<class> <top> 4026a9d8>)
   However, this result is not too much readable; using the function
`class-name' yields a clearer result:
     (map class-name (class-precedence-list B)) => (B <object> <top>)

   ---------- Footnotes ----------

   (1) This section is an adaptation of Jeff Dalton's
(J.Dalton@ed.ac.uk) `Brief introduction to CLOS'


File: goops.info,  Node: Generic functions,  Prev: Inheritance,  Up: Tutorial

Generic functions
=================

* Menu:

* Generic functions and methods::
* Next-method::
* Example::


File: goops.info,  Node: Generic functions and methods,  Next: Next-method,  Prev: Generic functions,  Up: Generic functions

Generic functions and methods
-----------------------------

   Neither GOOPS nor CLOS use the message mechanism for methods as most
Object Oriented language do. Instead, they use the notion of "generic
functions".  A generic function can be seen as a methods "tanker". When
the evaluator requested the application of a generic function, all the
methods of this generic function will be grabbed and the most specific
among them will be applied. We say that a method M is _more specific_
than a method M' if the class of its parameters are more specific than
the M' ones.  To be more precise, when a generic funtion must be
"called" the system will:
  1. search among all the generic function those which are applicable

  2. sort the list of applicable methods in the "most specific" order

  3. call the most specific method of this list (i.e. the first method
     of the sorted methods list).

   The definition of a generic function is done with the
`define-generic' macro. Definition of a new method is done with the
`define-method' macro.  Note that `define-method' automatically defines
the generic function if it has not been defined before. Consequently,
most of the time, the `define-generic' needs not be used.  Consider the
following definitions:
     (define-generic M)
     (define-method  M ((a <integer>) b) 'integer)
     (define-method  M ((a <real>) b) 'real)
     (define-method  M (a b) 'top)

   The `define-generic' call defines M as a generic function. Note that
the signature of the generic function is not given upon definition,
contrarily to CLOS. This will permit methods with different signatures
for a given generic function, as we shall see later. The three next
lines define methods for the M generic function. Each method uses a
sequence of "parameter specializers" that specify when the given method
is applicable. A specializer permits to indicate the class a parameter
must belong to (directly or indirectly) to be applicable. If no
specializer is given, the system defaults it to `<top>'. Thus, the
first method definition is equivalent to
     (define-method M ((a <integer>) (b <top>)) 'integer)

   Now, let us look at some possible calls to generic function M:
     (M 2 3)    => integer
     (M 2 #t)   => integer
     (M 1.2 'a) => real
     (M #t #f)  => top
     (M 1 2 3)  => error (since no method exists for 3 parameters)

   The preceding methods use only one specializer per parameter list. Of
course, each parameter can use a specializer. In this case, the
parameter list is scanned from left to right to determine the
applicability of a method. Suppose we declare now
     (define-method M ((a <integer>) (b <number>))  'integer-number)
     (define-method M ((a <integer>) (b <real>))    'integer-real)
     (define-method M ((a <integer>) (b <integer>)) 'integer-integer)
     (define-method M (a (b <number>))              'top-number)

   In this case,
     (M 1 2)   => integer-integer
     (M 1 1.0) => integer-real
     (M 1 #t)  => integer
     (M 'a 1)  => 'top-number


File: goops.info,  Node: Next-method,  Next: Example,  Prev: Generic functions and methods,  Up: Generic functions

Next-method
-----------

   When a generic function is called, the list of applicable methods is
built. As mentioned before, the most specific method of this list is
applied (see *Note Generic functions and methods::). This method may
call the next method in the list of applicable methods. This is done by
using the special form `next-method'. Consider the following definitions
     (define-method Test ((a <integer>)) (cons 'integer (next-method)))
     (define-method Test ((a <number>))  (cons 'number  (next-method)))
     (define-method Test (a)             (list 'top))

   With those definitions,
     (Test 1)   => (integer number top)
     (Test 1.0) => (number top)
     (Test #t)  => (top)


File: goops.info,  Node: Example,  Prev: Next-method,  Up: Generic functions

Example
-------

   In this section we shall continue to define operations on the
`<complex>' class defined in Figure 2. Suppose that we want to use it
to implement complex numbers completely. For instance a definition for
the addition of two complexes could be
     (define-method new-+ ((a <complex>) (b <complex>))
       (make-rectangular (+ (real-part a) (real-part b))
                         (+ (imag-part a) (imag-part b))))

   To be sure that the `+' used in the method `new-+' is the standard
addition we can do:
     (define-generic new-+)
     
     (let ((+ +))
       (define-method new-+ ((a <complex>) (b <complex>))
         (make-rectangular (+ (real-part a) (real-part b))
                           (+ (imag-part a) (imag-part b)))))

   The `define-generic' ensures here that `new-+' will be defined in
the global environment. Once this is done, we can add methods to the
generic function `new-+' which make a closure on the `+' symbol.  A
complete writing of the `new-+' methods is shown in Figure 3.

          (define-generic new-+)
          
          (let ((+ +))
          
            (define-method new-+ ((a <real>) (b <real>)) (+ a b))
          
            (define-method new-+ ((a <real>) (b <complex>))
              (make-rectangular (+ a (real-part b)) (imag-part b)))
          
            (define-method new-+ ((a <complex>) (b <real>))
              (make-rectangular (+ (real-part a) b) (imag-part a)))
          
            (define-method new-+ ((a <complex>) (b <complex>))
              (make-rectangular (+ (real-part a) (real-part b))
                                (+ (imag-part a) (imag-part b))))
          
            (define-method new-+ ((a <number>))  a)
          
            (define-method new-+ () 0)
          
            (define-method new-+ args  (new-+ (car args)
                                              (apply new-+ (cdr args)))))
          
          (set! + new-+)

          _Fig 3: Extending `+' for dealing with complex numbers_





   We use here the fact that generic function are not obliged to have
the same number of parameters, contrarily to CLOS.  The four first
methods implement the dyadic addition. The fifth method says that the
addition of a single element is this element itself. The sixth method
says that using the addition with no parameter always return 0. The
last method takes an arbitrary number of parameters(1).  This method
acts as a kind of `reduce': it calls the dyadic addition on the _car_
of the list and on the result of applying it on its rest.  To finish,
the `set!' permits to redefine the `+' symbol to our extended addition.




   To terminate our implementation (integration?) of  complex numbers,
we can redefine standard Scheme predicates in the following manner:
     (define-method complex? (c <complex>) #t)
     (define-method complex? (c)           #f)
     
     (define-method number? (n <number>) #t)
     (define-method number? (n)          #f)
     ...
     ...

   Standard primitives in which complex numbers are involved could also
be redefined in the same manner.

   ---------- Footnotes ----------

   (1) The third parameter of a `define-method' is a parameter list
which follow the conventions used for lambda expressions. In particular
it can use the dot notation or a symbol to denote an arbitrary number
of parameters


File: goops.info,  Node: Reference Manual,  Next: MOP specification,  Prev: Tutorial,  Up: Top

Reference Manual
****************

   [TO BE WRITTEN]


File: goops.info,  Node: MOP specification,  Next: Index,  Prev: Reference Manual,  Up: Top

MOP specification
*****************

   [TO BE WRITTEN]


File: goops.info,  Node: Index,  Next: Concept Index,  Prev: MOP specification,  Up: Top

Index
*****


File: goops.info,  Node: Concept Index,  Next: Function and Variable Index,  Prev: Index,  Up: Top

Concept Index
=============

* Menu:

* accessor:                              Slot description.
* class:                                 Class definition.
* default slot value:                    Slot description.
* generic function:                      Generic functions and methods.
* getter:                                Slot description.
* instance:                              Instance creation and slot access.
* keyword:                               Slot description.
* loading:                               Introduction.
* main module:                           Introduction.
* parameter specializers:                Generic functions and methods.
* preparing:                             Introduction.
* setter:                                Slot description.
* slot:                                  Class definition.
* top level environment:                 Slot description.


File: goops.info,  Node: Function and Variable Index,  Prev: Concept Index,  Up: Top

Function and Variable Index
===========================

* Menu:

* #:accessor:                            Slot description.
* #:allocation:                          Slot description.
* #:class:                               Slot description.
* #:each-subclass:                       Slot description.
* #:getter:                              Slot description.
* #:init-keyword:                        Slot description.
* #:init-thunk:                          Slot description.
* #:init-value:                          Slot description.
* #:instance:                            Slot description.
* #:setter:                              Slot description.
* #:slot-ref:                            Slot description.
* #:slot-set!:                           Slot description.
* #:virtual:                             Slot description.
* (oop goops):                           Introduction.
* default slot value:                    Slot description.
* define-class:                          Class definition.
* define-generic:                        Generic functions and methods.
* define-method:                         Generic functions and methods.
* make:                                  Instance creation and slot access.
* set!:                                  Slot description.
* slot-ref:                              Instance creation and slot access.
* slot-set!:                             Instance creation and slot access.



Tag Table:
Node: Top341
Node: Tutorial641
Node: Introduction989
Node: Class definition and instantiation2103
Node: Class definition2324
Ref: Class definition-Footnote-13749
Ref: Class definition-Footnote-23805
Node: Inheritance4115
Node: Class hierarchy and inheritance of slots4404
Node: Instance creation and slot access6040
Ref: Instance creation and slot access-Footnote-17493
Node: Slot description7684
Node: Class precedence list15224
Ref: Class precedence list-Footnote-118023
Node: Generic functions18127
Node: Generic functions and methods18317
Node: Next-method21476
Node: Example22298
Ref: Example-Footnote-125513
Node: Reference Manual25738
Node: MOP specification25891
Node: Index26043
Node: Concept Index26148
Node: Function and Variable Index27146

End Tag Table
