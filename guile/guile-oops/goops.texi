\input texinfo
@c -*-texinfo-*-
@c %**start of header
@setfilename goops.info
@settitle Goops Manual
@setchapternewpage odd
@paragraphindent 0
@c %**end of header

@set VERSION 0.2

@dircategory Scheme Programming
@direntry
* goops: (goops).          The GOOPS reference manual.
@end direntry

@macro goops
GOOPS
@end macro

@macro guile
Guile
@end macro

@ifinfo
This file documents GOOPS, an object oriented extension for Guile.

Copyright (C) 1999, 2000 Free Software Foundation

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@end ifinfo

@c  This title page illustrates only one of the
@c  two methods of forming a title page.

@titlepage
@title Goops Manual
@subtitle For use with GOOPS @value{VERSION}
@author Christian Lynbech
@author @email{chl@@tbit.dk}
@author
@author Mikael Djurfeldt
@author @email{djurfeldt@@nada.kth.se}
@author
@author Neil Jerram
@author @email{mpriz@@dircon.co.uk}

@c  The following two commands
@c  start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1999 Free Software Foundation

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@end titlepage

@node Top, Introduction, (dir), (dir)

@menu
[When the manual is completed, this will be a flat index in the style of
 the Emacs manual.  More nodes will turn up under parts I-III.]

Part I: Preliminaries

* Introduction::
* Getting Started::

Part II: Reference Manual [this is ongoing work; the manual is not complete]

* Reference Manual::

Part III: GOOPS Meta Object Protocol

* MOP Specification::

The GOOPS tutorial

* Tutorial::

* Index::                       
* Concept Index::               
* Function and Variable Index::  
@end menu

@iftex
@chapter Preliminaries
@end iftex

@node Introduction, Getting Started, Top, Top
@section Introduction

@goops{} is the object oriented extension to @guile{}. Its
implementation is derived from @w{STk-3.99.3} by Erick Gallesio and
version 1.3 of Gregor Kiczales @cite{Tiny-Clos}.  It is very close in
spirit to CLOS, the Common Lisp Object System (@cite{CLtL2}) but is
adapted for the Scheme language.  While GOOPS is not compatible with any
of these systems, GOOPS contains a compatibility module which allows for
execution of STKlos programs.

Briefly stated, the @goops{} extension gives the user a full object
oriented system with multiple inheritance and generic functions with
multi-method dispatch.  Furthermore, the implementation relies on a true
meta object protocol, in the spirit of the one defined for CLOS
(@cite{Gregor Kiczales: A Metaobject Protocol}).

@node Getting Started, Reference Manual, Introduction, Top
@section Getting Started

@menu
* Running GOOPS::

Examples of some basic GOOPS functionality.

* Methods::
* User-defined types::
* Asking for the type of an object::

See further in the GOOPS tutorial available in this distribution in
info (goops.info) and texinfo format.
@end menu

@node Running GOOPS, Methods, Getting Started, Getting Started
@subsection Running GOOPS
 
@enumerate
@item
Type

@smalllisp
guile-oops
@end smalllisp

You should now be at the Guile prompt ("guile> ").

@item
Type

@smalllisp
(use-modules (oop goops))
@end smalllisp

to load GOOPS.  (If your system supports dynamic loading, you
should be able to do this not only from `guile-oops' but from an
arbitrary Guile interpreter.)
@end enumerate

We're now ready to try some basic GOOPS functionality.

@node Methods, User-defined types, Running GOOPS, Getting Started
@subsection Methods

@smalllisp
@group
(define-method + ((x <string>) (y <string>))
  (string-append x y))

(+ 1 2) --> 3
(+ "abc" "de") --> "abcde"
@end group
@end smalllisp

@node User-defined types, Asking for the type of an object, Methods, Getting Started
@subsection User-defined types

@smalllisp
(define-class <2D-vector> ()
  (x #:init-value 0 #:accessor x-component #:init-keyword #:x)
  (y #:init-value 0 #:accessor y-component #:init-keyword #:y))

@group
(use-modules (ice-9 format))

(define-method write ((obj <2D-vector>) port)
  (display (format #f "<~S, ~S>" (x-component obj) (y-component obj))
           port))

(define v (make <2D-vector> #:x 3 #:y 4))

v --> <3, 4>
@end group

@group
(define-method + ((x <2D-vector>) (y <2D-vector>))
  (make <2D-vector>
        #:x (+ (x-component x) (x-component y))
        #:y (+ (y-component x) (y-component y))))

(+ v v) --> <6, 8>
@end group
@end smalllisp

@node Asking for the type of an object, , User-defined types, Getting Started
@subsection Types

@example
(class-of v) --> #<<class> <2D-vector> 40241ac0>
<2D-vector>  --> #<<class> <2D-vector> 40241ac0>
(class-of 1) --> #<<class> <integer> 401b2a98>
<integer>    --> #<<class> <integer> 401b2a98>

(is-a? v <2D-vector>) --> #t
@end example

@node Reference Manual, MOP Specification, Getting Started, Top
@chapter Reference Manual

[This is ongoing work; the manual is not yet complete.]

This chapter is the GOOPS reference manual.  It aims to describe all the
syntax, procedures, options and associated concepts that a typical
application author would need to understand in order to use GOOPS
effectively in their application.  It also describes what is meant by
the GOOPS ``metaobject protocol'' (aka ``MOP''), and indicates how
authors can use the metaobject protocol to customize the behaviour of
GOOPS itself.

For a detailed specification of the GOOPS meta-object protocol, see
@ref{MOP Specification}.

@menu
* Introductory Remarks::
* Defining New Classes::
* Creating Instances::
* Accessing Slots::
* Creating Generic Functions::
* Adding Methods to Generic Functions::
* Invoking Generic Functions::
* Redefining a Class::
* Changing the Class of an Instance::
* Introspection::
* Miscellaneous Functions::
@end menu

@node Introductory Remarks
@section Introductory Remarks

GOOPS is an object-oriented programming system based on a ``metaobject
protocol'' derived from the ones used in CLOS (the Common Lisp Object
System), tiny-clos (a small Scheme implementation of a subset of CLOS
functionality) and STKlos.

GOOPS can be used by application authors at a basic level without any
need to understand what the metaobject protocol (aka ``MOP'') is and how
it works.  On the other hand, the MOP underlies even the customizations
that application authors are likely to make use of very quickly --- such
as defining an @code{initialize} method to customize the initialization
of instances of an application-defined class --- and an understanding of
the MOP makes it much easier to explain such customizations in a precise
way.  And in the long run, understanding the MOP is the key both to
understanding GOOPS at a deeper level and to taking full advantage of
GOOPS' power, by customizing the behaviour of GOOPS itself.

Each of the following sections of the reference manual is arranged
such that the most basic usage is introduced first, and then subsequent
subsections discuss the related internal functions and metaobject
protocols, finishing with a description of how to customize that area of
functionality.

These introductory remarks continue with a few words about metaobjects
and the MOP.  Readers who do not want to be bothered yet with the MOP
and customization could safely skip this subsection on a first reading,
and should correspondingly skip subsequent subsections that are
concerned with internals and customization.

In general, this reference manual assumes familiarity with standard
object oriented concepts and terminology.  However, some of the terms
used in GOOPS is less well known, so the Terminology subsection
provides definitions for these terms.

@menu
* Metaobjects and the Metaobject Protocol::
* Terminology::
@end menu

@node Metaobjects and the Metaobject Protocol
@subsection Metaobjects and the Metaobject Protocol

The conceptual building blocks of GOOPS are classes, slot definitions,
instances, generic functions and methods.  A class is a grouping of
inheritance relations and slot definitions.  An instance is an object
with slots that are allocated following the rules implied by its class's
superclasses and slot definitions.  A generic function is a collection
of methods and rules for determining which of those methods to apply
when the generic function is invoked.  A method is a procedure and a set
of specializers that specify the type of arguments to which the
procedure is applicable.

Of these entities, GOOPS represents classes, generic functions and
methods as ``metaobjects''.  In other words, the values in a GOOPS
program that describe classes, generic functions and methods, are
themselves instances (or ``objects'') of special GOOPS classes that
encapsulate the behaviour, respectively, of classes, generic functions,
and methods.

(The other two entities are slot definitions and instances.  Slot
definitions are not strictly instances, but every slot definition is
associated with a GOOPS class that specifies the behaviour of the slot
as regards accessibility and protection from garbage collection.
Instances are of course objects in the usual sense, and there is no
benefit from thinking of them as metaobjects.)

The ``metaobject protocol'' (aka ``MOP'') is the specification of the
generic functions which determine the behaviour of these metaobjects and
the circumstances in which these generic functions are invoked.

For a concrete example of what this means, we need to introduce the
@code{initialize} generic function, which GOOPS calls whenever a new
instance is created, immediately after allocating memory for a new
instance, to initialize the new instance's slots.

Now consider how GOOPS calculates the set of slots for a class that is
being defined using @code{define-class}.  The desired set of slots is
the union of the new class's direct slots and the slots of all its
superclasses.  But @code{define-class} itself does not perform this
calculation.  Instead, there is a method of the @code{initialize}
generic function that is specialized for instances of type
@code{<class>}, and it is this method that performs the slot
calculation.  The sequence of steps is as follows.

@itemize @bullet
@item
@code{define-class} uses @code{make} to make a new instance of the
@code{<class>}, passing as initialization arguments the superclasses,
slot definitions and class options that were specified in the
@code{define-class} form.

@item
@code{make} allocates memory for the new instance, and then invokes the
@code{initialize} generic function to initialize the new instance's
slots.

@item
The @code{initialize} generic function applies the method that is
specialized for instances of type @code{<class>}, and this method
performs the slot calculation.
@end itemize

In other words, rather than being hardcoded in @code{define-class}, the
behaviour of class definition is encapsulated by generic function
methods that are specialized for the class @code{<class>}.

It is possible to create a new class that inherits from @code{<class>},
which is called a ``metaclass'', and to write a new @code{initialize}
method that is specialized for instances of the new metaclass.  Then, if
the @code{define-class} form includes a @code{#:metaclass} class option
whose value is the new metaclass, the class that is defined by the
@code{define-class} form will be an instance of the new metaclass
instead of the default @code{<class>}, and will be defined in accordance
with the new @code{initialize} method.  Thus the default slot
calculation, as well as any other aspect of the new class's relationship
with its superclasses, can be modified or overriden.

In a similar way, the behaviour of generic functions can be modified or
overriden by creating a new class that inherits from the standard
generic function class @code{<generic>}, writing appropriate methods
that are specialized to the new class, and creating new generic
functions that are instances of the new class.

The same is true for generic function method metaobjects.  And the same
basic mechanism allows the application class author to write an
@code{initialize} method that is specialized to their application class,
to initialize instances of that class.

Such is the power of the MOP.  Note that @code{initialize} is just one
of a large number of generic functions that can be customized to modify
the behaviour of application objects and classes and of GOOPS itself.
Each subsequent section of the reference manual covers a particular area
of GOOPS functionality, and describes the generic functions that are
relevant for customization of that area.

We conclude this subsection by emphasizing a point that may seem
obvious, but contrasts with the corresponding situation in some other
MOP implementations, such as CLOS.  The point is simply that an
identifier which represents a GOOPS class or generic function is a
variable with a first-class value, the value being an instance of class
@code{<class>} or @code{<generic>}.  (In CLOS, on the other hand, a
class identifier is a symbol that indexes the corresponding class
metaobject in a separate namespace for classes.)  This is, of course,
simply an extension of the tendency in Scheme to avoid the unnecessary
use of, on the one hand, syntactic forms that require unevaluated
arguments and, on the other, separate identifier namespaces (e.g. for
class names), but it is worth noting that GOOPS conforms fully to this
Schemely principle.

@node Terminology
@subsection Terminology

It is assumed that the reader is already familiar with standard object
orientation concepts such as classes, objects/instances,
inheritance/subclassing, generic functions and methods, encapsulation
and polymorphism.

This section explains some of the less well known concepts and
terminology that GOOPS uses, which are assumed by the following sections
of the reference manual.

@menu
* Metaclass::
* Class Precedence List::
* Accessor::
@end menu

@node Metaclass
@subsubsection Metaclass

A metaclass is the class of an object which represents a GOOPS class.
Put more succinctly, a metaclass is a class's class.

Most GOOPS classes have the metaclass @code{<class>} and, by default,
any new class that is created using @code{define-class} has the
metaclass @code{<class>}.

But what does this really mean?  To find out, let's look in more detail
at what happens when a new class is created using @code{define-class}:

@example
(define-class <my-class> (<object>) . slots)
@end example

GOOPS actually expands the @code{define-class} form to something like
this:

@example
(define <my-class>
  (make <class> #:supers (list <object>) #:slots slots))
@end example

In other words, the value of @code{<my-class>} is in fact an instance of
the class @code{<class>} with slot values specifying the superclasses
and slot definitions for the class @code{<my-class>}.  (@code{#:supers}
and @code{#:slots} are initialization keywords for the @code{dsupers}
and @code{dslots} slots of the @code{<class>} class.)

In order to take advantage of the full power of the GOOPS meta-object
protocol (@pxref{MOP Specification}), it is sometimes desirable to
create a new class with a metaclass other than the default
@code{<class>}.  This is done by writing:

@example
(define-class <my-class2> (<object>)
   #:metaclass <my-metaclass> . slots)
@end example

And GOOPS would expand this to something like:

@example
(define <my-class2>
  (make <my-metaclass> #:supers (list <object>) #:slots slots))
@end example

In this case, the value of @code{<my-class2>} is an instance of the more
specialized class @code{<my-metaclass>}.  Note that
@code{<my-metaclass>} itself must previously have been defined as a
subclass of @code{<class>}.  For a full discussion of when and how it is
useful to define new metaclasses, see @ref{MOP Specification}.

Now let's make an instance of @code{<my-class2>}:

@example
(define my-object (make <my-class2> ...))
@end example

All of the following statements are correct expressions of the
relationships between @code{my-object}, @code{<my-class2>},
@code{<my-metaclass>} and @code{<class>}.

@itemize @bullet
@item
@code{my-object} is an instance of the class @code{<my-class2>}.

@item
@code{<my-class2>} is an instance of the class @code{<my-metaclass>}.

@item
@code{<my-metaclass>} is an instance of the class @code{<class>}.

@item
The class of @code{my-object} is @code{<my-class2>}.

@item
The metaclass of @code{my-object} is @code{<my-metaclass>}.

@item
The class of @code{<my-class2>} is @code{<my-metaclass>}.

@item
The metaclass of @code{<my-class2>} is @code{<class>}.

@item
The class of @code{<my-metaclass>} is @code{<class>}.

@item
The metaclass of @code{<my-metaclass>} is @code{<class>}.

@item
@code{<my-class2>} is not a metaclass, since it is does not inherit from
@code{<class>}.

@item
@code{<my-metaclass>} is a metaclass, since it inherits from
@code{<class>}.
@end itemize

@node Class Precedence List
@subsubsection Class Precedence List

The @dfn{class precedence list} of a class is the list of all direct and
indirect superclasses of that class, including the class itself.

In the absence of multiple inheritance, the class precedence list is
ordered straightforwardly, beginning with the class itself and ending
with @code{<top>}.

For example, given this inheritance hierarchy:

@example
(define-class <invertebrate> (<object>) @dots{})
(define-class <echinoderm> (<invertebrate>) @dots{})
(define-class <starfish> (<echinoderm>) @dots{})
@end example

the class precedence list of <starfish> would be

@example
(<starfish> <echinoderm> <invertebrate> <object> <top>)
@end example

With multiple inheritance, the algorithm is a little more complicated.
A full description is provided by the GOOPS Tutorial: see @ref{Class
precedence list}.

``Class precedence list'' is often abbreviated, in documentation and
Scheme variable names, to @dfn{cpl}.

@node Accessor
@subsubsection Accessor

An accessor is a generic function with both reference and setter
methods.

@example
(define-accessor perimeter)
@end example

Reference methods for an accessor are defined in the same way as generic
function methods.

@example
(define-method perimeter ((s <square>))
  (* 4 (side-length s)))
@end example

Setter methods for an accessor are defined by specifying ``(setter
<accessor-name>)'' as the first parameter of the @code{define-method}
call.

@example
(define-method (setter perimeter) ((s <square>) (n <number>))
  (set! (side-length s) (/ n 4)))
@end example

Once an appropriate setter method has been defined in this way, it can
be invoked using the generalized @code{set!} syntax, as in:

@example
(set! (perimeter s1) 18.3)
@end example

@node Defining New Classes
@section Defining New Classes

@menu
* Basic Class Definition::
* Class Options::
* Slot Options::
* Class Definition Internals::
* Customizing Class Definition::
* STKlos Compatibility::
@end menu

@node Basic Class Definition
@subsection Basic Class Definition

@deffn syntax define-class name (super @dots{}) slot-definition @dots{} . options
Define a class called @var{name} that inherits from @var{super}s, with
direct slots defined by @var{slot-definition}s and class options
@var{options}.  The newly created class is bound to the variable name
@var{name} in the current (*fixme* top-level?) environment.

Each @var{slot-definition} is either a symbol that names the slot or a
list:

@example
(@var{slot-name-symbol} . @var{slot-options})
@end example

@var{options} and each @var{slot-options} must be a list with an even
number of elements, where the even-numbered elements (starting from
zero) are class- and slot-option keywords and the odd-numbered elements
are the corresponding values for those keywords.

Example 1.  Define a class that combines two pre-existing classes by
inheritance but adds no new slots.

@example
(define-class <combined> (<tree> <bicycle>))
@end example

Example 2.  Define a @code{regular-polygon} class with slots for side
length and number of sides that have default values and can be accessed
via the generic functions @code{side-length} and @code{num-sides}.

@example
(define-class <regular-polygon> ()
  (sl #:init-value 1 #:accessor side-length)
  (ns #:init-value 5 #:accessor num-sides))
@end example

Example 3.  Define a class whose behavior (and that of its instances) is
customized via an application-defined metaclass.

@example
(define-class <tcpip-fsm> ()
  (s #:init-value #f #:accessor state)
  ...
  #:metaclass <finite-state-class>)
@end example

For more details about the available class and slot options, see
@ref{Class Options} and @ref{Slot Options}.

Implementation notes: @code{define-class}

@itemize @bullet
@item
checks that it is being called only at top level

@item
defines any accessors that are implied by the @var{slot-definition}s

@item
calls @code{class} to create the new class (@pxref{Class Definition
Internals,, class})

@item
checks for a previous class definition for @var{name} and, if found,
handles the redefinition by calling @code{class-redefinition}
(@pxref{MOP Specification,, class-redefinition}).
@end itemize
@end deffn

@node Class Options
@subsection Class Options

@node Slot Options
@subsection Slot Options

@deffn {slot option} #:allocation allocation
The @code{#:allocation} option tells GOOPS how to allocate storage for
the slot.  Possible values for @var{allocation} are

@itemize @bullet
@item @code{#:instance}

Indicates that GOOPS should create separate storage for this slot in
each new instance of the containing class (and its subclasses).

@item @code{#:class}

Indicates that GOOPS should create storage for this slot that is shared
by all instances of the containing class (and its subclasses).  In other
words, a slot in class @var{C} with allocation @code{#:class} is shared
by all @var{instance}s for which @code{(is-a? @var{instance} @var{c})}.

@item @code{#:each-subclass}

Indicates that GOOPS should create storage for this slot that is shared
by all @emph{direct} instances of the containing class, and that
whenever a subclass of the containing class is defined, GOOPS should
create a new storage for the slot that is shared by all @emph{direct}
instances of the subclass.  In other words, a slot with allocation
@code{#:each-subclass} is shared by all instances with the same
@code{class-of}.

@item @code{#:virtual}

Indicates that GOOPS should not allocate storage for this slot.  The
slot definition must also include the @code{#:slot-ref} and
@code{#:slot-set!} options to specify how to reference and set the value
for this slot.
@end itemize

The default value is @code{#:instance}.

Slot allocation options are processed when defining a new class by the
generic function @code{compute-get-n-set}, which is specialized by the
class's metaclass.  Hence new types of slot allocation can be
implemented by defining a new metaclass and a method for
@code{compute-get-n-set} that is specialized for the new metaclass.

Suppose you wanted to create a large number of instances of some class
with a slot that should be shared between some but not all instances of
that class - say every 10 instances should share the same slot storage.
The following example shows how to implement and use a new type of slot
allocation to do this.

@example
(define-class <batched-allocation-metaclass> (<class>))

(let ((batch-allocation-count 0)
      (batch-get-n-set #f))
  (define-method compute-get-n-set ((class <batched-allocation-metaclass>) s)
    (case (slot-definition-allocation s)
      ((#:batched)
       ;; If we've already used the same slot storage for 10 instances,
       ;; reset variables.
       (if (= batch-allocation-count 10)
           (begin
             (set! batch-allocation-count 0)
             (set! batch-get-n-set #f)))
       ;; If we don't have a current pair of get and set closures,
       ;; create one.  make-closure-variable returns a pair of closures
       ;; around a single Scheme variable - see goops.scm for details.
       (or batch-get-n-set
           (set! batch-get-n-set (make-closure-variable)))
       ;; Increment the batch allocation count.
       (set! batch-allocation-count (+ batch-allocation-count 1))
       batch-get-n-set)

      ;; Call next-method to handle standard allocation types.
      (else (next-method)))))

(define-class <class-using-batched-slot> ()
  ...
  (c #:allocation #:batched)
  ...
  #:metaclass <batched-allocation-metaclass>)
@end example       
@end deffn

@deffn {slot option} #:slot-ref getter
@deffnx {slot option} #:slot-set! setter
The @code{#:slot-ref} and @code{#:slot-set!} options must be specified
if the slot allocation is @code{#:virtual}, and are ignored otherwise.

@var{getter} should be a closure taking a single @var{instance} parameter
that returns the current slot value.  @var{setter} should be a closure
taking two parameters - @var{instance} and @var{new-val} - that sets the
slot value to @var{new-val}.
@end deffn

@deffn {slot option} #:getter getter
@deffnx {slot option} #:setter setter
@deffnx {slot option} #:accessor accessor
These options, if present, tell GOOPS to create generic function and
method definitions that can be used to get and set the slot value more
conveniently than by using @code{slot-ref} and @code{slot-set!}.

@var{getter} specifies a generic function to which GOOPS will add a
method for getting the slot value.  @var{setter} specifies a generic
function to which GOOPS will add a method for setting the slot value.
@var{accessor} specifies an accessor to which GOOPS will add methods for
both getting and setting the slot value.

So if a class includes a slot definition like this:

@example
(c #:getter get-count #:setter set-count #:accessor count)
@end example

GOOPS defines generic function methods such that the slot value can be
referenced using either the getter or the accessor -

@example
(let ((current-count (get-count obj))) @dots{})
(let ((current-count (count obj))) @dots{})
@end example

- and set using either the setter or the accessor -

@example
(set-count obj (+ 1 current-count))
(set! (count obj) (+ 1 current-count))
@end example

Note that

@itemize @bullet
@item
with an accessor, the slot value is set using the generalized
@code{set!} syntax

@item
in practice, it is unusual for a slot to use all three of these options:
read-only, write-only and read-write slots would typically use only
@code{#:getter}, @code{#:setter} and @code{#:accessor} options
respectively.
@end itemize

If the specified names are already bound in the top-level environment to
values that cannot be upgraded to generic functions, those values are
overwritten during evaluation of the @code{define-class} that contains
the slot definition.  For details, see @ref{Generic Function Internals,,
ensure-generic}.
@end deffn

@deffn {slot option} #:init-value init-value
@deffnx {slot option} #:init-form init-form
@deffnx {slot option} #:init-thunk init-thunk
@deffnx {slot option} #:init-keyword init-keyword
These options provide various ways to specify how to initialize the
slot's value at instance creation time.  @var{init-value} is a fixed
value.  @var{init-thunk} is a procedure of no arguments that is called
when a new instance is created and should return the desired initial
slot value.  @var{init-form} is an unevaluated expression that gets
evaluated when a new instance is created and should return the desired
initial slot value.  @var{init-keyword} is a keyword that can be used to
pass an initial slot value to @code{make} when creating a new instance.

If more than one of these options is specified for the same slot, the
order of precedence, highest first is

@itemize @bullet
@item
@code{#:init-keyword}, if @var{init-keyword} is present in the options
passed to @code{make}

@item
@code{#:init-thunk} and @code{#:init-form} (with equal precedence)

@item
@code{#:init-value}.
@end itemize

If the slot definition contains more than one initialization option of
the same precedence, the later ones are ignored.  If a slot is not
initialized at all, its value is unbound.

In general, slots that are shared between more than one instance are
only initialized at new instance creation time if the slot value is
unbound at that time.  However, if the new instance creation specifies
a valid init keyword and value for a shared slot, the slot is
re-initialized regardless of its previous value.

Note, however, that the power of GOOPS' meta-object protocol means that
everything written here may be customized or overriden for particular
classes!  The slot initializations described here are performed by the least
specialized method of the generic function @code{initialize}, whose
signature is

@example
(define-method initialize ((object <object>) initargs) ...)
@end example

The initialization of instances of any given class can be customized by
defining a @code{initialize} method that is specialized for that class,
and the author of the specialized method may decide to call
@code{next-method} - which will result in a call to the next less
specialized @code{initialize} method - at any point within the
specialized code, or maybe not at all.  In general, therefore, the
initialization mechanisms described here may be modified or overriden by
more specialized code, or may not be supported at all for particular
classes.
@end deffn

@node Class Definition Internals
@subsection Class Definition Internals

@deffn procedure ensure-metaclass supers env
Return a metaclass suitable for a class that inherits from the list of
classes in @var{supers}.  The returned metaclass is the union by
inheritance of the metaclasses of the classes in @var{supers}.

In the simplest case, where all the @var{supers} are straightforward
classes with metaclass @code{<class>}, the returned metaclass is just
@code{<class>}.

For a more complex example, suppose that @var{supers} contained one
class with metaclass @code{<operator-class>} and one with metaclass
@code{<foreign-object-class>}.  Then the returned metaclass would be a
class that inherits from both @code{<operator-class>} and
@code{<foreign-object-class>}.

If @var{supers} is the empty list, @code{ensure-metaclass} returns the
default GOOPS metaclass @code{<class>}.

GOOPS keeps a list of the metaclasses created by
@code{ensure-metaclass}, so that each required type of metaclass only
has to be created once.

The @code{env} parameter is ignored.
@end deffn

@deffn procedure ensure-metaclass-with-supers meta-supers
Return a metaclass that is the union by inheritance of the metaclasses
in @var{meta-supers}.  For a more detailed discussion and examples, see
@ref{Class Definition Internals,, ensure-metaclass}.
@end deffn

@deffn syntax class name (super @dots{}) slot-definition @dots{} . options
Return a newly created class that inherits from @var{super}s, with
direct slots defined by @var{slot-definition}s and class options
@var{options}.  For the format of @var{slot-definition}s and
@var{options}, see @ref{Basic Class Definition,, define-class}.

Implementation notes: @code{class}

@itemize @bullet
@item
processes the class and slot definition options to check that they are
well-formed, to convert the @code{#:init-form} option to an
@code{#:init-thunk} option, to supply a default environment parameter
(the current top-level environment) and to evaluate all the bits that
need to be evaluated

@item
calls @code{make-class} to create the class with the processed and
evaluated parameters.
@end itemize
@end deffn

@deffn procedure make-class supers slots . options
Return a newly created class that inherits from @var{supers}, with
direct slots defined by @var{slots} and class options @var{options}.
For the format of @var{slots} and @var{options}, see @ref{Basic Class
Definition,, define-class}, except note that for @code{make-class},
@var{slots} and @var{options} are separate list parameters: @var{slots}
here is a list of slot definitions.

Implementation notes: @code{make-class}

@itemize @bullet
@item
adds @code{<object>} to the @var{supers} list if @var{supers} is empty
or if none of the classes in @var{supers} have @code{<object>} in their
class precedence list

@item
defaults the @code{#:environment}, @code{#:name} and @code{#:metaclass}
options, if they are not specified by @var{options}, to the current
top-level environment, the unbound value, and @code{(ensure-metaclass
@var{supers})} respectively (@pxref{Class Definition Internals,,
ensure-metaclass})

@item
checks for duplicate classes in @var{supers} and duplicate slot names in
@var{slots}, and signals an error if there are any duplicates

@item
calls @code{make}, passing the metaclass as the first parameter and all
other parameters as option keywords with values.
@end itemize
@end deffn

@node Customizing Class Definition
@subsection Customizing Class Definition

@node STKlos Compatibility
@subsection STKlos Compatibility

@deffn syntax standard-define-class name (super @dots{}) slot-definition @dots{} . options
If the STKlos compatibility module is loaded, @code{define-class} is
overwritten by a STKlos-specific definition; the standard GOOPS
definition of @code{define-class} remains available in
@code{standard-define-class}.
@end deffn

@node Creating Instances
@section Creating Instances

@menu
* Basic Instance Creation::
* Customizing Instance Creation::
@end menu

@node Basic Instance Creation
@subsection Basic Instance Creation

@deffn generic make
@deffnx method make (class <class>) . initargs
@deffnx generic make-instance
@deffnx method make-instance (class <class>) . initargs
*fixme*
@end deffn

@node Customizing Instance Creation
@subsection Customizing Instance Creation

@node Accessing Slots
@section Accessing Slots

@menu
* Class Slots::
* Instance Slots::
* Handling Slot Access Errors::
@end menu

@node Class Slots
@subsection Class Slots

@deffn procedure class-slot-ref class slot-name
Return the value of the slot named @var{slot-name} in class @var{class}.
The named slot must have @code{#:class} or @code{#:each-subclass}
allocation (@pxref{Slot Options,, allocation}).

If there is no such slot with @code{#:class} or @code{#:each-subclass}
allocation, @code{class-slot-ref} calls the @code{slot-missing} generic
function with arguments @var{class} and @var{slot-name}.  Otherwise, if
the slot value is unbound, @code{class-slot-ref} calls the
@code{slot-missing} generic function, with the same arguments.
@end deffn

@deffn procedure class-slot-set! class slot-name value
Set the value of the slot named @var{slot-name} in class @var{class} to
@var{value}.  The named slot must have @code{#:class} or
@code{#:each-subclass} allocation (@pxref{Slot Options,, allocation}).

If there is no such slot with @code{#:class} or @code{#:each-subclass}
allocation, @code{class-slot-ref} calls the @code{slot-missing} generic
function with arguments @var{class} and @var{slot-name}.
@end deffn

@node Instance Slots
@subsection Instance Slots

@node Handling Slot Access Errors
@subsection Handling Slot Access Errors

@deffn generic slot-missing
@deffnx method slot-missing (class <class>) slot-name
@deffnx method slot-missing (class <class>) (object <object>) slot-name
@deffnx method slot-missing (class <class>) (object <object>) slot-name value
When an application attempts to reference or set a class or instance
slot by name, and the slot name is invalid for the specified @var{class}
or @var{object}, GOOPS calls the @code{slot-missing} generic function.
The default methods all call @code{goops-error} with an appropriate
message.
@end deffn

@deffn generic slot-unbound
@deffnx method slot-unbound (object <object>)
@deffnx method slot-unbound (class <class>) slot-name
@deffnx method slot-unbound (class <class>) (object <object>) slot-name
When an application attempts to reference a class or instance slot, and
the slot's value is unbound, GOOPS calls the @code{slot-unbound} generic
function.  The default methods all call @code{goops-error} with an
appropriate message.
@end deffn

@node Creating Generic Functions
@section Creating Generic Functions

@menu
* Basic Generic Function Creation::
* Generic Function Internals::
* Upgrading a Previous Non-Generic Procedure::
* Customizing Generic Function Creation::
@end menu

@node Basic Generic Function Creation
@subsection Basic Generic Function Creation

@deffn syntax define-generic symbol
Create a generic function with name @var{symbol} and bind it to the
variable @var{symbol}.

If the variable @var{symbol} was previously bound to a Scheme procedure
(or procedure-with-setter), the old procedure (and setter) is
incorporated into the new generic function as its default procedure (and
setter).  Any other previous value that was bound to @var{symbol},
including an existing generic function, is overwritten by the new
generic function.

Implementation notes: @code{define-generic} calls @code{ensure-generic}
to upgrade a pre-existing procedure value, or @code{make} with metaclass
@code{<generic>} to create a new generic function.
@end deffn

@deffn syntax define-accessor symbol
Create an accessor with name @var{symbol} and bind it to the variable
@var{symbol}.

If the variable @var{symbol} was previously bound to a Scheme procedure
(or procedure-with-setter), the old procedure (and setter) is
incorporated into the new accessor as its default procedure (and
setter).  Any other previous value that was bound to @var{symbol},
including an existing generic function or accessor, is overwritten by
the new definition.

Implementation notes: @code{define-accessor} calls
@code{ensure-accessor} to upgrade a pre-existing procedure value, or
@code{make-accessor} to create a new accessor.
@end deffn

@node Generic Function Internals
@subsection Generic Function Internals

@deffn procedure make-generic . name
Return a new generic function with name @code{(car @var{name})}.

Implementation notes: @code{make-generic} is a simple wrapper for
@code{make} with metaclass @code{<generic>}.
@end deffn

@deffn procedure ensure-generic old-definition . name
Return a generic function with name @var{name}, if possible by using or
upgrading @var{old-definition}.

If @var{old-definition} is already a generic function, it is returned
unchanged.

If @var{old-definition} is a Scheme procedure or procedure-with-setter,
@code{ensure-generic} returns a new generic function that uses
@var{old-definition} for its default procedure and setter.

Otherwise @code{ensure-generic} returns a new generic function with no
defaults and no methods.

Implementation notes: @code{ensure-generic} calls @code{make} with
metaclasses @code{<generic>} and @code{<generic-with-setter>}.
@end deffn

@deffn procedure make-accessor . name
Return a new accessor with name @code{(car @var{name})}.

Implementation notes: @code{make-accessor} calls @code{make} twice, first
with metaclass @code{<generic>} to create a generic function for the
setter, then with metaclass @code{<generic-with-setter>} to create the
accessor, passing the setter generic function as the value of the
@code{#:setter} keyword.
@end deffn

@deffn procedure ensure-accessor proc . name
Return an accessor with name @var{name}, if possible by using or
upgrading @var{proc}.

If @var{proc} is already an accessor, it is returned unchanged.

If @var{proc} is a Scheme procedure, procedure-with-setter or generic
function, @code{ensure-accessor} returns an accessor that reuses the
reusable elements of @var{proc}.

Otherwise @code{ensure-accessor} returns a new accessor with no defaults
and no methods.

Implementation notes: @code{ensure-accessor} calls @code{make} with
metaclass @code{<generic-with-setter>}, as well as calls to
@code{ensure-generic}, @code{make-accessor} and (tail recursively)
@code{ensure-accessor}.
@end deffn

@node Upgrading a Previous Non-Generic Procedure
@subsection Upgrading a Previous Non-Generic Procedure

@node Customizing Generic Function Creation
@subsection Customizing Generic Function Creation

@node Adding Methods to Generic Functions
@section Adding Methods to Generic Functions

@menu
* Basic Method Definition::
* Method Definition Internals::
* Customizing Method Definition::
@end menu

@node Basic Method Definition
@subsection Basic Method Definition

@deffn syntax define-method symbol (parameter @dots{}) . body
Define a method for the generic function or accessor @var{symbol} with
parameters @var{parameter}s and body @var{body}.

@var{symbol} must be either a symbol for a variable bound to a generic
function or accessor, or @code{(setter @var{accessor-symbol})}, where
@var{accessor-symbol} is a symbol for a variable bound to an accessor.
If the former, @code{define-method} defines a reference method for the
specified generic function or accessor; if the latter,
@code{define-method} defines a setter method for the specified accessor.
The @var{symbol} parameter is subject to these restrictions (rather than
being allowed to be anything that evaluates to a generic function) so
that @code{define-method} can construct a call to @code{define-generic}
or @code{define-accessor} if @var{symbol} is not already defined as a
generic function.

Each @var{parameter} must be either a symbol or a two-element list
@code{(@var{symbol} @var{class})}.  The symbols refer to variables in
the @var{body} that will be bound to the parameters supplied by the
caller when calling this method.  The @var{class}es, if present,
specify the possible combinations of parameters to which this method
can be applied.

For example, if a generic function method is defined with
@var{parameter}s @code{((s1 <square>) (n <number>))}, that method is
only applicable to invocations of its generic function that have two
parameters where the first parameter is an instance of the
@code{<square>} class and the second parameter is a number.  (If a
generic function is invoked with a combination of parameters for which
there is no applicable method, GOOPS raises an error.)

@var{body} is the body of the method definition.

Implementation notes: @code{define-method}

@itemize @bullet
@item
checks the form of the first parameter, and applies the following steps
to the accessor's setter if it has the @code{(setter @dots{})} form

@item
interpolates a call to @code{define-generic} or @code{define-accessor}
if a generic function is not already defined with the supplied name

@item
calls @code{method} with the @var{parameter}s and @var{body}, to make a
new method instance

@item
calls @code{add-method!} to add this method to the relevant generic
function.
@end itemize
@end deffn

@node Method Definition Internals
@subsection Method Definition Internals

@deffn generic add-method! target method
Generic function for adding method @var{method} to @var{target}.
@end deffn

@deffn method add-method! (generic <generic>) (method <method>)
Add method @var{method} to the generic function @var{generic}.
@end deffn

@deffn method add-method! (proc <procedure>) (method <method>)
If @var{proc} is a procedure with generic capability (@pxref{Upgrading a
Previous Non-Generic Procedure,, generic-capability?}), upgrade it to a
primitive generic and add @var{method} to its generic function
definition.

Implementation notes: looks broken to me in the current CVS, since I
don't believe it is ever possible for @code{(generic-capability?
<procedure>)} to be true.
@end deffn

@deffn method add-method! (pg <primitive-generic>) (method <method>)
Add method @var{method} to the generic function definition of @var{pg}.

Implementation notes: @code{(add-method! (primitive-generic-generic pg) method)}.
@end deffn

@deffn method add-method! (whatever <top>) (method <method>)
Raise an error indicating that @var{whatever} is not a valid generic
function.
@end deffn

@deffn syntax method (parameter @dots{}) . body
Make a method whose specializers are defined by the classes in
@var{parameter}s and whose procedure definition is constructed from the
@var{parameter} symbols and @var{body} forms.

The @var{parameter} and @var{body} parameters should be as for
@code{define-method} (@pxref{Basic Method Definition,, define-method}).

Implementation notes: @code{method}

@itemize @bullet
@item
extracts formals and specializing classes from the @var{parameter}s,
defaulting the class for unspecialized parameters to @code{<top>}

@item
creates a closure using the formals and the @var{body} forms

@item
calls @code{make} with metaclass @code{<method>} and the specializers
and closure using the @code{#:specializers} and @code{#:procedure}
keywords.
@end itemize
@end deffn

@deffn procedure make-method specializers procedure
Make a method using @var{specializers} and @var{procedure}.

@var{specializers} should be a list of classes that specifies the
parameter combinations to which this method will be applicable.

@var{procedure} should be the closure that will applied to the generic
function parameters when this method is invoked.

@code{make-method} is a simple wrapper around @code{make} with metaclass
@code{<method>}.
@end deffn

@node Customizing Method Definition
@subsection Customizing Method Definition

@node Invoking Generic Functions
@section Invoking Generic Functions

@menu
* Determining Which Methods to Apply::
* Handling Invocation Errors::
@end menu

@node Determining Which Methods to Apply
@subsection Determining Which Methods to Apply

@node Handling Invocation Errors
@subsection Handling Invocation Errors

@deffn generic no-method
@deffnx method no-method (gf <generic>) args
When an application invokes a generic function, and no methods at all
have been defined for that generic function, GOOPS calls the
@code{no-method} generic function.  The default method calls
@code{goops-error} with an appropriate message.
@end deffn

@deffn generic no-applicable-method
@deffnx method no-applicable-method (gf <generic>) args
When an application applies a generic function to a set of arguments,
and no methods have been defined for those argument types, GOOPS calls
the @code{no-applicable-method} generic function.  The default method
calls @code{goops-error} with an appropriate message.
@end deffn

@deffn generic no-next-method
@deffnx method no-next-method (gf <generic>) args
When a generic function method calls @code{(next-method)} to invoke the
next less specialized method for that generic function, and no less
specialized methods have been defined for the current generic function
arguments, GOOPS calls the @code{no-next-method} generic function.  The
default method calls @code{goops-error} with an appropriate message.
@end deffn

@node Redefining a Class
@section Redefining a Class

@node Changing the Class of an Instance
@section Changing the Class of an Instance

@node Introspection
@section Introspection

@menu
* Classes::
* Instances::
* Generic Functions::
* Generic Function Methods::
@end menu

@node Classes
@subsection Classes

@deffn procedure class-slot-definition class slot-name
Return the slot definition for the slot named @var{slot-name} in class
@var{class}.  @var{slot-name} should be a symbol.
@end deffn

@deffn procedure slot-definition-name slot-def
Extract and return the slot name from @var{slot-def}.
@end deffn

@deffn procedure slot-definition-options slot-def
Extract and return the slot options from @var{slot-def}.
@end deffn

@deffn procedure slot-definition-allocation slot-def
Extract and return the slot allocation option from @var{slot-def}.  This
is the value of the @code{#:allocation} keyword (@pxref{Slot Options,,
allocation}), or @code{#:instance} if the @code{#:allocation} keyword is
absent.
@end deffn

@deffn procedure slot-definition-getter slot-def
Extract and return the slot getter option from @var{slot-def}.  This is
the value of the @code{#:getter} keyword (@pxref{Slot Options,,
getter}), or @code{#f} if the @code{#:getter} keyword is absent.
@end deffn

@deffn procedure slot-definition-setter slot-def
Extract and return the slot setter option from @var{slot-def}.  This is
the value of the @code{#:setter} keyword (@pxref{Slot Options,,
setter}), or @code{#f} if the @code{#:setter} keyword is absent.
@end deffn

@deffn procedure slot-definition-accessor slot-def
Extract and return the slot accessor option from @var{slot-def}.  This
is the value of the @code{#:accessor} keyword (@pxref{Slot Options,,
accessor}), or @code{#f} if the @code{#:accessor} keyword is absent.
@end deffn

@deffn procedure slot-definition-init-value slot-def
Extract and return the slot init-value option from @var{slot-def}.  This
is the value of the @code{#:init-value} keyword (@pxref{Slot Options,,
init-value}), or the unbound value if the @code{#:init-value} keyword is
absent.
@end deffn

@deffn procedure slot-definition-init-form slot-def
Extract and return the slot init-form option from @var{slot-def}.  This
is the value of the @code{#:init-form} keyword (@pxref{Slot Options,,
init-form}), or the unbound value if the @code{#:init-form} keyword is
absent.
@end deffn

@deffn procedure slot-definition-init-thunk slot-def
Extract and return the slot init-thunk option from @var{slot-def}.  This
is the value of the @code{#:init-thunk} keyword (@pxref{Slot Options,,
init-thunk}), or @code{#f} if the @code{#:init-thunk} keyword is absent.
@end deffn

@deffn procedure slot-definition-init-keyword slot-def
Extract and return the slot init-keyword option from @var{slot-def}.
This is the value of the @code{#:init-keyword} keyword (@pxref{Slot
Options,, init-keyword}), or @code{#f} if the @code{#:init-keyword}
keyword is absent.
@end deffn

@deffn procedure slot-init-function class slot-name
Return the initialization function for the slot named @var{slot-name} in
class @var{class}.  @var{slot-name} should be a symbol.

The returned initialization function incorporates the effects of the
standard @code{#:init-thunk}, @code{#:init-form} and @code{#:init-value}
slot options.  These initializations can be overriden by the
@code{#:init-keyword} slot option or by a specialized @code{initialize}
method, so, in general, the function returned by
@code{slot-init-function} may be irrelevant.  For a fuller discussion,
see @ref{Slot Options,, init-value}.
@end deffn

@node Instances
@subsection Instances

@deffn procedure is-a? object class
Return @code{#t} if @var{object} is an instance of @var{class} or one of
its subclasses.

Implementation notes: @code{is-a?} uses @code{class-of} and
@code{class-precedence-list} to obtain the class precedence list for
@var{object}.
@end deffn

@node Generic Functions
@subsection Generic Functions

@node Generic Function Methods
@subsection Generic Function Methods

@deffn generic method-source
@deffnx method method-source (m <method>)
Return an expression that prints to show the definition of method
@var{m}.

@example
(define-generic cube)
(define-method cube ((n <number>))
  (* n n n))
(map method-source (generic-function-methods cube))
@result{}
((method ((n <number>)) (* n n n)))
@end example
@end deffn

@node Miscellaneous Functions
@section Miscellaneous Functions

@menu
* Administrative Functions::
* Error Handling::
* Object Comparisons::
* Cloning Objects::
* Write and Display::
@end menu

@node Administrative Functions
@subsection Administration Functions

This section describes administrative, non-technical GOOPS functions.

@deffn primitive goops-version
Return the current GOOPS version as a string, for example ``0.2''.
@end deffn

@node Error Handling
@subsection Error Handling

@deffn procedure goops-error format-string . args
Raise an error with key @code{goops-error} and error message constructed
from @var{format-string} and @var{args}.  Error message formatting is
as done by @code{scm-error}.

@code{goops-error} is used to raise an appropriate error by the default
methods of the following generic functions.  If you customize these
functions for particular classes or metaclasses, you may still want to
use @code{goops-error} to signal any error conditions that you detect.
@end deffn

@node Object Comparisons
@subsection Object Comparisons

@deffn generic object-eqv?
@deffnx method object-eqv? ((x <top>) (y <top>))
@deffnx generic object-equal?
@deffnx method object-equal? ((x <top>) (y <top>))
Generic functions and default (unspecialized) methods for comparing two
GOOPS objects.

The default methods always return @code{#f}.  Application class authors
may wish to define specialized methods for @code{object-eqv?} and
@code{object-equal?} that compare instances of the same class for
equality in whatever sense is useful to the application.
@end deffn

@node Cloning Objects
@subsection Cloning Objects

@deffn generic shallow-clone
@deffnx method shallow-clone (self <object>)
Return a ``shallow'' clone of @var{self}.  The default method makes a
shallow clone by allocating a new instance and copying slot values from
self to the new instance.  Each slot value is copied either as an
immediate value or by reference.
@end deffn

@deffn generic deep-clone
@deffnx method deep-clone (self <object>)
Return a ``deep'' clone of @var{self}.  The default method makes a deep
clone by allocating a new instance and copying or cloning slot values
from self to the new instance.  If a slot value is an instance
(satisfies @code{instance?}), it is cloned by calling @code{deep-clone}
on that value.  Other slot values are copied either as immediate values
or by reference.
@end deffn

@node Write and Display
@subsection Write and Display

@deffn {primitive generic} write object port
@deffnx {primitive generic} display object port
When GOOPS is loaded, @code{write} and @code{display} become generic
functions with special methods for printing

@itemize @bullet
@item
objects - instances of the class @code{<object>}

@item
foreign objects - instances of the class @code{<foreign-object>}

@item
classes - instances of the class @code{<class>}

@item
generic functions - instances of the class @code{<generic>}

@item
methods - instances of the class @code{<method>}.
@end itemize

@code{write} and @code{display} print non-GOOPS values in the same way
as the Guile primitive @code{write} and @code{display} functions.
@end deffn

@node MOP Specification, Tutorial, Reference Manual, Top
@chapter MOP Specification

@node Tutorial, Index, MOP Specification, Top
@chapter Tutorial
@include goops-tutorial.texi

@node Index, Concept Index, Tutorial, Top
@chapter Index
@page
@node     Concept Index, Function and Variable Index, Index, Top
@unnumberedsec Concept Index

@printindex cp

@node Function and Variable Index,  , Concept Index, Top
@unnumberedsec Function and Variable Index

@printindex fn

@summarycontents
@contents
@bye
