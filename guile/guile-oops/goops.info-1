This is goops.info, produced by makeinfo version 4.0 from goops.texi.

INFO-DIR-SECTION Scheme Programming
START-INFO-DIR-ENTRY
* goops: (goops).          The GOOPS reference manual.
END-INFO-DIR-ENTRY

This file documents GOOPS, an object oriented extension for Guile.

Copyright (C) 1999, 2000 Free Software Foundation

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.


File: goops.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

* Menu:

[When the manual is completed, this will be a flat index in the style of
 the Emacs manual.  More nodes will turn up under parts I-III.]

Part I: Preliminaries

* Introduction::
* Getting Started::

Part II: Reference Manual

* Reference Manual::

Part III: GOOPS Meta Object Protocol

* MOP Specification::

The GOOPS tutorial

* Tutorial::

* Index::
* Concept Index::
* Function and Variable Index::


File: goops.info,  Node: Introduction,  Next: Getting Started,  Prev: Top,  Up: Top

Introduction
============

GOOPS is the object oriented extension to Guile. Its implementation is
derived from STk-3.99.3 by Erick Gallesio and version 1.3 of Gregor
Kiczales `Tiny-Clos'.  It is very close in spirit to CLOS, the Common
Lisp Object System (`CLtL2') but is adapted for the Scheme language.
While GOOPS is not compatible with any of these systems, GOOPS contains
a compatibility module which allows for execution of STKlos programs.

Briefly stated, the GOOPS extension gives the user a full object
oriented system with multiple inheritance and generic functions with
multi-method dispatch.  Furthermore, the implementation relies on a true
meta object protocol, in the spirit of the one defined for CLOS
(`Gregor Kiczales: A Metaobject Protocol').


File: goops.info,  Node: Getting Started,  Next: Reference Manual,  Prev: Introduction,  Up: Top

Getting Started
===============

* Menu:

* Running GOOPS::

Examples of some basic GOOPS functionality.

* Methods::
* User-defined types::
* Asking for the type of an object::

See further in the GOOPS tutorial available in this distribution in
info (goops.info) and texinfo format.


File: goops.info,  Node: Running GOOPS,  Next: Methods,  Prev: Getting Started,  Up: Getting Started

Running GOOPS
-------------

  1. Type

          guile-oops

     You should now be at the Guile prompt ("guile> ").

  2. Type

          (use-modules (oop goops))

     to load GOOPS.  (If your system supports dynamic loading, you
     should be able to do this not only from `guile-oops' but from an
     arbitrary Guile interpreter.)

We're now ready to try some basic GOOPS functionality.


File: goops.info,  Node: Methods,  Next: User-defined types,  Prev: Running GOOPS,  Up: Getting Started

Methods
-------

     (define-method + ((x <string>) (y <string>))
       (string-append x y))
     
     (+ 1 2) --> 3
     (+ "abc" "de") --> "abcde"


File: goops.info,  Node: User-defined types,  Next: Asking for the type of an object,  Prev: Methods,  Up: Getting Started

User-defined types
------------------

     (define-class <2D-vector> ()
       (x #:init-value 0 #:accessor x-component #:init-keyword #:x)
       (y #:init-value 0 #:accessor y-component #:init-keyword #:y))
     
     (use-modules (ice-9 format))
     
     (define-method write ((obj <2D-vector>) port)
       (display (format #f "<~S, ~S>" (x-component obj) (y-component obj))
                port))
     
     (define v (make <2D-vector> #:x 3 #:y 4))
     
     v --> <3, 4>
     
     (define-method + ((x <2D-vector>) (y <2D-vector>))
       (make <2D-vector>
             #:x (+ (x-component x) (x-component y))
             #:y (+ (y-component x) (y-component y))))
     
     (+ v v) --> <6, 8>


File: goops.info,  Node: Asking for the type of an object,  Prev: User-defined types,  Up: Getting Started

Types
-----

     (class-of v) --> #<<class> <2D-vector> 40241ac0>
     <2D-vector>  --> #<<class> <2D-vector> 40241ac0>
     (class-of 1) --> #<<class> <integer> 401b2a98>
     <integer>    --> #<<class> <integer> 401b2a98>
     
     (is-a? v <2D-vector>) --> #t


File: goops.info,  Node: Reference Manual,  Next: MOP Specification,  Prev: Getting Started,  Up: Top

Reference Manual
****************

This chapter is the GOOPS reference manual.  It aims to describe all the
syntax, procedures, options and associated concepts that a typical
application author would need to understand in order to use GOOPS
effectively in their application.  It also describes what is meant by
the GOOPS "metaobject protocol" (aka "MOP"), and indicates how authors
can use the metaobject protocol to customize the behaviour of GOOPS
itself.

For a detailed specification of the GOOPS meta-object protocol, see
*Note MOP Specification::.

* Menu:

* Introductory Remarks::
* Defining New Classes::
* Creating Instances::
* Accessing Slots::
* Creating Generic Functions::
* Adding Methods to Generic Functions::
* Invoking Generic Functions::
* Redefining a Class::
* Changing the Class of an Instance::
* Introspection::
* Miscellaneous Functions::


File: goops.info,  Node: Introductory Remarks,  Next: Defining New Classes,  Up: Reference Manual

Introductory Remarks
====================

GOOPS is an object-oriented programming system based on a "metaobject
protocol" derived from the ones used in CLOS (the Common Lisp Object
System), tiny-clos (a small Scheme implementation of a subset of CLOS
functionality) and STKlos.

GOOPS can be used by application authors at a basic level without any
need to understand what the metaobject protocol (aka "MOP") is and how
it works.  On the other hand, the MOP underlies even the customizations
that application authors are likely to make use of very quickly -- such
as defining an `initialize' method to customize the initialization of
instances of an application-defined class -- and an understanding of
the MOP makes it much easier to explain such customizations in a precise
way.  And in the long run, understanding the MOP is the key both to
understanding GOOPS at a deeper level and to taking full advantage of
GOOPS' power, by customizing the behaviour of GOOPS itself.

Each of the following sections of the reference manual is arranged such
that the most basic usage is introduced first, and then subsequent
subsections discuss the related internal functions and metaobject
protocols, finishing with a description of how to customize that area of
functionality.

These introductory remarks continue with a few words about metaobjects
and the MOP.  Readers who do not want to be bothered yet with the MOP
and customization could safely skip this subsection on a first reading,
and should correspondingly skip subsequent subsections that are
concerned with internals and customization.

In general, this reference manual assumes familiarity with standard
object oriented concepts and terminology.  However, some of the terms
used in GOOPS is less well known, so the Terminology subsection
provides definitions for these terms.

* Menu:

* Metaobjects and the Metaobject Protocol::
* Terminology::


File: goops.info,  Node: Metaobjects and the Metaobject Protocol,  Next: Terminology,  Up: Introductory Remarks

Metaobjects and the Metaobject Protocol
---------------------------------------

The conceptual building blocks of GOOPS are classes, slot definitions,
instances, generic functions and methods.  A class is a grouping of
inheritance relations and slot definitions.  An instance is an object
with slots that are allocated following the rules implied by its class's
superclasses and slot definitions.  A generic function is a collection
of methods and rules for determining which of those methods to apply
when the generic function is invoked.  A method is a procedure and a set
of specializers that specify the type of arguments to which the
procedure is applicable.

Of these entities, GOOPS represents classes, generic functions and
methods as "metaobjects".  In other words, the values in a GOOPS
program that describe classes, generic functions and methods, are
themselves instances (or "objects") of special GOOPS classes that
encapsulate the behaviour, respectively, of classes, generic functions,
and methods.

(The other two entities are slot definitions and instances.  Slot
definitions are not strictly instances, but every slot definition is
associated with a GOOPS class that specifies the behaviour of the slot
as regards accessibility and protection from garbage collection.
Instances are of course objects in the usual sense, and there is no
benefit from thinking of them as metaobjects.)

The "metaobject protocol" (aka "MOP") is the specification of the
generic functions which determine the behaviour of these metaobjects and
the circumstances in which these generic functions are invoked.

For a concrete example of what this means, we need to introduce the
`initialize' generic function, which GOOPS calls whenever a new
instance is created, immediately after allocating memory for a new
instance, to initialize the new instance's slots.

Now consider how GOOPS calculates the set of slots for a class that is
being defined using `define-class'.  The desired set of slots is the
union of the new class's direct slots and the slots of all its
superclasses.  But `define-class' itself does not perform this
calculation.  Instead, there is a method of the `initialize' generic
function that is specialized for instances of type `<class>', and it is
this method that performs the slot calculation.  The sequence of steps
is as follows.

   * `define-class' uses `make' to make a new instance of the
     `<class>', passing as initialization arguments the superclasses,
     slot definitions and class options that were specified in the
     `define-class' form.

   * `make' allocates memory for the new instance, and then invokes the
     `initialize' generic function to initialize the new instance's
     slots.

   * The `initialize' generic function applies the method that is
     specialized for instances of type `<class>', and this method
     performs the slot calculation.

In other words, rather than being hardcoded in `define-class', the
behaviour of class definition is encapsulated by generic function
methods that are specialized for the class `<class>'.

It is possible to create a new class that inherits from `<class>',
which is called a "metaclass", and to write a new `initialize' method
that is specialized for instances of the new metaclass.  Then, if the
`define-class' form includes a `#:metaclass' class option whose value
is the new metaclass, the class that is defined by the `define-class'
form will be an instance of the new metaclass instead of the default
`<class>', and will be defined in accordance with the new `initialize'
method.  Thus the default slot calculation, as well as any other aspect
of the new class's relationship with its superclasses, can be modified
or overriden.

In a similar way, the behaviour of generic functions can be modified or
overriden by creating a new class that inherits from the standard
generic function class `<generic>', writing appropriate methods that
are specialized to the new class, and creating new generic functions
that are instances of the new class.

The same is true for generic function method metaobjects.  And the same
basic mechanism allows the application class author to write an
`initialize' method that is specialized to their application class, to
initialize instances of that class.

Such is the power of the MOP.  Note that `initialize' is just one of a
large number of generic functions that can be customized to modify the
behaviour of application objects and classes and of GOOPS itself.  Each
subsequent section of the reference manual covers a particular area of
GOOPS functionality, and describes the generic functions that are
relevant for customization of that area.

We conclude this subsection by emphasizing a point that may seem
obvious, but contrasts with the corresponding situation in some other
MOP implementations, such as CLOS.  The point is simply that an
identifier which represents a GOOPS class or generic function is a
variable with a first-class value, the value being an instance of class
`<class>' or `<generic>'.  (In CLOS, on the other hand, a class
identifier is a symbol that indexes the corresponding class metaobject
in a separate namespace for classes.)  This is, of course, simply an
extension of the tendency in Scheme to avoid the unnecessary use of, on
the one hand, syntactic forms that require unevaluated arguments and,
on the other, separate identifier namespaces (e.g. for class names),
but it is worth noting that GOOPS conforms fully to this Schemely
principle.


File: goops.info,  Node: Terminology,  Prev: Metaobjects and the Metaobject Protocol,  Up: Introductory Remarks

Terminology
-----------

It is assumed that the reader is already familiar with standard object
orientation concepts such as classes, objects/instances,
inheritance/subclassing, generic functions and methods, encapsulation
and polymorphism.

This section explains some of the less well known concepts and
terminology that GOOPS uses, which are assumed by the following sections
of the reference manual.

* Menu:

* Metaclass::
* Class Precedence List::
* Accessor::


File: goops.info,  Node: Metaclass,  Next: Class Precedence List,  Up: Terminology

Metaclass
.........

A metaclass is the class of an object which represents a GOOPS class.
Put more succinctly, a metaclass is a class's class.

Most GOOPS classes have the metaclass `<class>' and, by default, any
new class that is created using `define-class' has the metaclass
`<class>'.

But what does this really mean?  To find out, let's look in more detail
at what happens when a new class is created using `define-class':

     (define-class <my-class> (<object>) . slots)

GOOPS actually expands the `define-class' form to something like this:

     (define <my-class>
       (make <class> #:supers (list <object>) #:slots slots))

In other words, the value of `<my-class>' is in fact an instance of the
class `<class>' with slot values specifying the superclasses and slot
definitions for the class `<my-class>'.  (`#:supers' and `#:slots' are
initialization keywords for the `dsupers' and `dslots' slots of the
`<class>' class.)

In order to take advantage of the full power of the GOOPS meta-object
protocol (*note MOP Specification::), it is sometimes desirable to
create a new class with a metaclass other than the default `<class>'.
This is done by writing:

     (define-class <my-class2> (<object>)
        #:metaclass <my-metaclass> . slots)

And GOOPS would expand this to something like:

     (define <my-class2>
       (make <my-metaclass> #:supers (list <object>) #:slots slots))

In this case, the value of `<my-class2>' is an instance of the more
specialized class `<my-metaclass>'.  Note that `<my-metaclass>' itself
must previously have been defined as a subclass of `<class>'.  For a
full discussion of when and how it is useful to define new metaclasses,
see *Note MOP Specification::.

Now let's make an instance of `<my-class2>':

     (define my-object (make <my-class2> ...))

All of the following statements are correct expressions of the
relationships between `my-object', `<my-class2>', `<my-metaclass>' and
`<class>'.

   * `my-object' is an instance of the class `<my-class2>'.

   * `<my-class2>' is an instance of the class `<my-metaclass>'.

   * `<my-metaclass>' is an instance of the class `<class>'.

   * The class of `my-object' is `<my-class2>'.

   * The metaclass of `my-object' is `<my-metaclass>'.

   * The class of `<my-class2>' is `<my-metaclass>'.

   * The metaclass of `<my-class2>' is `<class>'.

   * The class of `<my-metaclass>' is `<class>'.

   * The metaclass of `<my-metaclass>' is `<class>'.

   * `<my-class2>' is not a metaclass, since it is does not inherit from
     `<class>'.

   * `<my-metaclass>' is a metaclass, since it inherits from `<class>'.


File: goops.info,  Node: Class Precedence List,  Next: Accessor,  Prev: Metaclass,  Up: Terminology

Class Precedence List
.....................

The "class precedence list" of a class is the list of all direct and
indirect superclasses of that class, including the class itself.

In the absence of multiple inheritance, the class precedence list is
ordered straightforwardly, beginning with the class itself and ending
with `<top>'.

For example, given this inheritance hierarchy:

     (define-class <invertebrate> (<object>) ...)
     (define-class <echinoderm> (<invertebrate>) ...)
     (define-class <starfish> (<echinoderm>) ...)

the class precedence list of <starfish> would be

     (<starfish> <echinoderm> <invertebrate> <object> <top>)

With multiple inheritance, the algorithm is a little more complicated.
A full description is provided by the GOOPS Tutorial: see *Note Class
precedence list::.

"Class precedence list" is often abbreviated, in documentation and
Scheme variable names, to "cpl".


File: goops.info,  Node: Accessor,  Prev: Class Precedence List,  Up: Terminology

Accessor
........

An accessor is a generic function with both reference and setter
methods.

     (define-accessor perimeter)

Reference methods for an accessor are defined in the same way as generic
function methods.

     (define-method perimeter ((s <square>))
       (* 4 (side-length s)))

Setter methods for an accessor are defined by specifying "(setter
<accessor-name>)" as the first parameter of the `define-method' call.

     (define-method (setter perimeter) ((s <square>) (n <number>))
       (set! (side-length s) (/ n 4)))

Once an appropriate setter method has been defined in this way, it can
be invoked using the generalized `set!' syntax, as in:

     (set! (perimeter s1) 18.3)


File: goops.info,  Node: Defining New Classes,  Next: Creating Instances,  Prev: Introductory Remarks,  Up: Reference Manual

Defining New Classes
====================

* Menu:

* Basic Class Definition::
* Class Options::
* Slot Options::
* Class Definition Internals::
* Customizing Class Definition::
* STKlos Compatibility::


File: goops.info,  Node: Basic Class Definition,  Next: Class Options,  Up: Defining New Classes

Basic Class Definition
----------------------

 - syntax: define-class name (super ...) slot-definition ... . options
     Define a class called NAME that inherits from SUPERs, with direct
     slots defined by SLOT-DEFINITIONs and class options OPTIONS.  The
     newly created class is bound to the variable name NAME in the
     current (*fixme* top-level?) environment.

     Each SLOT-DEFINITION is either a symbol that names the slot or a
     list:

          (SLOT-NAME-SYMBOL . SLOT-OPTIONS)

     OPTIONS and each SLOT-OPTIONS must be a list with an even number
     of elements, where the even-numbered elements (starting from zero)
     are class- and slot-option keywords and the odd-numbered elements
     are the corresponding values for those keywords.

     Example 1.  Define a class that combines two pre-existing classes
     by inheritance but adds no new slots.

          (define-class <combined> (<tree> <bicycle>))

     Example 2.  Define a `regular-polygon' class with slots for side
     length and number of sides that have default values and can be
     accessed via the generic functions `side-length' and `num-sides'.

          (define-class <regular-polygon> ()
            (sl #:init-value 1 #:accessor side-length)
            (ns #:init-value 5 #:accessor num-sides))

     Example 3.  Define a class whose behavior (and that of its
     instances) is customized via an application-defined metaclass.

          (define-class <tcpip-fsm> ()
            (s #:init-value #f #:accessor state)
            ...
            #:metaclass <finite-state-class>)

     For more details about the available class and slot options, see
     *Note Class Options:: and *Note Slot Options::.

     Implementation notes: `define-class'

        * checks that it is being called only at top level

        * defines any accessors that are implied by the SLOT-DEFINITIONs

        * calls `class' to create the new class (*note class: Class
          Definition Internals.)

        * checks for a previous class definition for NAME and, if found,
          handles the redefinition by calling `class-redefinition'
          (*note class-redefinition: MOP Specification.).


File: goops.info,  Node: Class Options,  Next: Slot Options,  Prev: Basic Class Definition,  Up: Defining New Classes

Class Options
-------------


File: goops.info,  Node: Slot Options,  Next: Class Definition Internals,  Prev: Class Options,  Up: Defining New Classes

Slot Options
------------

 - slot option: #:allocation allocation
     The `#:allocation' option tells GOOPS how to allocate storage for
     the slot.  Possible values for ALLOCATION are

        * `#:instance'

          Indicates that GOOPS should create separate storage for this
          slot in each new instance of the containing class (and its
          subclasses).

        * `#:class'

          Indicates that GOOPS should create storage for this slot that
          is shared by all instances of the containing class (and its
          subclasses).  In other words, a slot in class C with
          allocation `#:class' is shared by all INSTANCEs for which
          `(is-a? INSTANCE C)'.

        * `#:each-subclass'

          Indicates that GOOPS should create storage for this slot that
          is shared by all _direct_ instances of the containing class,
          and that whenever a subclass of the containing class is
          defined, GOOPS should create a new storage for the slot that
          is shared by all _direct_ instances of the subclass.  In
          other words, a slot with allocation `#:each-subclass' is
          shared by all instances with the same `class-of'.

        * `#:virtual'

          Indicates that GOOPS should not allocate storage for this
          slot.  The slot definition must also include the `#:slot-ref'
          and `#:slot-set!' options to specify how to reference and set
          the value for this slot.

     The default value is `#:instance'.

     Slot allocation options are processed when defining a new class by
     the generic function `compute-get-n-set', which is specialized by
     the class's metaclass.  Hence new types of slot allocation can be
     implemented by defining a new metaclass and a method for
     `compute-get-n-set' that is specialized for the new metaclass.

     Suppose you wanted to create a large number of instances of some
     class with a slot that should be shared between some but not all
     instances of that class - say every 10 instances should share the
     same slot storage.  The following example shows how to implement
     and use a new type of slot allocation to do this.

          (define-class <batched-allocation-metaclass> (<class>))
          
          (let ((batch-allocation-count 0)
                (batch-get-n-set #f))
            (define-method compute-get-n-set ((class <batched-allocation-metaclass>) s)
              (case (slot-definition-allocation s)
                ((#:batched)
                 ;; If we've already used the same slot storage for 10 instances,
                 ;; reset variables.
                 (if (= batch-allocation-count 10)
                     (begin
                       (set! batch-allocation-count 0)
                       (set! batch-get-n-set #f)))
                 ;; If we don't have a current pair of get and set closures,
                 ;; create one.  make-closure-variable returns a pair of closures
                 ;; around a single Scheme variable - see goops.scm for details.
                 (or batch-get-n-set
                     (set! batch-get-n-set (make-closure-variable)))
                 ;; Increment the batch allocation count.
                 (set! batch-allocation-count (+ batch-allocation-count 1))
                 batch-get-n-set)
          
                ;; Call next-method to handle standard allocation types.
                (else (next-method)))))
          
          (define-class <class-using-batched-slot> ()
            ...
            (c #:allocation #:batched)
            ...
            #:metaclass <batched-allocation-metaclass>)

 - slot option: #:slot-ref getter
 - slot option: #:slot-set! setter
     The `#:slot-ref' and `#:slot-set!' options must be specified if
     the slot allocation is `#:virtual', and are ignored otherwise.

     GETTER should be a closure taking a single INSTANCE parameter that
     returns the current slot value.  SETTER should be a closure taking
     two parameters - INSTANCE and NEW-VAL - that sets the slot value
     to NEW-VAL.

 - slot option: #:getter getter
 - slot option: #:setter setter
 - slot option: #:accessor accessor
     These options, if present, tell GOOPS to create generic function
     and method definitions that can be used to get and set the slot
     value more conveniently than by using `slot-ref' and `slot-set!'.

     GETTER specifies a generic function to which GOOPS will add a
     method for getting the slot value.  SETTER specifies a generic
     function to which GOOPS will add a method for setting the slot
     value.  ACCESSOR specifies an accessor to which GOOPS will add
     methods for both getting and setting the slot value.

     So if a class includes a slot definition like this:

          (c #:getter get-count #:setter set-count #:accessor count)

     GOOPS defines generic function methods such that the slot value
     can be referenced using either the getter or the accessor -

          (let ((current-count (get-count obj))) ...)
          (let ((current-count (count obj))) ...)

     - and set using either the setter or the accessor -

          (set-count obj (+ 1 current-count))
          (set! (count obj) (+ 1 current-count))

     Note that

        * with an accessor, the slot value is set using the generalized
          `set!' syntax

        * in practice, it is unusual for a slot to use all three of
          these options: read-only, write-only and read-write slots
          would typically use only `#:getter', `#:setter' and
          `#:accessor' options respectively.

     If the specified names are already bound in the top-level
     environment to values that cannot be upgraded to generic
     functions, those values are overwritten during evaluation of the
     `define-class' that contains the slot definition.  For details,
     see *Note ensure-generic: Generic Function Internals.

 - slot option: #:init-value init-value
 - slot option: #:init-form init-form
 - slot option: #:init-thunk init-thunk
 - slot option: #:init-keyword init-keyword
     These options provide various ways to specify how to initialize the
     slot's value at instance creation time.  INIT-VALUE is a fixed
     value.  INIT-THUNK is a procedure of no arguments that is called
     when a new instance is created and should return the desired
     initial slot value.  INIT-FORM is an unevaluated expression that
     gets evaluated when a new instance is created and should return
     the desired initial slot value.  INIT-KEYWORD is a keyword that
     can be used to pass an initial slot value to `make' when creating
     a new instance.

     If more than one of these options is specified for the same slot,
     the order of precedence, highest first is

        * `#:init-keyword', if INIT-KEYWORD is present in the options
          passed to `make'

        * `#:init-thunk' and `#:init-form' (with equal precedence)

        * `#:init-value'.

     If the slot definition contains more than one initialization
     option of the same precedence, the later ones are ignored.  If a
     slot is not initialized at all, its value is unbound.

     In general, slots that are shared between more than one instance
     are only initialized at new instance creation time if the slot
     value is unbound at that time.  However, if the new instance
     creation specifies a valid init keyword and value for a shared
     slot, the slot is re-initialized regardless of its previous value.

     Note, however, that the power of GOOPS' meta-object protocol means
     that everything written here may be customized or overriden for
     particular classes!  The slot initializations described here are
     performed by the least specialized method of the generic function
     `initialize', whose signature is

          (define-method initialize ((object <object>) initargs) ...)

     The initialization of instances of any given class can be
     customized by defining a `initialize' method that is specialized
     for that class, and the author of the specialized method may
     decide to call `next-method' - which will result in a call to the
     next less specialized `initialize' method - at any point within the
     specialized code, or maybe not at all.  In general, therefore, the
     initialization mechanisms described here may be modified or
     overriden by more specialized code, or may not be supported at all
     for particular classes.


File: goops.info,  Node: Class Definition Internals,  Next: Customizing Class Definition,  Prev: Slot Options,  Up: Defining New Classes

Class Definition Internals
--------------------------

 - procedure: ensure-metaclass supers env
     Return a metaclass suitable for a class that inherits from the
     list of classes in SUPERS.  The returned metaclass is the union by
     inheritance of the metaclasses of the classes in SUPERS.

     In the simplest case, where all the SUPERS are straightforward
     classes with metaclass `<class>', the returned metaclass is just
     `<class>'.

     For a more complex example, suppose that SUPERS contained one
     class with metaclass `<operator-class>' and one with metaclass
     `<foreign-object-class>'.  Then the returned metaclass would be a
     class that inherits from both `<operator-class>' and
     `<foreign-object-class>'.

     If SUPERS is the empty list, `ensure-metaclass' returns the
     default GOOPS metaclass `<class>'.

     GOOPS keeps a list of the metaclasses created by
     `ensure-metaclass', so that each required type of metaclass only
     has to be created once.

     The `env' parameter is ignored.

 - procedure: ensure-metaclass-with-supers meta-supers
     Return a metaclass that is the union by inheritance of the
     metaclasses in META-SUPERS.  For a more detailed discussion and
     examples, see *Note ensure-metaclass: Class Definition Internals.

 - syntax: class name (super ...) slot-definition ... . options
     Return a newly created class that inherits from SUPERs, with
     direct slots defined by SLOT-DEFINITIONs and class options
     OPTIONS.  For the format of SLOT-DEFINITIONs and OPTIONS, see
     *Note define-class: Basic Class Definition.

     Implementation notes: `class'

        * processes the class and slot definition options to check that
          they are well-formed, to convert the `#:init-form' option to
          an `#:init-thunk' option, to supply a default environment
          parameter (the current top-level environment) and to evaluate
          all the bits that need to be evaluated

        * calls `make-class' to create the class with the processed and
          evaluated parameters.

 - procedure: make-class supers slots . options
     Return a newly created class that inherits from SUPERS, with
     direct slots defined by SLOTS and class options OPTIONS.  For the
     format of SLOTS and OPTIONS, see *Note define-class: Basic Class
     Definition, except note that for `make-class', SLOTS and OPTIONS
     are separate list parameters: SLOTS here is a list of slot
     definitions.

     Implementation notes: `make-class'

        * adds `<object>' to the SUPERS list if SUPERS is empty or if
          none of the classes in SUPERS have `<object>' in their class
          precedence list

        * defaults the `#:environment', `#:name' and `#:metaclass'
          options, if they are not specified by OPTIONS, to the current
          top-level environment, the unbound value, and
          `(ensure-metaclass SUPERS)' respectively (*note
          ensure-metaclass: Class Definition Internals.)

        * checks for duplicate classes in SUPERS and duplicate slot
          names in SLOTS, and signals an error if there are any
          duplicates

        * calls `make', passing the metaclass as the first parameter
          and all other parameters as option keywords with values.


File: goops.info,  Node: Customizing Class Definition,  Next: STKlos Compatibility,  Prev: Class Definition Internals,  Up: Defining New Classes

Customizing Class Definition
----------------------------


File: goops.info,  Node: STKlos Compatibility,  Prev: Customizing Class Definition,  Up: Defining New Classes

STKlos Compatibility
--------------------

 - syntax: standard-define-class name (super ...) slot-definition ... .
          options
     If the STKlos compatibility module is loaded, `define-class' is
     overwritten by a STKlos-specific definition; the standard GOOPS
     definition of `define-class' remains available in
     `standard-define-class'.


File: goops.info,  Node: Creating Instances,  Next: Accessing Slots,  Prev: Defining New Classes,  Up: Reference Manual

Creating Instances
==================

* Menu:

* Basic Instance Creation::
* Customizing Instance Creation::


File: goops.info,  Node: Basic Instance Creation,  Next: Customizing Instance Creation,  Up: Creating Instances

Basic Instance Creation
-----------------------

 - generic: make
 - method: make (class <class>) . initargs
 - generic: make-instance
 - method: make-instance (class <class>) . initargs
     *fixme*


File: goops.info,  Node: Customizing Instance Creation,  Prev: Basic Instance Creation,  Up: Creating Instances

Customizing Instance Creation
-----------------------------


File: goops.info,  Node: Accessing Slots,  Next: Creating Generic Functions,  Prev: Creating Instances,  Up: Reference Manual

Accessing Slots
===============

* Menu:

* Class Slots::
* Instance Slots::
* Handling Slot Access Errors::


File: goops.info,  Node: Class Slots,  Next: Instance Slots,  Up: Accessing Slots

Class Slots
-----------

 - procedure: class-slot-ref class slot-name
     Return the value of the slot named SLOT-NAME in class CLASS.  The
     named slot must have `#:class' or `#:each-subclass' allocation
     (*note allocation: Slot Options.).

     If there is no such slot with `#:class' or `#:each-subclass'
     allocation, `class-slot-ref' calls the `slot-missing' generic
     function with arguments CLASS and SLOT-NAME.  Otherwise, if the
     slot value is unbound, `class-slot-ref' calls the `slot-missing'
     generic function, with the same arguments.

 - procedure: class-slot-set! class slot-name value
     Set the value of the slot named SLOT-NAME in class CLASS to VALUE.
     The named slot must have `#:class' or `#:each-subclass'
     allocation (*note allocation: Slot Options.).

     If there is no such slot with `#:class' or `#:each-subclass'
     allocation, `class-slot-ref' calls the `slot-missing' generic
     function with arguments CLASS and SLOT-NAME.


File: goops.info,  Node: Instance Slots,  Next: Handling Slot Access Errors,  Prev: Class Slots,  Up: Accessing Slots

Instance Slots
--------------


File: goops.info,  Node: Handling Slot Access Errors,  Prev: Instance Slots,  Up: Accessing Slots

Handling Slot Access Errors
---------------------------

 - generic: slot-missing
 - method: slot-missing (class <class>) slot-name
 - method: slot-missing (class <class>) (object <object>) slot-name
 - method: slot-missing (class <class>) (object <object>) slot-name
          value
     When an application attempts to reference or set a class or
     instance slot by name, and the slot name is invalid for the
     specified CLASS or OBJECT, GOOPS calls the `slot-missing' generic
     function.  The default methods all call `goops-error' with an
     appropriate message.

 - generic: slot-unbound
 - method: slot-unbound (object <object>)
 - method: slot-unbound (class <class>) slot-name
 - method: slot-unbound (class <class>) (object <object>) slot-name
     When an application attempts to reference a class or instance
     slot, and the slot's value is unbound, GOOPS calls the
     `slot-unbound' generic function.  The default methods all call
     `goops-error' with an appropriate message.


File: goops.info,  Node: Creating Generic Functions,  Next: Adding Methods to Generic Functions,  Prev: Accessing Slots,  Up: Reference Manual

Creating Generic Functions
==========================

* Menu:

* Basic Generic Function Creation::
* Generic Function Internals::
* Upgrading a Previous Non-Generic Procedure::
* Customizing Generic Function Creation::


File: goops.info,  Node: Basic Generic Function Creation,  Next: Generic Function Internals,  Up: Creating Generic Functions

Basic Generic Function Creation
-------------------------------

 - syntax: define-generic symbol
     Create a generic function with name SYMBOL and bind it to the
     variable SYMBOL.

     If the variable SYMBOL was previously bound to a Scheme procedure
     (or procedure-with-setter), the old procedure (and setter) is
     incorporated into the new generic function as its default
     procedure (and setter).  Any other previous value that was bound
     to SYMBOL, including an existing generic function, is overwritten
     by the new generic function.

     Implementation notes: `define-generic' calls `ensure-generic' to
     upgrade a pre-existing procedure value, or `make' with metaclass
     `<generic>' to create a new generic function.

 - syntax: define-accessor symbol
     Create an accessor with name SYMBOL and bind it to the variable
     SYMBOL.

     If the variable SYMBOL was previously bound to a Scheme procedure
     (or procedure-with-setter), the old procedure (and setter) is
     incorporated into the new accessor as its default procedure (and
     setter).  Any other previous value that was bound to SYMBOL,
     including an existing generic function or accessor, is overwritten
     by the new definition.

     Implementation notes: `define-accessor' calls `ensure-accessor' to
     upgrade a pre-existing procedure value, or `make-accessor' to
     create a new accessor.


File: goops.info,  Node: Generic Function Internals,  Next: Upgrading a Previous Non-Generic Procedure,  Prev: Basic Generic Function Creation,  Up: Creating Generic Functions

Generic Function Internals
--------------------------

 - procedure: make-generic . name
     Return a new generic function with name `(car NAME)'.

     Implementation notes: `make-generic' is a simple wrapper for
     `make' with metaclass `<generic>'.

 - procedure: ensure-generic old-definition . name
     Return a generic function with name NAME, if possible by using or
     upgrading OLD-DEFINITION.

     If OLD-DEFINITION is already a generic function, it is returned
     unchanged.

     If OLD-DEFINITION is a Scheme procedure or procedure-with-setter,
     `ensure-generic' returns a new generic function that uses
     OLD-DEFINITION for its default procedure and setter.

     Otherwise `ensure-generic' returns a new generic function with no
     defaults and no methods.

     Implementation notes: `ensure-generic' calls `make' with
     metaclasses `<generic>' and `<generic-with-setter>'.

 - procedure: make-accessor . name
     Return a new accessor with name `(car NAME)'.

     Implementation notes: `make-accessor' calls `make' twice, first
     with metaclass `<generic>' to create a generic function for the
     setter, then with metaclass `<generic-with-setter>' to create the
     accessor, passing the setter generic function as the value of the
     `#:setter' keyword.

 - procedure: ensure-accessor proc . name
     Return an accessor with name NAME, if possible by using or
     upgrading PROC.

     If PROC is already an accessor, it is returned unchanged.

     If PROC is a Scheme procedure, procedure-with-setter or generic
     function, `ensure-accessor' returns an accessor that reuses the
     reusable elements of PROC.

     Otherwise `ensure-accessor' returns a new accessor with no defaults
     and no methods.

     Implementation notes: `ensure-accessor' calls `make' with
     metaclass `<generic-with-setter>', as well as calls to
     `ensure-generic', `make-accessor' and (tail recursively)
     `ensure-accessor'.


File: goops.info,  Node: Upgrading a Previous Non-Generic Procedure,  Next: Customizing Generic Function Creation,  Prev: Generic Function Internals,  Up: Creating Generic Functions

Upgrading a Previous Non-Generic Procedure
------------------------------------------


File: goops.info,  Node: Customizing Generic Function Creation,  Prev: Upgrading a Previous Non-Generic Procedure,  Up: Creating Generic Functions

Customizing Generic Function Creation
-------------------------------------


File: goops.info,  Node: Adding Methods to Generic Functions,  Next: Invoking Generic Functions,  Prev: Creating Generic Functions,  Up: Reference Manual

Adding Methods to Generic Functions
===================================

* Menu:

* Basic Method Definition::
* Method Definition Internals::
* Customizing Method Definition::


File: goops.info,  Node: Basic Method Definition,  Next: Method Definition Internals,  Up: Adding Methods to Generic Functions

Basic Method Definition
-----------------------

 - syntax: define-method symbol (parameter ...) . body
     Define a method for the generic function or accessor SYMBOL with
     parameters PARAMETERs and body BODY.

     SYMBOL must be either a symbol for a variable bound to a generic
     function or accessor, or `(setter ACCESSOR-SYMBOL)', where
     ACCESSOR-SYMBOL is a symbol for a variable bound to an accessor.
     If the former, `define-method' defines a reference method for the
     specified generic function or accessor; if the latter,
     `define-method' defines a setter method for the specified accessor.
     The SYMBOL parameter is subject to these restrictions (rather than
     being allowed to be anything that evaluates to a generic function)
     so that `define-method' can construct a call to `define-generic'
     or `define-accessor' if SYMBOL is not already defined as a generic
     function.

     Each PARAMETER must be either a symbol or a two-element list
     `(SYMBOL CLASS)'.  The symbols refer to variables in the BODY that
     will be bound to the parameters supplied by the caller when
     calling this method.  The CLASSes, if present, specify the
     possible combinations of parameters to which this method can be
     applied.

     For example, if a generic function method is defined with
     PARAMETERs `((s1 <square>) (n <number>))', that method is only
     applicable to invocations of its generic function that have two
     parameters where the first parameter is an instance of the
     `<square>' class and the second parameter is a number.  (If a
     generic function is invoked with a combination of parameters for
     which there is no applicable method, GOOPS raises an error.)

     BODY is the body of the method definition.

     Implementation notes: `define-method'

        * checks the form of the first parameter, and applies the
          following steps to the accessor's setter if it has the
          `(setter ...)' form

        * interpolates a call to `define-generic' or `define-accessor'
          if a generic function is not already defined with the
          supplied name

        * calls `method' with the PARAMETERs and BODY, to make a new
          method instance

        * calls `add-method!' to add this method to the relevant generic
          function.


File: goops.info,  Node: Method Definition Internals,  Next: Customizing Method Definition,  Prev: Basic Method Definition,  Up: Adding Methods to Generic Functions

Method Definition Internals
---------------------------

 - generic: add-method! target method
     Generic function for adding method METHOD to TARGET.

 - method: add-method! (generic <generic>) (method <method>)
     Add method METHOD to the generic function GENERIC.

 - method: add-method! (proc <procedure>) (method <method>)
     If PROC is a procedure with generic capability (*note
     generic-capability?: Upgrading a Previous Non-Generic Procedure.),
     upgrade it to a primitive generic and add METHOD to its generic
     function definition.

     Implementation notes: looks broken to me in the current CVS, since
     I don't believe it is ever possible for `(generic-capability?
     <procedure>)' to be true.

 - method: add-method! (pg <primitive-generic>) (method <method>)
     Add method METHOD to the generic function definition of PG.

     Implementation notes: `(add-method! (primitive-generic-generic pg)
     method)'.

 - method: add-method! (whatever <top>) (method <method>)
     Raise an error indicating that WHATEVER is not a valid generic
     function.

 - syntax: method (parameter ...) . body
     Make a method whose specializers are defined by the classes in
     PARAMETERs and whose procedure definition is constructed from the
     PARAMETER symbols and BODY forms.

     The PARAMETER and BODY parameters should be as for `define-method'
     (*note define-method: Basic Method Definition.).

     Implementation notes: `method'

        * extracts formals and specializing classes from the PARAMETERs,
          defaulting the class for unspecialized parameters to `<top>'

        * creates a closure using the formals and the BODY forms

        * calls `make' with metaclass `<method>' and the specializers
          and closure using the `#:specializers' and `#:procedure'
          keywords.

 - procedure: make-method specializers procedure
     Make a method using SPECIALIZERS and PROCEDURE.

     SPECIALIZERS should be a list of classes that specifies the
     parameter combinations to which this method will be applicable.

     PROCEDURE should be the closure that will applied to the generic
     function parameters when this method is invoked.

     `make-method' is a simple wrapper around `make' with metaclass
     `<method>'.


File: goops.info,  Node: Customizing Method Definition,  Prev: Method Definition Internals,  Up: Adding Methods to Generic Functions

Customizing Method Definition
-----------------------------


File: goops.info,  Node: Invoking Generic Functions,  Next: Redefining a Class,  Prev: Adding Methods to Generic Functions,  Up: Reference Manual

Invoking Generic Functions
==========================

* Menu:

* Determining Which Methods to Apply::
* Handling Invocation Errors::


File: goops.info,  Node: Determining Which Methods to Apply,  Next: Handling Invocation Errors,  Up: Invoking Generic Functions

Determining Which Methods to Apply
----------------------------------


File: goops.info,  Node: Handling Invocation Errors,  Prev: Determining Which Methods to Apply,  Up: Invoking Generic Functions

Handling Invocation Errors
--------------------------

 - generic: no-method
 - method: no-method (gf <generic>) args
     When an application invokes a generic function, and no methods at
     all have been defined for that generic function, GOOPS calls the
     `no-method' generic function.  The default method calls
     `goops-error' with an appropriate message.

 - generic: no-applicable-method
 - method: no-applicable-method (gf <generic>) args
     When an application applies a generic function to a set of
     arguments, and no methods have been defined for those argument
     types, GOOPS calls the `no-applicable-method' generic function.
     The default method calls `goops-error' with an appropriate message.

 - generic: no-next-method
 - method: no-next-method (gf <generic>) args
     When a generic function method calls `(next-method)' to invoke the
     next less specialized method for that generic function, and no less
     specialized methods have been defined for the current generic
     function arguments, GOOPS calls the `no-next-method' generic
     function.  The default method calls `goops-error' with an
     appropriate message.


File: goops.info,  Node: Redefining a Class,  Next: Changing the Class of an Instance,  Prev: Invoking Generic Functions,  Up: Reference Manual

Redefining a Class
==================


File: goops.info,  Node: Changing the Class of an Instance,  Next: Introspection,  Prev: Redefining a Class,  Up: Reference Manual

Changing the Class of an Instance
=================================


File: goops.info,  Node: Introspection,  Next: Miscellaneous Functions,  Prev: Changing the Class of an Instance,  Up: Reference Manual

Introspection
=============

* Menu:

* Classes::
* Instances::
* Generic Functions::
* Generic Function Methods::

