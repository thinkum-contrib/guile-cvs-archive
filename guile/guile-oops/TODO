* Version information (also from Scheme level).

* Check guile version in configure.in

* Update mop.text

* Test method cache.

* Read and correct documentation.

* Remove assumption of single-symbol slot definitions from goops.c.

* Fix some *fixme*'s

* Make sure that all of Guile's primitive types are represented in the
  class hierarchy

* README-file with "How to get started"

** Warn that current generic methods aren't tail recursive!

* Introduction to Goops

* Make sure that Makefile.am mentions all files which should go into
  the distribution

* Test that `make dist' yields a nice distribution

* Beta-release Goops 0.9!

* with-slots, with-accessors

* Optimizations

** Implement top-sort and compute-std-cpl in C, use this during
   bootstrapping and remove Scheme version of compute-std-cpl in
   goops.scm.

** Don't call intern repeatedly in goops.c (see e.g. CALL_GF).

** Free-list of next-methods (c.f. print-states in print.c)

** Start using method caches for GF dispatch
Self-mutating form which cache type --> method mappings.

This will also make generic methods tail-recursive.

*** Don't forget to invalidate generic function caches
when classes are redefined

** Faster slot access

** Strategy for optimization of the MOP

Terminology: Let subprotocol F mean a series of generic function calls
that starts with a call to generic function F in the MOP.

Ex: The apply-generic is a subprotocol that includes
compute-applicable-methods and sort-applicable-methods.

It is possible to have a fairly extensive MOP and yet have an
efficient implementation for the standard case.

Currently, this is the case with the apply-generic protocol: The class
<generic> has the flag SCM_CLASSF_PURE_GENERIC set.  Instances of this
class follow an efficient C level implementation of the apply-generic
protocol, but instances to subclasses of <generic> use the Scheme
level protocol.

Here is a proposal for a different strategy to achieve the same goal:

Let generic functions belonging to a certain subprotocol be instances
to a subclass <SUBPROTOCOL-generic> of <generic>.  The idea is that
the optimized version of the MOP will be used on instances to all
classes which are "pure" with respect the protocol.  The purity is an
inherited property.

But, if the user specializes a function M which is an instance of
<SUBPROTOCOL-generic> to C, C will no longer be "pure".

Example: Let C be a subclass to <generic>.  Normally a function F
which is an instance of C will be applied using the optimized
apply-generic protocol.  But, if the user specializes
compute-applicable-methods to C, C will no longer be "pure" => F will
be applied using the full MOP.

More concretely, we could allocate an inherited class flag which tells
that a GF belongs to SUBPROTOCOL.  There is also a class flag which
tells that a CLASS is "pure" with respect to SUBPROTOCOL.

When the user specializes a function F to a class C, add-method! will
clear the purity flag of C if F has the SUBPROTOCOL flag set.

This could for example be done by always calling a magic function

  %touch F C

when specializing F to C in the first argument.

It is also necessary to pay attention to the positions of slots so
that instances of "pure" classes have slots on the positions where the
optimized protocols expect to find them.

** Design a new MOP for generic method application

** Implement ditto and optimize!

* MOP

** Make no-applicable-method CLOS-like (args)
