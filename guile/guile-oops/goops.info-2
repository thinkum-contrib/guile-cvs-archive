This is goops.info, produced by makeinfo version 4.0 from goops.texi.

INFO-DIR-SECTION Scheme Programming
START-INFO-DIR-ENTRY
* goops: (goops).          The GOOPS reference manual.
END-INFO-DIR-ENTRY

This file documents GOOPS, an object oriented extension for Guile.

Copyright (C) 1999, 2000 Free Software Foundation

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.


File: goops.info,  Node: Classes,  Next: Instances,  Up: Introspection

Classes
-------

 - procedure: class-slot-definition class slot-name
     Return the slot definition for the slot named SLOT-NAME in class
     CLASS.  SLOT-NAME should be a symbol.

 - procedure: slot-definition-name slot-def
     Extract and return the slot name from SLOT-DEF.

 - procedure: slot-definition-options slot-def
     Extract and return the slot options from SLOT-DEF.

 - procedure: slot-definition-allocation slot-def
     Extract and return the slot allocation option from SLOT-DEF.  This
     is the value of the `#:allocation' keyword (*note allocation: Slot
     Options.), or `#:instance' if the `#:allocation' keyword is absent.

 - procedure: slot-definition-getter slot-def
     Extract and return the slot getter option from SLOT-DEF.  This is
     the value of the `#:getter' keyword (*note getter: Slot Options.),
     or `#f' if the `#:getter' keyword is absent.

 - procedure: slot-definition-setter slot-def
     Extract and return the slot setter option from SLOT-DEF.  This is
     the value of the `#:setter' keyword (*note setter: Slot Options.),
     or `#f' if the `#:setter' keyword is absent.

 - procedure: slot-definition-accessor slot-def
     Extract and return the slot accessor option from SLOT-DEF.  This
     is the value of the `#:accessor' keyword (*note accessor: Slot
     Options.), or `#f' if the `#:accessor' keyword is absent.

 - procedure: slot-definition-init-value slot-def
     Extract and return the slot init-value option from SLOT-DEF.  This
     is the value of the `#:init-value' keyword (*note init-value: Slot
     Options.), or the unbound value if the `#:init-value' keyword is
     absent.

 - procedure: slot-definition-init-form slot-def
     Extract and return the slot init-form option from SLOT-DEF.  This
     is the value of the `#:init-form' keyword (*note init-form: Slot
     Options.), or the unbound value if the `#:init-form' keyword is
     absent.

 - procedure: slot-definition-init-thunk slot-def
     Extract and return the slot init-thunk option from SLOT-DEF.  This
     is the value of the `#:init-thunk' keyword (*note init-thunk: Slot
     Options.), or `#f' if the `#:init-thunk' keyword is absent.

 - procedure: slot-definition-init-keyword slot-def
     Extract and return the slot init-keyword option from SLOT-DEF.
     This is the value of the `#:init-keyword' keyword (*note
     init-keyword: Slot Options.), or `#f' if the `#:init-keyword'
     keyword is absent.

 - procedure: slot-init-function class slot-name
     Return the initialization function for the slot named SLOT-NAME in
     class CLASS.  SLOT-NAME should be a symbol.

     The returned initialization function incorporates the effects of
     the standard `#:init-thunk', `#:init-form' and `#:init-value' slot
     options.  These initializations can be overriden by the
     `#:init-keyword' slot option or by a specialized `initialize'
     method, so, in general, the function returned by
     `slot-init-function' may be irrelevant.  For a fuller discussion,
     see *Note init-value: Slot Options.


File: goops.info,  Node: Instances,  Next: Generic Functions,  Prev: Classes,  Up: Introspection

Instances
---------

 - procedure: is-a? object class
     Return `#t' if OBJECT is an instance of CLASS or one of its
     subclasses.

     Implementation notes: `is-a?' uses `class-of' and
     `class-precedence-list' to obtain the class precedence list for
     OBJECT.


File: goops.info,  Node: Generic Functions,  Next: Generic Function Methods,  Prev: Instances,  Up: Introspection

Generic Functions
-----------------


File: goops.info,  Node: Generic Function Methods,  Prev: Generic Functions,  Up: Introspection

Generic Function Methods
------------------------

 - generic: method-source
 - method: method-source (m <method>)
     Return an expression that prints to show the definition of method
     M.

          (define-generic cube)
          (define-method cube ((n <number>))
            (* n n n))
          (map method-source (generic-function-methods cube))
          =>
          ((method ((n <number>)) (* n n n)))


File: goops.info,  Node: Miscellaneous Functions,  Prev: Introspection,  Up: Reference Manual

Miscellaneous Functions
=======================

* Menu:

* Administrative Functions::
* Error Handling::
* Object Comparisons::
* Cloning Objects::
* Write and Display::


File: goops.info,  Node: Administrative Functions,  Next: Error Handling,  Up: Miscellaneous Functions

Administration Functions
------------------------

This section describes administrative, non-technical GOOPS functions.

 - primitive: goops-version
     Return the current GOOPS version as a string, for example "0.2".


File: goops.info,  Node: Error Handling,  Next: Object Comparisons,  Prev: Administrative Functions,  Up: Miscellaneous Functions

Error Handling
--------------

 - procedure: goops-error format-string . args
     Raise an error with key `goops-error' and error message constructed
     from FORMAT-STRING and ARGS.  Error message formatting is as done
     by `scm-error'.

     `goops-error' is used to raise an appropriate error by the default
     methods of the following generic functions.  If you customize these
     functions for particular classes or metaclasses, you may still
     want to use `goops-error' to signal any error conditions that you
     detect.


File: goops.info,  Node: Object Comparisons,  Next: Cloning Objects,  Prev: Error Handling,  Up: Miscellaneous Functions

Object Comparisons
------------------

 - generic: object-eqv?
 - method: object-eqv? ((x <top>) (y <top>))
 - generic: object-equal?
 - method: object-equal? ((x <top>) (y <top>))
     Generic functions and default (unspecialized) methods for
     comparing two GOOPS objects.

     The default methods always return `#f'.  Application class authors
     may wish to define specialized methods for `object-eqv?' and
     `object-equal?' that compare instances of the same class for
     equality in whatever sense is useful to the application.


File: goops.info,  Node: Cloning Objects,  Next: Write and Display,  Prev: Object Comparisons,  Up: Miscellaneous Functions

Cloning Objects
---------------

 - generic: shallow-clone
 - method: shallow-clone (self <object>)
     Return a "shallow" clone of SELF.  The default method makes a
     shallow clone by allocating a new instance and copying slot values
     from self to the new instance.  Each slot value is copied either
     as an immediate value or by reference.

 - generic: deep-clone
 - method: deep-clone (self <object>)
     Return a "deep" clone of SELF.  The default method makes a deep
     clone by allocating a new instance and copying or cloning slot
     values from self to the new instance.  If a slot value is an
     instance (satisfies `instance?'), it is cloned by calling
     `deep-clone' on that value.  Other slot values are copied either
     as immediate values or by reference.


File: goops.info,  Node: Write and Display,  Prev: Cloning Objects,  Up: Miscellaneous Functions

Write and Display
-----------------

 - primitive generic: write object port
 - primitive generic: display object port
     When GOOPS is loaded, `write' and `display' become generic
     functions with special methods for printing

        * objects - instances of the class `<object>'

        * foreign objects - instances of the class `<foreign-object>'

        * classes - instances of the class `<class>'

        * generic functions - instances of the class `<generic>'

        * methods - instances of the class `<method>'.

     `write' and `display' print non-GOOPS values in the same way as
     the Guile primitive `write' and `display' functions.


File: goops.info,  Node: MOP Specification,  Next: Tutorial,  Prev: Reference Manual,  Up: Top

MOP Specification
*****************


File: goops.info,  Node: Tutorial,  Next: Index,  Prev: MOP Specification,  Up: Top

Tutorial
********

This is chapter was originally written by Erick Gallesio as an appendix
for the STk reference manual, and subsequently adapted to GOOPS.

* Menu:

* Copyright::
* Intro::
* Class definition and instantiation::
* Inheritance::
* Generic functions::


File: goops.info,  Node: Copyright,  Next: Intro,  Prev: Tutorial,  Up: Tutorial

Copyright
=========

Original attribution:

STk Reference manual (Appendix: An Introduction to STklos)

Copyright © 1993-1999 Erick Gallesio - I3S-CNRS/ESSI <eg@unice.fr>
Permission to use, copy, modify, distribute,and license this software
and its documentation for any purpose is hereby granted, provided that
existing copyright notices are retained in all copies and that this
notice is included verbatim in any distributions.  No written
agreement, license, or royalty fee is required for any of the
authorized uses.  This software is provided "AS IS" without express or
implied warranty.

Adapted for use in Guile with the authors permission


File: goops.info,  Node: Intro,  Next: Class definition and instantiation,  Prev: Copyright,  Up: Tutorial

Introduction
============

GOOPS is the object oriented extension to Guile. Its implementation is
derived from STk-3.99.3 by Erick Gallesio and version 1.3 of the Gregor
Kiczales `Tiny-Clos'.  It is very close to CLOS, the Common Lisp Object
System (`CLtL2') but is adapted for the Scheme language.

Briefly stated, the GOOPS extension gives the user a full object
oriented system with multiple inheritance and generic functions with
multi-method dispatch.  Furthermore, the implementation relies on a true
meta object protocol, in the spirit of the one defined for CLOS
(`Gregor Kiczales: A Metaobject Protocol').

The purpose of this tutorial is to introduce briefly the GOOPS package
and in no case will it replace the GOOPS reference manual (which needs
to be urgently written now ...).

Note that the operations described in this tutorial resides in modules
that may need to be imported before being available.  The main module is
imported by evaluating:

     (use-modules (oop goops))


File: goops.info,  Node: Class definition and instantiation,  Next: Inheritance,  Prev: Intro,  Up: Tutorial

Class definition and instantiation
==================================

* Menu:

* Class definition::


File: goops.info,  Node: Class definition,  Prev: Class definition and instantiation,  Up: Class definition and instantiation

Class definition
----------------

A new class is defined with the `define-class'(1) macro. The syntax of
`define-class' is close to CLOS `defclass':

     (define-class CLASS (SUPERCLASS ...)
        SLOT-DESCRIPTION ...
        CLASS-OPTION ...)

Class options will not be discussed in this tutorial.  The list of
SUPERCLASSes specifies which classes to inherit properties from CLASS
(see *Note Inheritance:: for more details).  A SLOT-DESCRIPTION gives
the name of a slot and, eventually, some "properties" of this slot
(such as its initial value, the function which permit to access its
value, ...). Slot descriptions will be discussed in *Note Slot
description::.

As an example, let us define a type for representation of complex
numbers in terms of real numbers. This can be done with the following
class definition:

     (define-class  <complex> (<number>)
        r i)

This binds the variable `<complex>'(2) to a new class whose instances
contain two slots. These slots are called `r' an `i' and we suppose here
that they contain respectively the real part and the imaginary part of a
complex number. Note that this class inherits from `<number>' which is
a pre-defined class.  (`<number>' is the direct super class of the
pre-defined class `<complex>' which, in turn, is the super class of
`<real>' which is the super of `<integer>'.)(3).

---------- Footnotes ----------

(1) Don't forget to import the `(oop goops)' module

(2) `<complex>' is in fact a builtin class in GOOPS.  Because of this,
GOOPS will create a new class.  The old class will still serve as the
type for Guile's native complex numbers.

(3) With the new definition of `<complex>', a `<real>' is not a
`<complex>' since `<real>' inherits from ` <number>' rather than
`<complex>'. In practice, inheritance could be modified _a posteriori_,
if needed. However, this necessitates some knowledge of the meta object
protocol and it will not be shown in this document


File: goops.info,  Node: Inheritance,  Next: Generic functions,  Prev: Class definition and instantiation,  Up: Tutorial

Inheritance
===========

* Menu:

* Class hierarchy and inheritance of slots::
* Instance creation and slot access::
* Slot description::
* Class precedence list::


File: goops.info,  Node: Class hierarchy and inheritance of slots,  Next: Instance creation and slot access,  Prev: Inheritance,  Up: Inheritance

Class hierarchy and inheritance of slots
----------------------------------------

Inheritance is specified upon class definition. As said in the
introduction, GOOPS supports multiple inheritance.  Here are some class
definitions:

     (define-class A () a)
     (define-class B () b)
     (define-class C () c)
     (define-class D (A B) d a)
     (define-class E (A C) e c)
     (define-class F (D E) f)

`A', `B', `C' have a null list of super classes. In this case, the
system will replace it by the list which only contains `<object>', the
root of all the classes defined by `define-class'. `D', `E', `F' use
multiple inheritance: each class inherits from two previously defined
classes.  Those class definitions define a hierarchy which is shown in
Figure 1.  In this figure, the class `<top>' is also shown; this class
is the super class of all Scheme objects. In particular, `<top>' is the
super class of all standard Scheme types.

               <top>
               / \\\_____________________
              /   \\___________          \
             /     \           \          \
         <object>  <pair>  <procedure>  <number>
         /  |  \                           |
        /   |   \                          |
       A    B    C                      <complex>
       |\__/__   |                         |
        \ /   \ /                          |
         D     E                         <real>
          \   /                            |
            F                              |
                                        <integer>

                         _Fig 1: A class hierarchy_


The set of slots of a given class is calculated by taking the union of
the slots of all its super class. For instance, each instance of the
class D, defined before will have three slots (`a', `b' and `d'). The
slots of a class can be obtained by the `class-slots' primitive.  For
instance,

     (class-slots A) => ((a))
     (class-slots E) => ((a) (e) (c))
     (class-slots F) => ((e) (c) (b) (d) (a) (f))

_Note: _ The order of slots is not significant.


File: goops.info,  Node: Instance creation and slot access,  Next: Slot description,  Prev: Class hierarchy and inheritance of slots,  Up: Inheritance

Instance creation and slot access
---------------------------------

Creation of an instance of a previously defined class can be done with
the `make' procedure. This procedure takes one mandatory parameter
which is the class of the instance which must be created and a list of
optional arguments. Optional arguments are generally used to initialize
some slots of the newly created instance. For instance, the following
form

     (define c (make <complex>))

will create a new `<complex>' object and will bind it to the `c' Scheme
variable.

Accessing the slots of the new complex number can be done with the
`slot-ref' and the `slot-set!'  primitives. `Slot-set!' primitive
permits to set the value of an object slot and `slot-ref' permits to
get its value.

     (slot-set! c 'r 10)
     (slot-set! c 'i 3)
     (slot-ref c 'r) => 10
     (slot-ref c 'i) => 3

Using the `describe' function is a simple way to see all the slots of
an object at one time: this function prints all the slots of an object
on the standard output.

First load the module `(oop goops describe)':

     `(use-modules (oop goops describe))'

The expression

     (describe c)

will now print the following information on the standard output:

     #<<complex> 401d8638> is an instance of class <complex>
     Slots are:
          r = 10
          i = 3


File: goops.info,  Node: Slot description,  Next: Class precedence list,  Prev: Instance creation and slot access,  Up: Inheritance

Slot description
----------------

When specifying a slot, a set of options can be given to the system.
Each option is specified with a keyword. The list of authorized
keywords is given below:

   * `#:init-value' permits to supply a default value for the slot. This
     default value is obtained by evaluating the form given after the
     `#:init-form' in the global environment, at class definition time.

   * `#:init-thunk' permits to supply a thunk that will provide a
     default value for the slot. The value is obtained by evaluating the
     thunk a instance creation time.

   * `#:init-keyword' permits to specify the keyword for initializing a
     slot. The init-keyword may be provided during instance creation
     (i.e. in the `make' optional parameter list). Specifying such a
     keyword during instance initialization will supersede the default
     slot initialization possibly given with `#:init-form'.

   * `#:getter' permits to supply the name for the slot getter. The
     name binding is done in the environment of the `define-class'
     macro.

   * `#:setter' permits to supply the name for the slot setter. The
     name binding is done in the environment of the `define-class'
     macro.

   * `#:accessor' permits to supply the name for the slot accessor. The
     name binding is done in the global environment. An accessor
     permits to get and set the value of a slot. Setting the value of a
     slot is done with the extended version of `set!'.

   * `#:allocation' permits to specify how storage for the slot is
     allocated. Three kinds of allocation are provided.  They are
     described below:

        - `#:instance' indicates that each instance gets its own
          storage for the slot. This is the default.

        - `#:class' indicates that there is one storage location used
          by all the direct and indirect instances of the class. This
          permits to define a kind of global variable which can be
          accessed only by (in)direct instances of the class which
          defines this slot.

        - `#:each-subclass' indicates that there is one storage
          location used by all the direct instances of the class. In
          other words, if two classes are not siblings in the class
          hierarchy, they will not see the same value.

        - `#:virtual' indicates that no storage will be allocated for
          this slot.  It is up to the user to define a getter and a
          setter function for this slot. Those functions must be
          defined with the `#:slot-ref' and `#:slot-set!' options. See
          the example below.

To illustrate slot description, we shall redefine the `<complex>' class
seen before. A definition could be:

     (define-class <complex> (<number>)
        (r #:init-value 0 #:getter get-r #:setter set-r! #:init-keyword #:r)
        (i #:init-value 0 #:getter get-i #:setter set-i! #:init-keyword #:i))

With this definition, the `r' and `i' slot are set to 0 by default.
Value of a slot can also be specified by calling `make' with the `#:r'
and `#:i' keywords. Furthermore, the generic functions `get-r' and
`set-r!' (resp. `get-i' and `set-i!') are automatically defined by the
system to read and write the `r' (resp. `i') slot.

     (define c1 (make <complex> #:r 1 #:i 2))
     (get-r c1) => 1
     (set-r! c1 12)
     (get-r c1) => 12
     (define c2 (make <complex> #:r 2))
     (get-r c2) => 2
     (get-i c2) => 0

Accessors provide an uniform access for reading and writing an object
slot.  Writing a slot is done with an extended form of `set!' which is
close to the Common Lisp `setf' macro. So, another definition of the
previous `<complex>' class, using the `#:accessor' option, could be:

     (define-class <complex> (<number>)
        (r #:init-value 0 #:accessor real-part #:init-keyword #:r)
        (i #:init-value 0 #:accessor imag-part #:init-keyword #:i))

Using this class definition, reading the real part of the `c' complex
can be done with:
     (real-part c)
and setting it to the value contained in the `new-value' variable can
be done using the extended form of `set!'.
     (set! (real-part c) new-value)

Suppose now that we have to manipulate complex numbers with rectangular
coordinates as well as with polar coordinates. One solution could be to
have a definition of complex numbers which uses one particular
representation and some conversion functions to pass from one
representation to the other.  A better solution uses virtual slots. A
complete definition of the `<complex>' class using virtual slots is
given in Figure 2.

          (define-class <complex> (<number>)
             ;; True slots use rectangular coordinates
             (r #:init-value 0 #:accessor real-part #:init-keyword #:r)
             (i #:init-value 0 #:accessor imag-part #:init-keyword #:i)
             ;; Virtual slots access do the conversion
             (m #:accessor magnitude #:init-keyword #:magn
                #:allocation #:virtual
                #:slot-ref (lambda (o)
                            (let ((r (slot-ref o 'r)) (i (slot-ref o 'i)))
                              (sqrt (+ (* r r) (* i i)))))
                #:slot-set! (lambda (o m)
                              (let ((a (slot-ref o 'a)))
                                (slot-set! o 'r (* m (cos a)))
                                (slot-set! o 'i (* m (sin a))))))
             (a #:accessor angle #:init-keyword #:angle
                #:allocation #:virtual
                #:slot-ref (lambda (o)
                            (atan (slot-ref o 'i) (slot-ref o 'r)))
                #:slot-set! (lambda(o a)
                             (let ((m (slot-ref o 'm)))
                                (slot-set! o 'r (* m (cos a)))
                                (slot-set! o 'i (* m (sin a)))))))

     _Fig 2: A `<complex>' number class definition using virtual slots_





This class definition implements two real slots (`r' and `i'). Values
of the `m' and `a' virtual slots are calculated from real slot values.
Reading a virtual slot leads to the application of the function defined
in the `#:slot-ref' option. Writing such a slot leads to the
application of the function defined in the `#:slot-set!' option.  For
instance, the following expression

     (slot-set! c 'a 3)

permits to set the angle of the `c' complex number. This expression
conducts, in fact, to the evaluation of the following expression

     ((lambda o m)
         (let ((m (slot-ref o 'm)))
            (slot-set! o 'r (* m (cos a)))
            (slot-set! o 'i (* m (sin a))))
       c 3)

A more complete example is given below:

          (define c (make <complex> #:r 12 #:i 20))
          (real-part c) => 12
          (angle c) => 1.03037682652431
          (slot-set! c 'i 10)
          (set! (real-part c) 1)
          (describe c) =>
                    #<<complex> 401e9b58> is an instance of class <complex>
                    Slots are:
                         r = 1
                         i = 10
                         m = 10.0498756211209
                         a = 1.47112767430373

Since initialization keywords have been defined for the four slots, we
can now define the `make-rectangular' and `make-polar' standard Scheme
primitives.

     (define make-rectangular
        (lambda (x y) (make <complex> #:r x #:i y)))
     
     (define make-polar
        (lambda (x y) (make <complex> #:magn x #:angle y)))


File: goops.info,  Node: Class precedence list,  Prev: Slot description,  Up: Inheritance

Class precedence list
---------------------

A class may have more than one superclass.  (1) With single inheritance
(one superclass), it is easy to order the super classes from most to
least specific. This is the rule:

     Rule 1: Each class is more specific than its superclasses.

With multiple inheritance, ordering is harder. Suppose we have

     (define-class X ()
        (x #:init-value 1))
     
     (define-class Y ()
        (x #:init-value 2))
     
     (define-class Z (X Y)
        (...))

In this case, the `Z' class is more specific than the `X' or `Y' class
for instances of `Z'. However, the `#:init-value' specified in `X' and
`Y' leads to a problem: which one overrides the other?  The rule in
GOOPS, as in CLOS, is that the superclasses listed earlier are more
specific than those listed later.  So:

     Rule 2: For a given class, superclasses listed earlier are more
             specific than those listed later.

These rules are used to compute a linear order for a class and all its
superclasses, from most specific to least specific.  This order is
called the "class precedence list" of the class. Given these two rules,
we can claim that the initial form for the `x' slot of previous example
is 1 since the class `X' is placed before `Y' in class precedence list
of `Z'.

These two rules are not always enough to determine a unique order,
however, but they give an idea of how things work.  Taking the `F'
class shown in Figure 1, the class precedence list is

     (f d e a c b <object> <top>)

However, it is usually considered a bad idea for programmers to rely on
exactly what the order is.  If the order for some superclasses is
important, it can be expressed directly in the class definition.

The precedence list of a class can be obtained by the function
`class-precedence-list'. This function returns a ordered list whose
first element is the most specific class. For instance,

     (class-precedence-list B) => (#<<class> B 401b97c8>
                                          #<<class> <object> 401e4a10>
                                          #<<class> <top> 4026a9d8>)

However, this result is not too much readable; using the function
`class-name' yields a clearer result:

     (map class-name (class-precedence-list B)) => (B <object> <top>)

---------- Footnotes ----------

(1) This section is an adaptation of Jeff Dalton's (J.Dalton@ed.ac.uk)
`Brief introduction to CLOS'


File: goops.info,  Node: Generic functions,  Prev: Inheritance,  Up: Tutorial

Generic functions
=================

* Menu:

* Generic functions and methods::
* Next-method::
* Example::


File: goops.info,  Node: Generic functions and methods,  Next: Next-method,  Prev: Generic functions,  Up: Generic functions

Generic functions and methods
-----------------------------

Neither GOOPS nor CLOS use the message mechanism for methods as most
Object Oriented language do. Instead, they use the notion of "generic
functions".  A generic function can be seen as a methods "tanker". When
the evaluator requested the application of a generic function, all the
methods of this generic function will be grabbed and the most specific
among them will be applied. We say that a method M is _more specific_
than a method M' if the class of its parameters are more specific than
the M' ones.  To be more precise, when a generic function must be
"called" the system will:

  1. search among all the generic function those which are applicable

  2. sort the list of applicable methods in the "most specific" order

  3. call the most specific method of this list (i.e. the first method
     of the sorted methods list).

The definition of a generic function is done with the `define-generic'
macro. Definition of a new method is done with the `define-method'
macro.  Note that `define-method' automatically defines the generic
function if it has not been defined before. Consequently, most of the
time, the `define-generic' needs not be used.  Consider the following
definitions:

     (define-generic G)
     (define-method  G ((a <integer>) b) 'integer)
     (define-method  G ((a <real>) b) 'real)
     (define-method  G (a b) 'top)

The `define-generic' call defines G as a generic function. Note that
the signature of the generic function is not given upon definition,
contrarily to CLOS. This will permit methods with different signatures
for a given generic function, as we shall see later. The three next
lines define methods for the G generic function. Each method uses a
sequence of "parameter specializers" that specify when the given method
is applicable. A specializer permits to indicate the class a parameter
must belong to (directly or indirectly) to be applicable. If no
specializer is given, the system defaults it to `<top>'. Thus, the
first method definition is equivalent to

     (define-method G ((a <integer>) (b <top>)) 'integer)

Now, let us look at some possible calls to generic function G:

     (G 2 3)    => integer
     (G 2 #t)   => integer
     (G 1.2 'a) => real
     (G #t #f)  => top
     (G 1 2 3)  => error (since no method exists for 3 parameters)

The preceding methods use only one specializer per parameter list. Of
course, each parameter can use a specializer. In this case, the
parameter list is scanned from left to right to determine the
applicability of a method. Suppose we declare now

     (define-method G ((a <integer>) (b <number>))  'integer-number)
     (define-method G ((a <integer>) (b <real>))    'integer-real)
     (define-method G ((a <integer>) (b <integer>)) 'integer-integer)
     (define-method G (a (b <number>))              'top-number)

In this case,

     (G 1 2)   => integer-integer
     (G 1 1.0) => integer-real
     (G 1 #t)  => integer
     (G 'a 1)  => top-number


File: goops.info,  Node: Next-method,  Next: Example,  Prev: Generic functions and methods,  Up: Generic functions

Next-method
-----------

When a generic function is called, the list of applicable methods is
built. As mentioned before, the most specific method of this list is
applied (see *Note Generic functions and methods::). This method may
call the next method in the list of applicable methods. This is done by
using the special form `next-method'. Consider the following definitions

     (define-method Test ((a <integer>)) (cons 'integer (next-method)))
     (define-method Test ((a <number>))  (cons 'number  (next-method)))
     (define-method Test (a)             (list 'top))

With those definitions,

     (Test 1)   => (integer number top)
     (Test 1.0) => (number top)
     (Test #t)  => (top)


File: goops.info,  Node: Example,  Prev: Next-method,  Up: Generic functions

Example
-------

In this section we shall continue to define operations on the
`<complex>' class defined in Figure 2. Suppose that we want to use it
to implement complex numbers completely. For instance a definition for
the addition of two complexes could be

     (define-method new-+ ((a <complex>) (b <complex>))
       (make-rectangular (+ (real-part a) (real-part b))
                         (+ (imag-part a) (imag-part b))))

To be sure that the `+' used in the method `new-+' is the standard
addition we can do:

     (define-generic new-+)
     
     (let ((+ +))
       (define-method new-+ ((a <complex>) (b <complex>))
         (make-rectangular (+ (real-part a) (real-part b))
                           (+ (imag-part a) (imag-part b)))))

The `define-generic' ensures here that `new-+' will be defined in the
global environment. Once this is done, we can add methods to the
generic function `new-+' which make a closure on the `+' symbol.  A
complete writing of the `new-+' methods is shown in Figure 3.

          (define-generic new-+)
          
          (let ((+ +))
          
            (define-method new-+ ((a <real>) (b <real>)) (+ a b))
          
            (define-method new-+ ((a <real>) (b <complex>))
              (make-rectangular (+ a (real-part b)) (imag-part b)))
          
            (define-method new-+ ((a <complex>) (b <real>))
              (make-rectangular (+ (real-part a) b) (imag-part a)))
          
            (define-method new-+ ((a <complex>) (b <complex>))
              (make-rectangular (+ (real-part a) (real-part b))
                                (+ (imag-part a) (imag-part b))))
          
            (define-method new-+ ((a <number>))  a)
          
            (define-method new-+ () 0)
          
            (define-method new-+ args  (new-+ (car args)
                                              (apply new-+ (cdr args)))))
          
          (set! + new-+)

          _Fig 3: Extending `+' for dealing with complex numbers_





We use here the fact that generic function are not obliged to have the
same number of parameters, contrarily to CLOS.  The four first methods
implement the dyadic addition. The fifth method says that the addition
of a single element is this element itself. The sixth method says that
using the addition with no parameter always return 0. The last method
takes an arbitrary number of parameters(1).  This method acts as a kind
of `reduce': it calls the dyadic addition on the _car_ of the list and
on the result of applying it on its rest.  To finish, the `set!'
permits to redefine the `+' symbol to our extended addition.




To terminate our implementation (integration?) of  complex numbers, we
can redefine standard Scheme predicates in the following manner:

     (define-method complex? (c <complex>) #t)
     (define-method complex? (c)           #f)
     
     (define-method number? (n <number>) #t)
     (define-method number? (n)          #f)
     ...
     ...

Standard primitives in which complex numbers are involved could also be
redefined in the same manner.

---------- Footnotes ----------

(1) The third parameter of a `define-method' is a parameter list which
follow the conventions used for lambda expressions. In particular it
can use the dot notation or a symbol to denote an arbitrary number of
parameters


File: goops.info,  Node: Index,  Next: Concept Index,  Prev: Tutorial,  Up: Top

Index
*****


File: goops.info,  Node: Concept Index,  Next: Function and Variable Index,  Prev: Index,  Up: Top

Concept Index
=============

* Menu:

* accessor:                              Slot description.
* class:                                 Class definition.
* default slot value:                    Slot description.
* generic function:                      Generic functions and methods.
* getter:                                Slot description.
* instance:                              Instance creation and slot access.
* keyword:                               Slot description.
* loading:                               Intro.
* main module:                           Intro.
* parameter specializers:                Generic functions and methods.
* preparing:                             Intro.
* setter:                                Slot description.
* slot:                                  Class definition.
* top level environment:                 Slot description.


File: goops.info,  Node: Function and Variable Index,  Prev: Concept Index,  Up: Top

Function and Variable Index
===========================

* Menu:

* #:accessor <1>:                        Slot description.
* #:accessor:                            Slot Options.
* #:allocation <1>:                      Slot description.
* #:allocation:                          Slot Options.
* #:class:                               Slot description.
* #:each-subclass:                       Slot description.
* #:getter <1>:                          Slot description.
* #:getter:                              Slot Options.
* #:init-form:                           Slot Options.
* #:init-keyword <1>:                    Slot description.
* #:init-keyword:                        Slot Options.
* #:init-thunk <1>:                      Slot description.
* #:init-thunk:                          Slot Options.
* #:init-value <1>:                      Slot description.
* #:init-value:                          Slot Options.
* #:instance:                            Slot description.
* #:setter <1>:                          Slot description.
* #:setter:                              Slot Options.
* #:slot-ref <1>:                        Slot description.
* #:slot-ref:                            Slot Options.
* #:slot-set! <1>:                       Slot description.
* #:slot-set!:                           Slot Options.
* #:virtual:                             Slot description.
* (oop goops):                           Intro.
* add-method!:                           Method Definition Internals.
* class:                                 Class Definition Internals.
* class-slot-definition:                 Classes.
* class-slot-ref:                        Class Slots.
* class-slot-set!:                       Class Slots.
* deep-clone:                            Cloning Objects.
* default slot value:                    Slot description.
* define-accessor:                       Basic Generic Function Creation.
* define-class <1>:                      Class definition.
* define-class:                          Basic Class Definition.
* define-generic <1>:                    Generic functions and methods.
* define-generic:                        Basic Generic Function Creation.
* define-method <1>:                     Generic functions and methods.
* define-method:                         Basic Method Definition.
* display:                               Write and Display.
* ensure-accessor:                       Generic Function Internals.
* ensure-generic:                        Generic Function Internals.
* ensure-metaclass:                      Class Definition Internals.
* ensure-metaclass-with-supers:          Class Definition Internals.
* goops-error:                           Error Handling.
* goops-version:                         Administrative Functions.
* is-a?:                                 Instances.
* make <1>:                              Instance creation and slot access.
* make:                                  Basic Instance Creation.
* make-accessor:                         Generic Function Internals.
* make-class:                            Class Definition Internals.
* make-generic:                          Generic Function Internals.
* make-instance:                         Basic Instance Creation.
* make-method:                           Method Definition Internals.
* method:                                Method Definition Internals.
* method-source:                         Generic Function Methods.
* no-applicable-method:                  Handling Invocation Errors.
* no-method:                             Handling Invocation Errors.
* no-next-method:                        Handling Invocation Errors.
* object-equal?:                         Object Comparisons.
* object-eqv?:                           Object Comparisons.
* set!:                                  Slot description.
* shallow-clone:                         Cloning Objects.
* slot-definition-accessor:              Classes.
* slot-definition-allocation:            Classes.
* slot-definition-getter:                Classes.
* slot-definition-init-form:             Classes.
* slot-definition-init-keyword:          Classes.
* slot-definition-init-thunk:            Classes.
* slot-definition-init-value:            Classes.
* slot-definition-name:                  Classes.
* slot-definition-options:               Classes.
* slot-definition-setter:                Classes.
* slot-init-function:                    Classes.
* slot-missing:                          Handling Slot Access Errors.
* slot-ref:                              Instance creation and slot access.
* slot-set!:                             Instance creation and slot access.
* slot-unbound:                          Handling Slot Access Errors.
* standard-define-class:                 STKlos Compatibility.
* write:                                 Write and Display.


